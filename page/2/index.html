<!DOCTYPE html>
<html lang="zh-CN">
    <head>
	<meta name="generator" content="Hugo 0.80.0" />
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>povcfe&#39;s blog</title><meta name="Description" content="povcfe&#39;s blog"><meta property="og:title" content="povcfe&#39;s blog" />
<meta property="og:description" content="povcfe&#39;s blog" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://povcfe.github.io/" />
<meta property="og:image" content="https://povcfe.github.io/logo.png"/>
<meta property="og:updated_time" content="2022-04-30T03:12:33-07:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://povcfe.github.io/logo.png"/>

<meta name="twitter:title" content="povcfe&#39;s blog"/>
<meta name="twitter:description" content="povcfe&#39;s blog"/>
<meta name="application-name" content="povcfe&#39;s blog">
<meta name="apple-mobile-web-app-title" content="povcfe&#39;s blog"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://povcfe.github.io/" /><link rel="alternate" href="/index.xml" type="application/rss+xml" title="povcfe&#39;s blog">
    <link rel="feed" href="/index.xml" type="application/rss+xml" title="povcfe&#39;s blog"><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "WebSite",
        "url": "https:\/\/povcfe.github.io\/","inLanguage": "zh-CN","description": "povcfe's blog","name": "povcfe's blog"
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="povcfe&#39;s blog">povcfe&#39;s blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="povcfe&#39;s blog">povcfe&#39;s blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="page home" posts><div class="home-profile"><div class="home-avatar"><a href="/posts/" title="所有文章"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/avatar.jpg"
        data-srcset="/images/avatar.jpg, /images/avatar.jpg 1.5x, /images/avatar.jpg 2x"
        data-sizes="auto"
        alt="/images/avatar.jpg"
        title="/images/avatar.jpg" /></a></div><h1 class="home-title">the more u learn, the less u know</h1><h2 class="home-subtitle">玄武实验室安全研究员, 专注于内核与Httpd漏洞挖掘</h2><div class="links"><a href="https://github.com/povcfe" title="GitHub" target="_blank" rel="noopener noreffer me"><i class="fab fa-github-alt fa-fw"></i></a><a href="https://twitter.com/povcfe" title="Twitter" target="_blank" rel="noopener noreffer me"><i class="fab fa-twitter fa-fw"></i></a><a href="https://www.zhihu.com/people/po-vcfen" title="知乎" target="_blank" rel="noopener noreffer me"><i data-svg-src="/lib/simple-icons/icons/zhihu.min.svg"></i></a><a href="mailto:41bll521@gmail.com" title="Email" rel=" me"><i class="far fa-envelope fa-fw"></i></a><a href="/index.xml" title="RSS" target="_blank" rel="noopener noreffer me"><i class="fas fa-rss fa-fw"></i></a></div><h3 class="home-disclaimer">转载必须注明原链接</h3></div>
<article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/posts/kernel_boot/">linux内核(5.4.81)---内核引导</a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class="post-publish">发布于 <time datetime="2020-06-06">2020-06-06</time></span>&nbsp;<span class="post-category">收录于 <a href="/categories/linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="far fa-folder fa-fw"></i>linux内核源码分析</a></span></div><div class="content">发表于看雪论坛
 本文详细讲解linux内核的加载过程，参考linux-insiders，并结合linux-5.6.6代码对原文的部分老旧内容做修改
 引导   按下电源开关后, CPU设置寄存器为预定值，程序在实模式下运行，程序首先执行0xfffffff0(映射至ROM)处内容，此处为复位向量，直接跳转至BIOS。
  BIOS初始化，检查硬件，寻找可引导设备，跳转至引导扇区代码(boot.img)
  寻找可引导设备方式: 定位MBR分区, 引导扇区存储在第一个扇区(512字节)的头446字节处。引导扇区以0x55和0xaa(magic bytes)结束。
  MBR分区代码只占用一个扇区, 空间较小，只执行了一些初始化工作, 然后跳转至GRUB2的core image(以diskboot.img为起始)继续执行。
    core image的初始化代码将剩余的core image(包含GRUB 2的内核代码和文件系统驱动)加载到内存中，运行grub_main
  grub_main 初始化控制台，计算模块基地址，设置root设备，读取 grub 配置文件，加载模块等，最后将grub切换为normal模式
  normal模式调用grub_normal_execute完成最后的准备工作，显示一个菜单列出可用的操作系统。
  选择操作系统后grub_menu_execute_entry被调用，用以运行boot命令，引导操作系统, 运行kernel代码
  内核自带bootloader，但是新版本内核已经弃用
  kernel boot protocol规定，bootloader必须具备协议中规定的头信息
      实模式运行内核   kernel地址(header.S _start)位于X + sizeof(KernelBootSector) + 1
 内核加载进入内存后，空间排布   | Protected-mode kernel | 100000 +------------------------+ | I/O memory hole | 0A0000 +------------------------+ | Reserved for BIOS | Leave as much as possible unused ~ ~ | Command line | (Can also be below the X+10000 mark) X+10000 +------------------------+ | Stack/heap | For use by the kernel real-mode code.</div><div class="post-footer">
        <a href="/posts/kernel_boot/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/linux-kernel/">linux kernel</a>,&nbsp;<a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a>,&nbsp;<a href="/tags/boot/">boot</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/posts/kernel_rw4/">linux 内核提权总结(demo&#43;exp分析) -- 任意读写(四)</a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class="post-publish">发布于 <time datetime="2020-02-02">2020-02-02</time></span>&nbsp;<span class="post-category">收录于 <a href="/categories/linux%E5%86%85%E6%A0%B8%E6%80%81%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"><i class="far fa-folder fa-fw"></i>linux内核态漏洞利用</a></span></div><div class="content">发表于看雪论坛
hijack_modprobe_path篇   原理同hijack_prctl, 当用户执行错误格式的elf文件时内核调用call_usermodehelper(char *modprobe_path &hellip;)
  修改modprobe后，即可实现root权限任意命令执行
  攻击流程
 (内核任意读写漏洞)内核修改全局变量 modprobe_path为目标指令 写入错误格式elf文件，并手动执行，触发    一. 利用步骤 1. 定位modprobe_path(开启kaslr)   同hijack_vdso，泄漏vdso地址，因为内核kaslr开启后，只有较高字节的地址发生偏移，且vdso与基地址相距较近，所以可以使用vdso定位内核加载地址
  获得当前调试阶段modprobe_path与内核基地址固定偏移
  modprobe_path_addr = 内核基地址+固定偏移
  2. 修改modprobe_path 为任意指令 二. 驱动代码(见cred) 三. exp #define _GNU_SOURCE  #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/auxv.h&gt;#include &lt;sys/prctl.h&gt; #define CHANGE_POINT 0x100000 #define RW_READ 0x100001 #define RW_WRITE 0x100002  size_t modprobe_path = 0xe3cba0; size_t vmlinux_base = 0; struct vunl { char *point; size_t size; } VUNL; void leak_data(int fd, char *buf) { char *res = NULL; VUNL.</div><div class="post-footer">
        <a href="/posts/kernel_rw4/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/linux-kernel/">linux kernel</a>,&nbsp;<a href="/tags/rw/">rw</a>,&nbsp;<a href="/tags/exp/">exp</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/posts/kernel_rw3/">linux 内核提权总结(demo&#43;exp分析) -- 任意读写(三) </a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class="post-publish">发布于 <time datetime="2020-01-30">2020-01-30</time></span>&nbsp;<span class="post-category">收录于 <a href="/categories/linux%E5%86%85%E6%A0%B8%E6%80%81%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"><i class="far fa-folder fa-fw"></i>linux内核态漏洞利用</a></span></div><div class="content">发表于看雪论坛
hijack_prctl篇   prctl函数: 用户态函数，可用于定制进程参数，非常适合和内核进行交互
 用户态执行prctl函数后触发prctl系统调用 内核接收参数后执行security_task_prctl security_task_prctl执行hook.task_prctl    poweroff_work_func函数: 内核函数，执行 run_cmd(poweroff_cmd)，即root权限执行poweroff_cmd
  攻击流程:
 劫持hook.task_prctl为目标函数地址(poweroff_work_func) 修改poweroff_cmd为目标指令 用户执行prctl函数，触发    一. 利用步骤 1. 定位内核加载基地址(开启kaslr)  同hijack_vdso，泄漏vdso地址，因为内核kaslr开启后，只有较高字节的地址发生偏移，且vdso与基地址相距较近，所以可以使用vdso定位内核加载地址  2. 定位hook.prctl，poweroff_cmd地址   gdb调试内核并在security_task_prctl函数处下断点，用户态程序执行prctl函数，进入security_task_prctl函数，单步执行汇编指令，通过内存查看hook.task_prctl 地址
  gdb 执行 p poweroff_cmd，获得poweroff_cmd真实地址
  获得hook.prctl，poweroff_cmd与内核基地址固定偏移
  3. 修改poweroff_cmd 为任意指令 4. 用户态执行prctl函数，触发 二. 驱动代码(见cred篇) 三. exp #define _GNU_SOURCE  #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/auxv.h&gt;#include &lt;sys/prctl.</div><div class="post-footer">
        <a href="/posts/kernel_rw3/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/linux-kernel/">linux kernel</a>,&nbsp;<a href="/tags/rw/">rw</a>,&nbsp;<a href="/tags/exp/">exp</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/posts/kernel_rw2/">linux 内核提权总结(demo&#43;exp分析) -- 任意读写(二)</a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class="post-publish">发布于 <time datetime="2020-01-21">2020-01-21</time></span>&nbsp;<span class="post-category">收录于 <a href="/categories/linux%E5%86%85%E6%A0%B8%E6%80%81%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"><i class="far fa-folder fa-fw"></i>linux内核态漏洞利用</a></span></div><div class="content">发表于看雪论坛
hijack_vdso篇   vdso: 内核实现的一个动态库，存在于内核，然后映射到用户态空间，可由用户态直接调用
 内核中的vdso如果被修改，那么用户态空间的vdso也会同步被修改    攻击流程
 (内核任意代码执行漏洞)内核调用set_memory_rw 函数修改内核vdso页面属性，使得用户态可以直接修改vdso，劫持vdso为shellcode，触发条件同1 (内核任意读写漏洞)内核修改内核vdso数据，写入shellcode，使得用户态vdso中函数被劫持，当高权限进程调用vdso中特定函数时，触发shellcode，本篇只讲解攻击流程2    一. 利用步骤 1. 定位内核态vdso位置   vdso中存在一些比较有特点的字符串，比如&quot;gettimeofday&quot;，在拥有任意读漏洞的前提下，从0xffffffff80000000(开启kaslr后内核基地址在此地址基础上往上偏移)开始按页搜索内存
  如果内存其他地方存在&quot;gettimeofday&quot;字符串，且出现在vdso之前，则会返回错误地址。所以在内存搜索时，应以返回地址为起始，使用gdb dump 0x2000 内存，使用ida查看是否是vdso，如果不是，可以忽略这个错误地址，继续向下搜索。
  得到真正的vdso后，查看&quot;gettimeofday&quot;与vdso起始地址的偏移，后续匹配vdso时，加上这个偏移条件
  2. 向内核中vdso写入shellcode   shellcode功能: 判断进程是否具有root权限，如果成立，则开辟新进程用来反弹root shell
  shellcode写入位置: 定位vdso上某函数，比如gettimeofday函数，使用shellcode覆盖
  shellcode触发条件: 当高权限进程调用gettimeofday函数时，自动执行shellcode 反弹root shell
  二. 驱动代码(见cred篇) 三. exp #define _GNU_SOURCE  #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/auxv.</div><div class="post-footer">
        <a href="/posts/kernel_rw2/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/linux-kernel/">linux kernel</a>,&nbsp;<a href="/tags/rw/">rw</a>,&nbsp;<a href="/tags/exp/">exp</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/posts/kernel_rw1/">linux 内核提权总结(demo&#43;exp分析) -- 任意读写(一)</a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class="post-publish">发布于 <time datetime="2020-01-11">2020-01-11</time></span>&nbsp;<span class="post-category">收录于 <a href="/categories/linux%E5%86%85%E6%A0%B8%E6%80%81%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"><i class="far fa-folder fa-fw"></i>linux内核态漏洞利用</a></span></div><div class="content">发表于看雪论坛
cred篇   每个线程在内核中都对应一个线程结构块thread_info
  thread_info中存在task_struct类型结构体
  struct task_struct中存在cred结构体用来保存线程权限
  攻击流程
 定位某进程的cred结构体 将cred结构提结构体的uid~fsgid全部覆写为0(前28字节)    一. 利用步骤 1. 定位cred结构体   task_struct中存在char comm[TASK_COMM_LEN]
  comm字符串使用prctl函数的PR_SET_NAME自行设置
  在内存中搜索被设置后的comm字符串，cred结构体地址就在附近
  泄漏cred结构体地址，定向覆盖cred结构体
  2. 进程权限被修改，变成root进程，执行system(&quot;/bin/sh&quot;)，弹出root shell 二. 驱动代码 #include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/device.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;asm/cacheflush.h&gt; #define CHANGE_POINT 0x100000 #define RW_READ 0x100001 #define RW_WRITE 0x100002 #define SET_MEM 0x100003  dev_t dev_id = 0; struct cdev cdev_0; struct class *dev_class; struct vunl { char *point; size_t size; } VUNL; long rw_any_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { int ret = 0; switch (cmd) { case CHANGE_POINT: ret = copy_from_user(&amp;VUNL, (struct vunl *)(arg), sizeof(struct vunl)); break; case RW_READ: ret = copy_to_user((char *)arg, (char *)VUNL.</div><div class="post-footer">
        <a href="/posts/kernel_rw1/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/linux-kernel/">linux kernel</a>,&nbsp;<a href="/tags/rw/">rw</a>,&nbsp;<a href="/tags/exp/">exp</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/posts/kernel_rop2/">linux 内核提权总结(demo&#43;exp分析) -- ROP(二)</a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class="post-publish">发布于 <time datetime="2020-01-06">2020-01-06</time></span>&nbsp;<span class="post-category">收录于 <a href="/categories/linux%E5%86%85%E6%A0%B8%E6%80%81%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"><i class="far fa-folder fa-fw"></i>linux内核态漏洞利用</a></span></div><div class="content">发表于看雪论坛
ret2usr CR4篇   smep: smep是内核的一种保护措施, 使得内核不可执行用户态代码
 内核通过CR4寄存器的第20位来控制smep, 第20位为0时，smep被关闭    攻击流程
 提前在用户态代码中构造进程提权代码(get_root) ROP技术修改CR4第20位数据为0(关闭smep), 通常使用 mov cr4, 0x6f0 修改 rip 直接指向用户态提权代码,实现进程提权    一. 判断是否开启smep  查看 boot.sh qemu-system-x86_64 \ -kernel bzImage \ -initrd rootfs.img \ -append &#34;console=ttyS0 root=/dev/ram rdinit=/sbin/init&#34; \ -cpu qemu64,+smep,+smap \ -nographic \ -gdb tcp::1234  smep, smap 在boot.sh -cpu选项内进行设置  二. ROP链构造 ROP[i++] = 0xffffffff810275f1 + offset; //pop rax; ret  ROP[i++] = 0x6f0; ROP[i++] = 0xffffffff8123ed93 + offset; //pop rcx; ret  ROP[i++] = 0; ROP[i++] = 0xffffffff81003c0e + offset; //mov cr4, rax ; push rcx ; popfq ; pop rbp ; ret  ROP[i++] = 0; ROP[i++] = (size_t)get_root; 三.</div><div class="post-footer">
        <a href="/posts/kernel_rop2/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/linux-kernel/">linux kernel</a>,&nbsp;<a href="/tags/rop/">rop</a>,&nbsp;<a href="/tags/exp/">exp</a></div></div>
</article><ul class="pagination"><li class="page-item ">
                    <span class="page-link">
                        <a href="/">1</a>
                    </span>
                </li><li class="page-item active">
                    <span class="page-link">
                        <a href="/page/2/">2</a>
                    </span>
                </li><li class="page-item ">
                    <span class="page-link">
                        <a href="/page/3/">3</a>
                    </span>
                </li></ul></div></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank"></a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
