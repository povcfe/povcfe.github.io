<!doctype html>









































<html
  class="not-ready lg:text-base"
  style="--bg: #faf8f1"
  lang="en-us"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>linux内核(5.6.6)---内核引导 - povcfe&#39;s site</title>

  
  <meta name="theme-color" />

  
  
  
  
  <meta name="description" content="发表于看雪论坛
本文详细讲解linux内核的加载过程，参考linux-insiders，并结合linux-5.6.6代码对原文的部分老旧内容做修改
引导 按下电源开关后, CPU设置寄存器为预定值，程序在实模式下运行，程序首先执行0xfffffff0(映射至ROM)处内容，此处为复位向量，直接跳转至BIOS。
BIOS初始化，检查硬件，寻找可引导设备，跳转至引导扇区代码(boot.img)
寻找可引导设备方式: 定位MBR分区, 引导扇区存储在第一个扇区(512字节)的头446字节处。引导扇区以0x55和0xaa(magic bytes)结束。
MBR分区代码只占用一个扇区, 空间较小，只执行了一些初始化工作, 然后跳转至GRUB2的core image(以diskboot.img为起始)继续执行。
core image的初始化代码将剩余的core image(包含GRUB 2的内核代码和文件系统驱动)加载到内存中，运行grub_main
grub_main 初始化控制台，计算模块基地址，设置root设备，读取 grub 配置文件，加载模块等，最后将grub切换为normal模式
normal模式调用grub_normal_execute完成最后的准备工作，显示一个菜单列出可用的操作系统。
选择操作系统后grub_menu_execute_entry被调用，用以运行boot命令，引导操作系统, 运行kernel代码
内核自带bootloader，但是新版本内核已经弃用
kernel boot protocol规定，bootloader必须具备协议中规定的头信息
实模式运行内核 kernel地址(header.S _start)位于X &#43; sizeof(KernelBootSector) &#43; 1
内核加载进入内存后，空间排布 | Protected-mode kernel | 100000 &#43;------------------------&#43; | I/O memory hole | 0A0000 &#43;------------------------&#43; | Reserved for BIOS | Leave as much as possible unused ~ ~ | Command line | (Can also be below the X&#43;10000 mark) X&#43;10000 &#43;------------------------&#43; | Stack/heap | For use by the kernel real-mode code." />
  <meta name="author" content="povcfe" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://www.povcfe.site/main.min.css" />

  
  
  
  
  
  <link rel="preload" as="image" href="https://www.povcfe.site/theme.png" />

  
  
  
  
  <link rel="preload" as="image" href="https://www.povcfe.site/avatar.jpg" />
  
  

  
  
  <link rel="preload" as="image" href="https://www.povcfe.site/twitter.svg" />
  
  <link rel="preload" as="image" href="https://www.povcfe.site/github.svg" />
  
  <link rel="preload" as="image" href="https://www.povcfe.site/rss.svg" />
  
  

  
  
  <script
    defer
    src="https://www.povcfe.site/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
  
  

  
  <link rel="icon" href="https://www.povcfe.site/favicon.ico" />
  <link rel="apple-touch-icon" href="https://www.povcfe.site/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.111.3">

  
  
  
  
  
  <meta itemprop="name" content="linux内核(5.6.6)---内核引导">
<meta itemprop="description" content="发表于看雪论坛
本文详细讲解linux内核的加载过程，参考linux-insiders，并结合linux-5.6.6代码对原文的部分老旧内容做修改
引导 按下电源开关后, CPU设置寄存器为预定值，程序在实模式下运行，程序首先执行0xfffffff0(映射至ROM)处内容，此处为复位向量，直接跳转至BIOS。
BIOS初始化，检查硬件，寻找可引导设备，跳转至引导扇区代码(boot.img)
寻找可引导设备方式: 定位MBR分区, 引导扇区存储在第一个扇区(512字节)的头446字节处。引导扇区以0x55和0xaa(magic bytes)结束。
MBR分区代码只占用一个扇区, 空间较小，只执行了一些初始化工作, 然后跳转至GRUB2的core image(以diskboot.img为起始)继续执行。
core image的初始化代码将剩余的core image(包含GRUB 2的内核代码和文件系统驱动)加载到内存中，运行grub_main
grub_main 初始化控制台，计算模块基地址，设置root设备，读取 grub 配置文件，加载模块等，最后将grub切换为normal模式
normal模式调用grub_normal_execute完成最后的准备工作，显示一个菜单列出可用的操作系统。
选择操作系统后grub_menu_execute_entry被调用，用以运行boot命令，引导操作系统, 运行kernel代码
内核自带bootloader，但是新版本内核已经弃用
kernel boot protocol规定，bootloader必须具备协议中规定的头信息
实模式运行内核 kernel地址(header.S _start)位于X &#43; sizeof(KernelBootSector) &#43; 1
内核加载进入内存后，空间排布 | Protected-mode kernel | 100000 &#43;------------------------&#43; | I/O memory hole | 0A0000 &#43;------------------------&#43; | Reserved for BIOS | Leave as much as possible unused ~ ~ | Command line | (Can also be below the X&#43;10000 mark) X&#43;10000 &#43;------------------------&#43; | Stack/heap | For use by the kernel real-mode code."><meta itemprop="datePublished" content="2020-06-06T00:00:00-04:00" />
<meta itemprop="dateModified" content="2020-06-06T00:00:00-04:00" />
<meta itemprop="wordCount" content="1591">
<meta itemprop="keywords" content="" />
  
  <meta property="og:title" content="linux内核(5.6.6)---内核引导" />
<meta property="og:description" content="发表于看雪论坛
本文详细讲解linux内核的加载过程，参考linux-insiders，并结合linux-5.6.6代码对原文的部分老旧内容做修改
引导 按下电源开关后, CPU设置寄存器为预定值，程序在实模式下运行，程序首先执行0xfffffff0(映射至ROM)处内容，此处为复位向量，直接跳转至BIOS。
BIOS初始化，检查硬件，寻找可引导设备，跳转至引导扇区代码(boot.img)
寻找可引导设备方式: 定位MBR分区, 引导扇区存储在第一个扇区(512字节)的头446字节处。引导扇区以0x55和0xaa(magic bytes)结束。
MBR分区代码只占用一个扇区, 空间较小，只执行了一些初始化工作, 然后跳转至GRUB2的core image(以diskboot.img为起始)继续执行。
core image的初始化代码将剩余的core image(包含GRUB 2的内核代码和文件系统驱动)加载到内存中，运行grub_main
grub_main 初始化控制台，计算模块基地址，设置root设备，读取 grub 配置文件，加载模块等，最后将grub切换为normal模式
normal模式调用grub_normal_execute完成最后的准备工作，显示一个菜单列出可用的操作系统。
选择操作系统后grub_menu_execute_entry被调用，用以运行boot命令，引导操作系统, 运行kernel代码
内核自带bootloader，但是新版本内核已经弃用
kernel boot protocol规定，bootloader必须具备协议中规定的头信息
实模式运行内核 kernel地址(header.S _start)位于X &#43; sizeof(KernelBootSector) &#43; 1
内核加载进入内存后，空间排布 | Protected-mode kernel | 100000 &#43;------------------------&#43; | I/O memory hole | 0A0000 &#43;------------------------&#43; | Reserved for BIOS | Leave as much as possible unused ~ ~ | Command line | (Can also be below the X&#43;10000 mark) X&#43;10000 &#43;------------------------&#43; | Stack/heap | For use by the kernel real-mode code." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.povcfe.site/post/kernel_boot/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-06-06T00:00:00-04:00" />
<meta property="article:modified_time" content="2020-06-06T00:00:00-04:00" />

  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="linux内核(5.6.6)---内核引导"/>
<meta name="twitter:description" content="发表于看雪论坛
本文详细讲解linux内核的加载过程，参考linux-insiders，并结合linux-5.6.6代码对原文的部分老旧内容做修改
引导 按下电源开关后, CPU设置寄存器为预定值，程序在实模式下运行，程序首先执行0xfffffff0(映射至ROM)处内容，此处为复位向量，直接跳转至BIOS。
BIOS初始化，检查硬件，寻找可引导设备，跳转至引导扇区代码(boot.img)
寻找可引导设备方式: 定位MBR分区, 引导扇区存储在第一个扇区(512字节)的头446字节处。引导扇区以0x55和0xaa(magic bytes)结束。
MBR分区代码只占用一个扇区, 空间较小，只执行了一些初始化工作, 然后跳转至GRUB2的core image(以diskboot.img为起始)继续执行。
core image的初始化代码将剩余的core image(包含GRUB 2的内核代码和文件系统驱动)加载到内存中，运行grub_main
grub_main 初始化控制台，计算模块基地址，设置root设备，读取 grub 配置文件，加载模块等，最后将grub切换为normal模式
normal模式调用grub_normal_execute完成最后的准备工作，显示一个菜单列出可用的操作系统。
选择操作系统后grub_menu_execute_entry被调用，用以运行boot命令，引导操作系统, 运行kernel代码
内核自带bootloader，但是新版本内核已经弃用
kernel boot protocol规定，bootloader必须具备协议中规定的头信息
实模式运行内核 kernel地址(header.S _start)位于X &#43; sizeof(KernelBootSector) &#43; 1
内核加载进入内存后，空间排布 | Protected-mode kernel | 100000 &#43;------------------------&#43; | I/O memory hole | 0A0000 &#43;------------------------&#43; | Reserved for BIOS | Leave as much as possible unused ~ ~ | Command line | (Can also be below the X&#43;10000 mark) X&#43;10000 &#43;------------------------&#43; | Stack/heap | For use by the kernel real-mode code."/>

  
  
  
  <link rel="canonical" href="https://www.povcfe.site/post/kernel_boot/" />
  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center">
  <div class="relative z-50 mr-auto flex items-center">
    <a
      class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold"
      href="https://www.povcfe.site/"
      >povcfe&#39;s site</a
    >
    <div
      class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]"
      role="button"
      aria-label="Dark"
    ></div>
  </div>

  <div
    class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
    role="button"
    aria-label="Menu"
  ></div>

  

  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = '#faf8f1'.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"
    >
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./twitter.svg)"
        href="https://twitter.com/povcfe"
        target="_blank"
        rel="me"
      >
        twitter
      </a>
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href="https://github.com/povcfe"
        target="_blank"
        rel="me"
      >
        github
      </a>
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./rss.svg)"
        href="https://www.povcfe.site/index.xml"
        target="_blank"
        rel="alternate"
      >
        rss
      </a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"
    >
      

<article>
  <header class="mb-16">
    <h1 class="!my-0 pb-2.5">linux内核(5.6.6)---内核引导</h1>

    
    <div class="text-sm antialiased opacity-60">
      
      <time>Jun 6, 2020</time>
      
      
      
      
    </div>
    
  </header>

  <section><p><a href="https://bbs.pediy.com/user-839858.htm">发表于看雪论坛</a></p>
<blockquote>
<p>本文详细讲解linux内核的加载过程，参考linux-insiders，并结合linux-5.6.6代码对原文的部分老旧内容做修改</p>
</blockquote>
<h1 id="引导">引导</h1>
<ol>
<li>
<p>按下电源开关后, CPU设置寄存器为预定值，程序在实模式下运行，程序首先执行0xfffffff0(映射至ROM)处内容，此处为复位向量，直接跳转至BIOS。</p>
</li>
<li>
<p>BIOS初始化，检查硬件，寻找可引导设备，跳转至引导扇区代码(boot.img)</p>
<ul>
<li>
<p>寻找可引导设备方式: 定位MBR分区, 引导扇区存储在第一个扇区(512字节)的头446字节处。引导扇区以0x55和0xaa(magic bytes)结束。</p>
</li>
<li>
<p>MBR分区代码只占用一个扇区, 空间较小，只执行了一些初始化工作, 然后跳转至GRUB2的core image(以diskboot.img为起始)继续执行。</p>
</li>
</ul>
</li>
<li>
<p>core image的初始化代码将剩余的core image(包含GRUB 2的内核代码和文件系统驱动)加载到内存中，运行grub_main</p>
<ul>
<li>
<p>grub_main 初始化控制台，计算模块基地址，设置root设备，读取 grub 配置文件，加载模块等，最后将grub切换为normal模式</p>
</li>
<li>
<p>normal模式调用grub_normal_execute完成最后的准备工作，显示一个菜单列出可用的操作系统。</p>
</li>
<li>
<p>选择操作系统后grub_menu_execute_entry被调用，用以运行boot命令，引导操作系统, 运行kernel代码</p>
<ul>
<li>
<p>内核自带bootloader，但是新版本内核已经弃用</p>
</li>
<li>
<p>kernel boot protocol规定，bootloader必须具备协议中规定的头信息</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="实模式运行内核">实模式运行内核</h1>
<ol>
<li>
<p>kernel地址(header.S _start)位于X + sizeof(KernelBootSector) + 1</p>
<ul>
<li>内核加载进入内存后，空间排布</li>
</ul>
<pre tabindex="0"><code>        | Protected-mode kernel  |
100000   +------------------------+
        | I/O memory hole        |
0A0000   +------------------------+
        | Reserved for BIOS      | Leave as much as possible unused
        ~                        ~
        | Command line           | (Can also be below the X+10000 mark)
X+10000  +------------------------+
        | Stack/heap             | For use by the kernel real-mode code.
X+08000  +------------------------+
        | Kernel setup           | The kernel real-mode code.
        | Kernel boot sector     | The kernel legacy boot sector.
    X +------------------------+
        | Boot loader            | &lt;- Boot sector entry point 0x7C00
001000   +------------------------+
        | Reserved for MBR/BIOS  |
000800   +------------------------+
        | Typically used by MBR  |
000600   +------------------------+
        | BIOS use only          |
000000   +------------------------+
</code></pre><ul>
<li>kernel初始代码功能: 设置段寄存器，堆栈，BSS段，跳转进入main</li>
</ul>
</li>
<li>
<p>main函数(主要用来填充boot_params参数)</p>
<ul>
<li>main函数解析
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">copy_boot_params</span>();
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">1. 将header.S中定义的hdr拷贝到boot_params结构体的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">struct setup_header hdr中。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">2. 如果内核是通过老的命令行协议运行起来的，那么就更新
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">内核的命令行指针(boot_params.hdr.cmd_line_ptr)。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Initialize the early-boot console */</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console_init</span>();
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">根据命令行参数设置串口,例如ttyS0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">cmdline_find_option_bool</span>(<span style="color:#e6db74">&#34;debug&#34;</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;early console in setup code</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* End of heap check */</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">init_heap</span>();
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">1. stack_end = esp - STACK_SIZE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">2. 如果heap_end大于stack_end，令stack_end=heap_end 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Make sure we have all the proper CPU support */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">查看当前CPU level，如果低于系统预设的最低CPU level,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">则系统停止运行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">validate_cpu</span>()) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Unable to boot - please use a kernel appropriate &#34;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;for your CPU.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">die</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Tell the BIOS what CPU mode we intend to run in. */</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">set_bios_mode</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Detect memory layout */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">循环执行调用号为0xe820的0x15中断调用，将每次的返回值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">保存在e820entry数组中,每项的成员如下
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 内存段的起始地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 内存段的大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 内存段的类型（类型可以是reserved, usable等等)。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">detect_memory</span>();
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Set keyboard repeat rate (why?) and query the lock flags */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">1. 通过中断获得键盘状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">2. 设置键盘的按键检测频率
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">keyboard_init</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Query Intel SpeedStep (IST) information */</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">query_ist</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Query APM information */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(CONFIG_APM) || defined(CONFIG_APM_MODULE)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">query_apm_bios</span>();
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Query EDD information */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if defined(CONFIG_EDD) || defined(CONFIG_EDD_MODULE)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">query_edd</span>();
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Set the video mode */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">设置屏幕,暂时用不到=。=
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">set_video</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Do the last things and invoke protected mode */</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">go_to_protected_mode</span>();
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
<h1 id="内核切换至保护模式">内核切换至保护模式</h1>
<ol>
<li>
<p>mian调用go_to_protected_mode()函数，由实模式切换至保护模式</p>
<ul>
<li>
<p>realmode_switch_hook: 如果boot_params.hdr.realmode_swtch
存在，则跳转执行boot_params.hdr.realmode_swtch(禁用NMI中断),
否则直接禁用NMI中断(写数据需要时间，所以后面紧跟io_delay实现短暂延迟)</p>
</li>
<li>
<p>enable_a20： 检测a20是否被激活，如果没有则尝试多种方法激活a20，
激活失败，则系统停止运行</p>
</li>
<li>
<p>set_idt(null_idt为空，使用lidt将null_idt加载入idt寄存器)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setup_idt</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> gdt_ptr null_idt <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">asm</span> <span style="color:#66d9ef">volatile</span>(<span style="color:#e6db74">&#34;lidtl %0&#34;</span> <span style="color:#f92672">:</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;m&#34;</span> (null_idt));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>set_gdt</p>
<ul>
<li>使用boot_gdt[]数组存储gdt全局表，初始化CS，DS，TSS表项</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* CS: code, read/execute, 4 GB, base 0 */</span>
</span></span><span style="display:flex;"><span>[GDT_ENTRY_BOOT_CS] <span style="color:#f92672">=</span> <span style="color:#a6e22e">GDT_ENTRY</span>(<span style="color:#ae81ff">0xc09b</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0xfffff</span>),
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* DS: data, read/write, 4 GB, base 0 */</span>
</span></span><span style="display:flex;"><span>[GDT_ENTRY_BOOT_DS] <span style="color:#f92672">=</span> <span style="color:#a6e22e">GDT_ENTRY</span>(<span style="color:#ae81ff">0xc093</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0xfffff</span>),
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* TSS: 32-bit tss, 104 bytes, base 4096 */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* We only have a TSS here to keep Intel VT happy;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   we don&#39;t actually use it for anything. */</span>
</span></span><span style="display:flex;"><span>[GDT_ENTRY_BOOT_TSS] <span style="color:#f92672">=</span> <span style="color:#a6e22e">GDT_ENTRY</span>(<span style="color:#ae81ff">0x0089</span>, <span style="color:#ae81ff">4096</span>, <span style="color:#ae81ff">103</span>),
</span></span></code></pre></div><ul>
<li>
<p>使用static struct gdt_ptr gdt存储gdt全局表大小与地址</p>
</li>
<li>
<p>使用lgdt将gdt_ptr加载如gdt寄存器</p>
</li>
</ul>
</li>
<li>
<p>protected_mode_jump(boot_params.hdr.code32_start,(u32&amp;boot_params + (ds() &laquo; 4));</p>
<ul>
<li>
<p>该函数使用gcc noreturn特性描述</p>
</li>
<li>
<p>传递code32入口地址(0x100000)，与boot_params内容</p>
</li>
<li>
<p>x86_linux内核引导协议规定使用bzImage时，保护模式的内核被重定位至0x100000</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>保护模式总结</p>
<ul>
<li>
<p>gdtr寄存器(48位)存储全局描述符表的基址(32位)与大小(16位)</p>
</li>
<li>
<p>段寄存器存储段选择子(16位)，包含段描述符在段描述表中的索引，GDT/LDT标志位，RPL请求者优先级(与段描述符中的优先级协同工作)</p>
</li>
<li>
<p>段描述符(64位)</p>
<pre tabindex="0"><code>31          24        19      16              7            0
------------------------------------------------------------
|             | |B| |A|       | |   | |0|E|W|A|            |
| BASE 31:24  |G|/|L|V| LIMIT |P|DPL|S|  TYPE | BASE 23:16 | 4
|             | |D| |L| 19:16 | |   | |1|C|R|A|            |
------------------------------------------------------------
|                             |                            |
|        BASE 15:0            |       LIMIT 15:0           | 0
|                             |                            |
------------------------------------------------------------
</code></pre><ul>
<li>
<p>Limit(20位)表示内存段长度</p>
<ul>
<li>
<p>G = 0, 内存段的长度按照1 byte进行增长(Limit每增加1，段长度增加1 byte)，最大的内存段长度将是1M bytes；</p>
</li>
<li>
<p>G = 1, 内存段的长度按照4K bytes进行增长(Limit每增加1，段长度增加4K bytes)，最大的内存段长度是4G bytes;</p>
</li>
</ul>
</li>
<li>
<p>Base(32位)表示段基址</p>
</li>
<li>
<p>40-47位定义内存段类型以及支持的操作</p>
<ul>
<li>
<p>S标志(第44位)定义了段类型，S = 0说明这个内存段是一个系统段;S = 1说明这个内存段是一个代码段或者是数据段(堆栈段是一种特殊类型的数据段，堆栈段必须是可以进行读写的段)。</p>
<ul>
<li>
<p>S = 1的情况下，第43位决定了内存段是数据段还是代码段。如果43位 = 0，说明是一个数据段，否则就是一个代码段。</p>
</li>
<li>
<p>数据段，第42，41，40位表示的是(E扩展，W可写，A可访问)</p>
</li>
<li>
<p>代码段，第42，41，40位表示的是(C一致，R可读，A可访问）</p>
</li>
</ul>
<pre tabindex="0"><code>                |           Type Field        | Descriptor Type | Description
|-----------------------------|-----------------|------------------
| Decimal                     |                 |
|             0    E    W   A |                 |
| 0           0    0    0   0 | Data            | Read-Only
| 1           0    0    0   1 | Data            | Read-Only, accessed
| 2           0    0    1   0 | Data            | Read/Write
| 3           0    0    1   1 | Data            | Read/Write, accessed
| 4           0    1    0   0 | Data            | Read-Only, expand-down
| 5           0    1    0   1 | Data            | Read-Only, expand-down, accessed
| 6           0    1    1   0 | Data            | Read/Write, expand-down
| 7           0    1    1   1 | Data            | Read/Write, expand-down, accessed
|                  C    R   A |                 |
| 8           1    0    0   0 | Code            | Execute-Only
| 9           1    0    0   1 | Code            | Execute-Only, accessed
| 10          1    0    1   0 | Code            | Execute/Read
| 11          1    0    1   1 | Code            | Execute/Read, accessed
| 12          1    1    0   0 | Code            | Execute-Only, conforming
| 14          1    1    0   1 | Code            | Execute-Only, conforming, accessed
| 13          1    1    1   0 | Code            | Execute/Read, conforming
| 15          1    1    1   1 | Code            | Execute/Read, conforming, accessed
</code></pre></li>
</ul>
</li>
<li>
<p>P 标志(bit 47) 说明该内存段是否已经存在于内存中。如果P = 0，那么在访问这个内存段的时候将报错。</p>
</li>
<li>
<p>AVL 标志(bit 52) 在Linux内核中没有被使用。</p>
</li>
<li>
<p>L 标志(bit 53) 只对代码段有意义，如果L = 1，说明该代码段需要运行在64位模式下。</p>
</li>
<li>
<p>D/B flag(bit 54) 根据段描述符描述的是一个可执行代码段、下扩数据段还是一个堆栈段，这个标志具有不同的功能。（对于32位代码和数据段，这个标志应该总是设置为1；对于16位代码和数据段，这个标志被设置为0。）。</p>
<ul>
<li>
<p>可执行代码段。此时这个标志称为D标志并用于指出该段中的指令引用有效地址和操作数的默认长度。如果该标志置位，则默认值是32位地址和32位或8位的操作数；如果该标志为0，则默认值是16位地址和16位或8位的操作数。指令前缀0x66可以用来选择非默认值的操作数大小；前缀0x67可用来选择非默认值的地址大小。</p>
</li>
<li>
<p>栈段（由SS寄存器指向的数据段）。此时该标志称为B（Big）标志，用于指明隐含堆栈操作（如PUSH、POP或CALL）时的栈指针大小。如果该标志置位，则使用32位栈指针并存放在ESP寄存器中；如果该标志为0，则使用16位栈指针并存放在SP寄存器中。如果堆栈段被设置成一个下扩数据段，这个B标志也同时指定了堆栈段的上界限。</p>
</li>
<li>
<p>下扩数据段。此时该标志称为B标志，用于指明堆栈段的上界限。如果设置了该标志，则堆栈段的上界限是0xFFFFFFFF（4GB）；如果没有设置该标志，则堆栈段的上界限是0xFFFF（64KB）。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="内核切换至长模式">内核切换至长模式</h1>
<ol>
<li>
<p>x86_64架构下code32_start(内核启动时在0x100000处加载，但是如果内核崩溃，需要重新加载内核时，此处会进行重定位) 在head_64.S(使用-fPIC编译，用于适配内核加载地址重定位)中定义</p>
</li>
<li>
<p>head_64.S</p>
<ul>
<li>
<p>head_64.S(starup_32) 解析</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-S" data-lang="S"><span style="display:flex;"><span>        __HEAD  <span style="color:#f92672">//</span>宏定义，声名代码段(<span style="color:#75715e">#define __HEAD  .section  &#34;.head.text&#34;,&#34;ax&#34;)</span>
</span></span><span style="display:flex;"><span>        .code32
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">SYM_FUNC_START</span>(startup_32)
</span></span><span style="display:flex;"><span>        cld 
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">/*</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span> Test KEEP_SEGMENTS flag to see if the bootloader is asking
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span> us to not reload segments
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">/*</span>
</span></span><span style="display:flex;"><span>        判断loadflags是否设置KEEP_SEGMENTS标志位
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>        testb <span style="color:#f92672">$</span>KEEP_SEGMENTS, <span style="color:#a6e22e">BP_loadflags</span>(<span style="color:#f92672">%esi)  
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        jnz 1f
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        /*
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        如果没有设置KEEP_SEGMENTS标志位，则使用DS段描述符初始化数据段寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        */
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        cli
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        movl	$(__BOOT_DS), %</span>eax
</span></span><span style="display:flex;"><span>        movl	<span style="color:#f92672">%eax, %</span>ds
</span></span><span style="display:flex;"><span>        movl	<span style="color:#f92672">%eax, %</span>es
</span></span><span style="display:flex;"><span>        movl	<span style="color:#f92672">%eax, %</span>ss
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">/*</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span> Calculate the delta between where we were compiled to run
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span> at and where we were actually loaded at.  This can only be done
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span> with a short local call on x86.  Nothing  else will tell us what
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span> address we are running at.  The reserved chunk of the real<span style="color:#f92672">-</span>mode
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span> data at <span style="color:#ae81ff">0x1e4</span> (defined as a scratch field) are used as the stack
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span> for this calculation. Only <span style="color:#ae81ff">4</span> bytes are needed.
</span></span><span style="display:flex;"><span><span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">/*</span>
</span></span><span style="display:flex;"><span>使用bootparams结构中的scratch作为临时栈顶，call <span style="color:#ae81ff">1</span>f, popl <span style="color:#f92672">%ebp(将当前物
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">理位置置于ebp),通过subl $1b, %</span>ebp 定位startup_32真实地址
</span></span><span style="display:flex;"><span><span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">leal	</span>(BP_scratch<span style="color:#ae81ff">+4</span>)(<span style="color:#f92672">%esi), %</span>esp
</span></span><span style="display:flex;"><span>        call	<span style="color:#ae81ff">1</span>f
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>	popl	<span style="color:#f92672">%ebp
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        subl	$1b, %</span>ebp
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">/*</span> setup a stack and make sure cpu supports long mode. <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">/*</span> startup_32基地址结合boot_stack_end 重新设置栈顶
</span></span><span style="display:flex;"><span>        movl	<span style="color:#f92672">$</span>boot_stack_end, <span style="color:#f92672">%eax
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        addl	%</span>ebp, <span style="color:#f92672">%eax
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        movl	%</span>eax, <span style="color:#f92672">%esp
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">调用verify_cpu 判断CPU 是否支持长模式和SSE，如果不支持则不再向长模式跳转
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">*/
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        call	verify_cpu
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        testl	%</span>eax, <span style="color:#f92672">%eax
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        jnz	.Lno_longmode
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">* Compute the delta between where we were compiled to run at
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">* and where the code will actually run at.
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">*
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">* %</span>ebp contains the address we are loaded at by the boot loader and <span style="color:#f92672">%ebx
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">* contains the address where we should move the kernel image temporarily
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">* for safe in-place decompression.
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">*/
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">#ifdef CONFIG_RELOCATABLE
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        movl	%</span>ebp, <span style="color:#f92672">%ebx
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        movl	BP_kernel_alignment(%</span>esi), <span style="color:#f92672">%eax
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        decl	%</span>eax
</span></span><span style="display:flex;"><span>        addl	<span style="color:#f92672">%eax, %</span>ebx
</span></span><span style="display:flex;"><span>        notl	<span style="color:#f92672">%eax
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        andl	%</span>eax, <span style="color:#f92672">%ebx
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        cmpl	$LOAD_PHYSICAL_ADDR, %</span>ebx
</span></span><span style="display:flex;"><span>        jae	<span style="color:#ae81ff">1</span>f
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif</span>
</span></span><span style="display:flex;"><span>        movl	<span style="color:#f92672">$</span>LOAD_PHYSICAL_ADDR, <span style="color:#f92672">%ebx
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">1:
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        /* Target address to relocate to for decompression */
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        movl	BP_init_size(%</span>esi), <span style="color:#f92672">%eax
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        subl	$_end, %</span>eax
</span></span><span style="display:flex;"><span>        addl	<span style="color:#f92672">%eax, %</span>ebx
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">/*</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">*</span> Prepare for entering <span style="color:#ae81ff">64</span> bit mode
</span></span><span style="display:flex;"><span><span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">/*</span> Load new GDT with the <span style="color:#ae81ff">64</span>bit segments using <span style="color:#ae81ff">32</span>bit descriptor <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">/*</span> 
</span></span><span style="display:flex;"><span>        重新加载全局描述表，<span style="color:#ae81ff">64</span>位代码段描述项添加 <span style="color:#a6e22e">CS.L</span>(长模式标志为) <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> CS.D <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">SYM_DATA_START_LOCAL</span>(gdt)
</span></span><span style="display:flex;"><span>                .word	gdt_end <span style="color:#f92672">-</span> gdt
</span></span><span style="display:flex;"><span>                .long	gdt
</span></span><span style="display:flex;"><span>                .word	<span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>                .quad	<span style="color:#ae81ff">0x00cf9a000000ffff</span>	<span style="color:#f92672">/*</span> __KERNEL32_CS <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>                .quad	<span style="color:#ae81ff">0x00af9a000000ffff</span>	<span style="color:#f92672">/*</span> __KERNEL_CS <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>                .quad	<span style="color:#ae81ff">0x00cf92000000ffff</span>	<span style="color:#f92672">/*</span> __KERNEL_DS <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>                .quad	<span style="color:#ae81ff">0x0080890000000000</span>	<span style="color:#f92672">/*</span> TS descriptor <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>                .quad   <span style="color:#ae81ff">0x0000000000000000</span>	<span style="color:#f92672">/*</span> TS continued <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">SYM_DATA_END_LABEL</span>(gdt, SYM_L_LOCAL, gdt_end)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        addl	<span style="color:#f92672">%ebp, gdt+2(%</span>ebp)
</span></span><span style="display:flex;"><span>        lgdt	<span style="color:#a6e22e">gdt</span>(<span style="color:#f92672">%ebp)
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        /* Enable PAE mode */
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        /* cr4寄存器第5位置1,开启PAE模式
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        movl	%</span>cr4, <span style="color:#f92672">%eax
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        orl	$X86_CR4_PAE, %</span>eax
</span></span><span style="display:flex;"><span>        movl	<span style="color:#f92672">%eax, %</span>cr4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">... </span>(创建页表) <span style="color:#66d9ef">...</span>
</span></span></code></pre></div></li>
<li>
<p>页表(IA-32e 分页模式)</p>
<ol>
<li>
<p>cr3寄存器</p>
<pre tabindex="0"><code>63                  52 51                                                       32
--------------------------------------------------------------------------------
|                     |                                                          |
|    Reserved MBZ     |            Address of the top level structure            |
|                     |                                                          |
--------------------------------------------------------------------------------
31                                  12 11            5     4     3 2             0
--------------------------------------------------------------------------------
|                                     |               |  P  |  P  |              |
|  Address of the top level structure |   Reserved    |  C  |  W  |    Reserved  |
|                                     |               |  D  |  T  |              |
--------------------------------------------------------------------------------
</code></pre><ul>
<li>
<p>Bits 63:52 - reserved must be 0.</p>
</li>
<li>
<p>Bits 51:12 - stores the address of the top level paging structure;</p>
</li>
<li>
<p>Bits 11:5 - reserved must be 0;</p>
</li>
<li>
<p>Bits 4:3 - PWT or Page-Level Writethrough and PCD or Page-level cache disable indicate. These bits control the way the page or Page Table is handled by the hardware cache;</p>
</li>
<li>
<p>Bits 2:0 - ignored;</p>
</li>
</ul>
</li>
<li>
<p>页表项</p>
<pre tabindex="0"><code>63  62                  52 51                                                  32
--------------------------------------------------------------------------------
| N |                     |                                                     |
|   |     Available       |     Address of the paging structure on lower level  |
| X |                     |                                                     |
--------------------------------------------------------------------------------
31                                              12 11  9 8 7 6 5   4   3 2 1     0
--------------------------------------------------------------------------------
|                                                |     | M |I| | P | P |U|W|    |
| Address of the paging structure on lower level | AVL | B |G|A| C | W | | |  P |
|                                                |     | Z |N| | D | T |S|R|    |
--------------------------------------------------------------------------------
</code></pre><ul>
<li>
<p>Bits 63 - N/X位(不可执行位)表示被这个页表项映射的所有物理页执行代码的能力；</p>
</li>
<li>
<p>Bits 62：52 - CPU忽略，被系统软件使用；</p>
</li>
<li>
<p>Bits 51：12 - 存储低级分页结构的物理地址；</p>
</li>
<li>
<p>Bits 11：9 - 被 CPU 忽略；</p>
</li>
<li>
<p>MBZ - 必须为 0；</p>
</li>
<li>
<p>忽略位；</p>
</li>
<li>
<p>A - 访问标志位暗示物理页或者页结构被访问；</p>
</li>
<li>
<p>PWT 和 PCD 用于缓存；</p>
</li>
<li>
<p>U/S - 普通用户/超级管理员访问标志位 控制被这个页表项映射的所有物理页的访问权限；</p>
</li>
<li>
<p>R/W - 读写位 控制被这个页表项映射的所有物理页的读写权限;</p>
</li>
<li>
<p>P - 存在位 表示页表或物理页是否被加载进内存；</p>
</li>
</ul>
</li>
<li>
<p>线性地址转换为物理地址</p>
<ul>
<li>
<p>64位线性地址只有低48位有意义</p>
</li>
<li>
<p>cr3寄存器存储4级页表地址</p>
</li>
<li>
<p>线性地址中的第39位到第47位存储4级页表项索引，第30位到第38位存储3级页表项索引，第29位到第21位存储2级页表项索引，第12位到第20位存储1级页表项索引，第0位到第11位提供物理页的字节偏移；</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>继续解析 head_64.S(starup_32)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-S" data-lang="S"><span style="display:flex;"><span>        <span style="color:#f92672">/*</span> Enable Long mode in <span style="color:#a6e22e">EFER </span>(Extended Feature Enable Register) <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">/*</span> 
</span></span><span style="display:flex;"><span>        启用拓展寄存器
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>        movl	<span style="color:#f92672">$</span>MSR_EFER, <span style="color:#f92672">%ecx
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        rdmsr
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        btsl	$_EFER_LME, %</span>eax
</span></span><span style="display:flex;"><span>        wrmsr
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">/*</span> After gdt is loaded <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">/*</span>
</span></span><span style="display:flex;"><span>        初始化LDT寄存器
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>        xorl	<span style="color:#f92672">%eax, %</span>eax
</span></span><span style="display:flex;"><span>        lldt	<span style="color:#f92672">%ax
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        movl    $__BOOT_TSS, %</span>eax
</span></span><span style="display:flex;"><span>        ltr	<span style="color:#f92672">%ax
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        /*
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        * Setup for the jump to 64bit mode
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        *
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        * When the jump is performend we will be in long mode but
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        * in 32bit compatibility mode with EFER.LME = 1, CS.L = 0, CS.D = 1
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        * (and in turn EFER.LMA = 1).	To jump into 64bit mode we use
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        * the new gdt/idt that has __KERNEL_CS with CS.L = 1.
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        * We place all of the values on our mini stack so lret can
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        * used to perform that far jump.
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        */
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        pushl	$__KERNEL_CS
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        leal	startup_64(%</span>ebp), <span style="color:#f92672">%eax
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        pushl	%</span>eax
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">/*</span> Enter paged protected Mode, activating Long Mode <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">/*</span>
</span></span><span style="display:flex;"><span>        启用分页机制
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>        movl	<span style="color:#f92672">$</span>(X86_CR0_PG <span style="color:#f92672">|</span> X86_CR0_PE), <span style="color:#f92672">%eax /* Enable Paging and Protected mode */
</span></span></span><span style="display:flex;"><span><span style="color:#f92672">        movl	%</span>eax, %cr0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">/*</span> Jump from <span style="color:#ae81ff">32</span>bit compatibility mode into <span style="color:#ae81ff">64</span>bit mode. <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">/*</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cs段选择子</span>(指向cs_kernel_64段描述符)，<span style="color:#a6e22e">rip</span>(startup_64物理地址)，已经压入栈中
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span>        lret
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">/*</span>
</span></span><span style="display:flex;"><span>        跳转进入startup_64
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">SYM_FUNC_END</span>(startup_32)
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
<h1 id="长模式下内核解压缩">长模式下内核解压缩</h1>
<ol>
<li>
<p>进入64位长模式后，将数据段寄存器设置为空描述符，以实现寻址平坦化(长模式下段寄存器，段描述符显得有些鸡肋，只保留部分功能)</p>
</li>
<li>
<p>如果设置了内核重定位，则首先通过rip相对寻址获得当前代码段加载的基地址，2MB字节对齐后，与LOAD_PHYSICAL_ADDR比较，如果不同，则使用该基地址替换LOAD_PHYSICAL_ADDR(这种操作在startup32中实现过，但是在这里又实现一遍是因为64位引导可以直接跳到startup_64而忽略startup_32)，紧接着将rbx设置为用以解压内核的代码的地址</p>
</li>
<li>
<p>按照64位引导协议，重置rsp(以rbx为基地址)，flag寄存器，GDT</p>
</li>
<li>
<p>将压缩内核(位于当前代码与解压缩代码之间)复制到栈上(rbx为基地址)后，跳转到rbx处(用于解压内核的代码段)</p>
</li>
<li>
<p>因为接下来会执行c语言程序，所以提前清空bss段</p>
</li>
<li>
<p>调用extract_kernel函数</p>
<ul>
<li>
<p>初始化video/console(程序不知道系统引导类型，所以再次初始化)</p>
</li>
<li>
<p>初始化堆，堆长度为0x10000</p>
</li>
<li>
<p>调用choose_random_location(用来适配KASLR安全机制)选择可以用来写入已解压内核的物理空间</p>
</li>
<li>
<p>原地解压内核</p>
</li>
<li>
<p>parse_elf函数将内核可加载段加载入choose_random_location的返回地址</p>
</li>
<li>
<p>handle_relocations函数完成到64位内核代码段的跳转</p>
</li>
</ul>
</li>
</ol>
<h1 id="至此x86_64架构下64位linux内核成功运行">至此，x86_64架构下64位linux内核成功运行</h1>
</section>

  
  

  
  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    <a
      class="flex w-1/2 items-center rounded-l-md p-6 pr-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]"
      href="https://www.povcfe.site/post/kernel_mm/"
      ><span class="mr-1.5">←</span><span>linux内核(5.4.81)---内存管理模块源码分析</span></a
    >
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]"
      href="https://www.povcfe.site/post/kernel_rw3/"
      ><span>linux 内核提权总结(demo&#43;exp分析) -- 任意读写(三)</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  
  

  
  

  
  

  


  
</article>


    </main>

    <footer
  class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"
>
  <div class="mr-auto">
    &copy; 2024
    <a class="link" href="https://www.povcfe.site/">povcfe&#39;s site</a>
  </div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank"
    >Powered by Hugo️️</a
  >️
  <a
    class="link"
    href="https://github.com/nanxiaobei/hugo-paper"
    rel="noopener"
    target="_blank"
    >✎ Paper</a
  >
</footer>

  </body>
</html>
