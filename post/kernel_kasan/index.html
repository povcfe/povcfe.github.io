<!doctype html>









































<html
  class="not-ready lg:text-base"
  style="--bg: #faf8f1"
  lang="en-us"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>linux内核(5.4.81)---KASAN - povcfe&#39;s site</title>

  
  <meta name="theme-color" />

  
  
  
  
  <meta name="description" content="发表于安全客
KASAN 简述 KASAN是内核用于动态检测内存错误的工具, 简单来说, 数据区域可分为两种:可访问区域，不可访问区域(red_zone).KASAN存在影子内存(shadow memory), 他和正常内存的比例是1:8, 即1byte shadow memory可以代表8bytes 正常内存的可访问性.
128TB(内核正常内存) : 16TB(影子内存) &mdash; Documentation/x86/x86_64/mm.rst x86-64 内存布局显示如下:
ffffec0000000000 | -20 TB | fffffbffffffffff | 16 TB | KASAN shadow memory 具体规则(&#43;: byte可访问, -: byte不可访问)
如果1byte shadow memory对应的8bytes 内存都可访问, 则*(shadow memory) == 0 [0] -&gt; [&#43;, &#43;, &#43;, &#43;, &#43;, &#43;, &#43;, &#43;] 如果1byte shadow memory对应的8bytes 内存都不可访问, 则*(shadow memory)为负数 [-1] -&gt; [-, -, -, -, -, -, -, -] 如果1byte shadow memory对应的8bytes 内存中有N bytes可访问, 则*(shadow memory) == N if N = 3 [3] -&gt; [&#43;, &#43;, &#43;, -, -, -, -, -] 实现原理" />
  <meta name="author" content="povcfe" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://www.povcfe.site/main.min.css" />

  
  
  
  
  
  <link rel="preload" as="image" href="https://www.povcfe.site/theme.png" />

  
  
  
  
  <link rel="preload" as="image" href="https://www.povcfe.site/avatar.jpg" />
  
  

  
  
  <link rel="preload" as="image" href="https://www.povcfe.site/twitter.svg" />
  
  <link rel="preload" as="image" href="https://www.povcfe.site/github.svg" />
  
  <link rel="preload" as="image" href="https://www.povcfe.site/rss.svg" />
  
  

  
  
  <script
    defer
    src="https://www.povcfe.site/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
  
  

  
  <link rel="icon" href="https://www.povcfe.site/favicon.ico" />
  <link rel="apple-touch-icon" href="https://www.povcfe.site/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.111.3">

  
  
  
  
  
  <meta itemprop="name" content="linux内核(5.4.81)---KASAN">
<meta itemprop="description" content="发表于安全客
KASAN 简述 KASAN是内核用于动态检测内存错误的工具, 简单来说, 数据区域可分为两种:可访问区域，不可访问区域(red_zone).KASAN存在影子内存(shadow memory), 他和正常内存的比例是1:8, 即1byte shadow memory可以代表8bytes 正常内存的可访问性.
128TB(内核正常内存) : 16TB(影子内存) &mdash; Documentation/x86/x86_64/mm.rst x86-64 内存布局显示如下:
ffffec0000000000 | -20 TB | fffffbffffffffff | 16 TB | KASAN shadow memory 具体规则(&#43;: byte可访问, -: byte不可访问)
如果1byte shadow memory对应的8bytes 内存都可访问, 则*(shadow memory) == 0 [0] -&gt; [&#43;, &#43;, &#43;, &#43;, &#43;, &#43;, &#43;, &#43;] 如果1byte shadow memory对应的8bytes 内存都不可访问, 则*(shadow memory)为负数 [-1] -&gt; [-, -, -, -, -, -, -, -] 如果1byte shadow memory对应的8bytes 内存中有N bytes可访问, 则*(shadow memory) == N if N = 3 [3] -&gt; [&#43;, &#43;, &#43;, -, -, -, -, -] 实现原理"><meta itemprop="datePublished" content="2021-03-21T00:00:00-04:00" />
<meta itemprop="dateModified" content="2021-03-21T00:00:00-04:00" />
<meta itemprop="wordCount" content="1358">
<meta itemprop="keywords" content="" />
  
  <meta property="og:title" content="linux内核(5.4.81)---KASAN" />
<meta property="og:description" content="发表于安全客
KASAN 简述 KASAN是内核用于动态检测内存错误的工具, 简单来说, 数据区域可分为两种:可访问区域，不可访问区域(red_zone).KASAN存在影子内存(shadow memory), 他和正常内存的比例是1:8, 即1byte shadow memory可以代表8bytes 正常内存的可访问性.
128TB(内核正常内存) : 16TB(影子内存) &mdash; Documentation/x86/x86_64/mm.rst x86-64 内存布局显示如下:
ffffec0000000000 | -20 TB | fffffbffffffffff | 16 TB | KASAN shadow memory 具体规则(&#43;: byte可访问, -: byte不可访问)
如果1byte shadow memory对应的8bytes 内存都可访问, 则*(shadow memory) == 0 [0] -&gt; [&#43;, &#43;, &#43;, &#43;, &#43;, &#43;, &#43;, &#43;] 如果1byte shadow memory对应的8bytes 内存都不可访问, 则*(shadow memory)为负数 [-1] -&gt; [-, -, -, -, -, -, -, -] 如果1byte shadow memory对应的8bytes 内存中有N bytes可访问, 则*(shadow memory) == N if N = 3 [3] -&gt; [&#43;, &#43;, &#43;, -, -, -, -, -] 实现原理" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.povcfe.site/post/kernel_kasan/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-03-21T00:00:00-04:00" />
<meta property="article:modified_time" content="2021-03-21T00:00:00-04:00" />

  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="linux内核(5.4.81)---KASAN"/>
<meta name="twitter:description" content="发表于安全客
KASAN 简述 KASAN是内核用于动态检测内存错误的工具, 简单来说, 数据区域可分为两种:可访问区域，不可访问区域(red_zone).KASAN存在影子内存(shadow memory), 他和正常内存的比例是1:8, 即1byte shadow memory可以代表8bytes 正常内存的可访问性.
128TB(内核正常内存) : 16TB(影子内存) &mdash; Documentation/x86/x86_64/mm.rst x86-64 内存布局显示如下:
ffffec0000000000 | -20 TB | fffffbffffffffff | 16 TB | KASAN shadow memory 具体规则(&#43;: byte可访问, -: byte不可访问)
如果1byte shadow memory对应的8bytes 内存都可访问, 则*(shadow memory) == 0 [0] -&gt; [&#43;, &#43;, &#43;, &#43;, &#43;, &#43;, &#43;, &#43;] 如果1byte shadow memory对应的8bytes 内存都不可访问, 则*(shadow memory)为负数 [-1] -&gt; [-, -, -, -, -, -, -, -] 如果1byte shadow memory对应的8bytes 内存中有N bytes可访问, 则*(shadow memory) == N if N = 3 [3] -&gt; [&#43;, &#43;, &#43;, -, -, -, -, -] 实现原理"/>

  
  
  
  <link rel="canonical" href="https://www.povcfe.site/post/kernel_kasan/" />
  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center">
  <div class="relative z-50 mr-auto flex items-center">
    <a
      class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold"
      href="https://www.povcfe.site/"
      >povcfe&#39;s site</a
    >
    <div
      class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]"
      role="button"
      aria-label="Dark"
    ></div>
  </div>

  <div
    class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
    role="button"
    aria-label="Menu"
  ></div>

  

  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = '#faf8f1'.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"
    >
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./twitter.svg)"
        href="https://twitter.com/povcfe"
        target="_blank"
        rel="me"
      >
        twitter
      </a>
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href="https://github.com/povcfe"
        target="_blank"
        rel="me"
      >
        github
      </a>
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./rss.svg)"
        href="https://www.povcfe.site/index.xml"
        target="_blank"
        rel="alternate"
      >
        rss
      </a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"
    >
      

<article>
  <header class="mb-16">
    <h1 class="!my-0 pb-2.5">linux内核(5.4.81)---KASAN</h1>

    
    <div class="text-sm antialiased opacity-60">
      
      <time>Mar 21, 2021</time>
      
      
      
      
    </div>
    
  </header>

  <section><p><a href="https://www.anquanke.com/setting?p=message">发表于安全客</a></p>
<h2 id="kasan-简述">KASAN 简述</h2>
<ul>
<li>
<p>KASAN是内核用于动态检测内存错误的工具, 简单来说, 数据区域可分为两种:可访问区域，不可访问区域(red_zone).KASAN存在影子内存(shadow memory), 他和正常内存的比例是1:8, 即1byte shadow memory可以代表8bytes 正常内存的可访问性.</p>
</li>
<li>
<p>128TB(内核正常内存) : 16TB(影子内存) &mdash; Documentation/x86/x86_64/mm.rst x86-64 内存布局显示如下:</p>
</li>
</ul>
<pre tabindex="0"><code> ffffec0000000000 |  -20    TB | fffffbffffffffff |   16 TB | KASAN shadow memory
</code></pre><ul>
<li>
<p>具体规则(+: byte可访问, -: byte不可访问)</p>
<ul>
<li>如果1byte shadow memory对应的8bytes 内存都可访问, 则*(shadow memory) == 0</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-&gt;</span> [<span style="color:#f92672">+</span>, <span style="color:#f92672">+</span>, <span style="color:#f92672">+</span>, <span style="color:#f92672">+</span>, <span style="color:#f92672">+</span>, <span style="color:#f92672">+</span>, <span style="color:#f92672">+</span>, <span style="color:#f92672">+</span>]
</span></span></code></pre></div><ul>
<li>如果1byte shadow memory对应的8bytes 内存都不可访问, 则*(shadow memory)为负数</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">-&gt;</span> [<span style="color:#f92672">-</span>, <span style="color:#f92672">-</span>, <span style="color:#f92672">-</span>, <span style="color:#f92672">-</span>, <span style="color:#f92672">-</span>, <span style="color:#f92672">-</span>, <span style="color:#f92672">-</span>, <span style="color:#f92672">-</span>]
</span></span></code></pre></div><ul>
<li>如果1byte shadow memory对应的8bytes 内存中有N bytes可访问, 则*(shadow memory) == N</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">-&gt;</span> [<span style="color:#f92672">+</span>, <span style="color:#f92672">+</span>, <span style="color:#f92672">+</span>, <span style="color:#f92672">-</span>, <span style="color:#f92672">-</span>, <span style="color:#f92672">-</span>, <span style="color:#f92672">-</span>, <span style="color:#f92672">-</span>]
</span></span></code></pre></div></li>
<li>
<p>实现原理</p>
<ul>
<li>
<p>代码插桩: 利用编译器特性进行代码插桩, 当程序对内存进行读取或写入(load/store)时插入kasan检测代码</p>
</li>
<li>
<p>kasan检测代码: __asan_loadN(addr)/__asan_storeN(addr) (后面会对源码做详细分析), 主要功能是检测addr所在位置的N bytes内存是否可用.</p>
</li>
</ul>
</li>
</ul>
<h2 id="源码分析">源码分析</h2>
<h3 id="kasan检测入口">kasan检测入口</h3>
<ul>
<li>使用宏定义实现__asan_load/__asan_store, 关键函数为check_memory_region_inline</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define DEFINE_ASAN_LOAD_STORE(size)					\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	void __asan_load##size(unsigned long addr)			\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	{								\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		check_memory_region_inline(addr, size, false, _RET_IP_);\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	}								\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	EXPORT_SYMBOL(__asan_load##size);				\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	__alias(__asan_load##size)					\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	void __asan_load##size##_noabort(unsigned long);		\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	EXPORT_SYMBOL(__asan_load##size##_noabort);			\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	void __asan_store##size(unsigned long addr)			\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	{								\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		check_memory_region_inline(addr, size, true, _RET_IP_);	\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	}								\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	EXPORT_SYMBOL(__asan_store##size);				\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	__alias(__asan_store##size)					\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	void __asan_store##size##_noabort(unsigned long);		\
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	EXPORT_SYMBOL(__asan_store##size##_noabort)
</span></span></span></code></pre></div><h3 id="check_memory_region_inline">check_memory_region_inline</h3>
<ul>
<li>
<p>当size==0时, 对内存不做读写操作, 正常返回</p>
</li>
<li>
<p>addr必须大于KASAN_SHADOW_START对应的正常地址, 即addr必须在shadow映射的界限内</p>
</li>
<li>
<p>memory_is_poisoned作为核心函数判断内存是否可用</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> __always_inline <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">check_memory_region_inline</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr,
</span></span><span style="display:flex;"><span>						<span style="color:#66d9ef">size_t</span> size, <span style="color:#66d9ef">bool</span> write,
</span></span><span style="display:flex;"><span>						<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> ret_ip)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)addr <span style="color:#f92672">&lt;</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">kasan_shadow_to_mem</span>((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)KASAN_SHADOW_START))) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">kasan_report</span>(addr, size, write, ret_ip);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">memory_is_poisoned</span>(addr, size)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">kasan_report</span>(addr, size, write, ret_ip);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="memory_is_poisoned">memory_is_poisoned</h3>
<ul>
<li>
<p>size 如果为常量, 则对1, 2-4-8, 16这三种情况分开讨论</p>
</li>
<li>
<p>size 不为常量进入memory_is_poisoned_n</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> __always_inline <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">memory_is_poisoned</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr, <span style="color:#66d9ef">size_t</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 判断size是否为常量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">__builtin_constant_p</span>(size)) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">switch</span> (size) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">memory_is_poisoned_1</span>(addr);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">4</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">8</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">memory_is_poisoned_2_4_8</span>(addr, size);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">16</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">memory_is_poisoned_16</span>(addr);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">BUILD_BUG</span>();
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">memory_is_poisoned_n</span>(addr, size);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="memory_is_poisoned_1">memory_is_poisoned_1</h4>
<ul>
<li>
<p>通过kasan_mem_to_shadow获得addr对应的shadow_addr, *((s8 *)shadow_addr)获得shadow_addr所对应的8bits内存值shadow_value</p>
</li>
<li>
<p>因为1byte shadow对应8bytes, 所以可以将 8bytes对齐的addr -&gt; 8bytes对齐的addr+8 设为一个内存组, 对应1byte shadow, 此处addr&amp;7获得addr在该组中的偏移量last_accessible_byte</p>
</li>
<li>
<p>比较偏移量与shadow_value(该组内可访问内存的byte 数), 如果last_accessible_byte &lt;= shadow_value 显然addr可访问(当shadow_value==0时, 表示8bytes皆可访问)</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> __always_inline <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">memory_is_poisoned_1</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	s8 shadow_value <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(s8 <span style="color:#f92672">*</span>)<span style="color:#a6e22e">kasan_mem_to_shadow</span>((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)addr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(shadow_value)) {
</span></span><span style="display:flex;"><span>		s8 last_accessible_byte <span style="color:#f92672">=</span> addr <span style="color:#f92672">&amp;</span> KASAN_SHADOW_MASK;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">unlikely</span>(last_accessible_byte <span style="color:#f92672">&gt;=</span> shadow_value);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="memory_is_poisoned_2_4_8">memory_is_poisoned_2_4_8</h4>
<ul>
<li>
<p>与memory_is_poisoned_1的区别在于此处多考虑了一种情况(待store/read内存跨越两个内存组)</p>
</li>
<li>
<p>对于跨越内存组的情况, 需要满足第一个内存组8bytes皆可访问(0), 第二个内存组shadow_value &gt;= 组内偏移</p>
</li>
<li>
<p>如果不跨越内存, 只判断末尾地址是否可store/load 1byte 内存</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> __always_inline <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">memory_is_poisoned_2_4_8</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr,
</span></span><span style="display:flex;"><span>						<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	u8 <span style="color:#f92672">*</span>shadow_addr <span style="color:#f92672">=</span> (u8 <span style="color:#f92672">*</span>)<span style="color:#a6e22e">kasan_mem_to_shadow</span>((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)addr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Access crosses 8(shadow size)-byte boundary. Such access maps
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * into 2 shadow bytes, so we need to check them both.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(((addr <span style="color:#f92672">+</span> size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&amp;</span> KASAN_SHADOW_MASK) <span style="color:#f92672">&lt;</span> size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>shadow_addr <span style="color:#f92672">||</span> <span style="color:#a6e22e">memory_is_poisoned_1</span>(addr <span style="color:#f92672">+</span> size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">memory_is_poisoned_1</span>(addr <span style="color:#f92672">+</span> size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="memory_is_poisoned_16">memory_is_poisoned_16</h4>
<ul>
<li>
<p>只有addr本身为8bytes 对齐时才会只跨越两个内存组, 否则跨越三个内存组</p>
</li>
<li>
<p>对于跨越三个内存组的情况, 需要满足前两个内存组内存皆可访问(16bit shadow_value == 0), 同时第三个内存组shadow_value &gt;= 组内偏移</p>
</li>
<li>
<p>如果只跨越两个内存组, 只需要16bit shadow_value == 0即可</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> __always_inline <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">memory_is_poisoned_16</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	u16 <span style="color:#f92672">*</span>shadow_addr <span style="color:#f92672">=</span> (u16 <span style="color:#f92672">*</span>)<span style="color:#a6e22e">kasan_mem_to_shadow</span>((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)addr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Unaligned 16-bytes access maps into 3 shadow bytes. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">IS_ALIGNED</span>(addr, KASAN_SHADOW_SCALE_SIZE)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>shadow_addr <span style="color:#f92672">||</span> <span style="color:#a6e22e">memory_is_poisoned_1</span>(addr <span style="color:#f92672">+</span> <span style="color:#ae81ff">15</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>shadow_addr;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="memory_is_poisoned_n">memory_is_poisoned_n</h4>
<ul>
<li>
<p>memory_is_nonzero:</p>
<ul>
<li>首先定位与待访问内存块对应的shadow_mem_block, 检测shadow_mem_block中的shadow_value是否全为0, 如果全为0, 则内存块可访问, 从memory_is_poisoned_n返回</li>
<li>如果shadow_value不全为0, 则找到第一个不为0的shadow_value对应的shadow_addr, return shadow_addr</li>
</ul>
</li>
<li>
<p>得到memory_is_nonzero中返回的shadow_addr, 如果shadow_addr == last_shadow(末尾地址对应的shadow_addr) 则内存块可访问, 从memory_is_poisoned_n返回</p>
</li>
<li>
<p>否则判断末尾地址是否可store/load 1byte(比较末尾地址偏移与last_shadow的大小)</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> __always_inline <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">memory_is_poisoned_n</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr,
</span></span><span style="display:flex;"><span>						<span style="color:#66d9ef">size_t</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">memory_is_nonzero</span>(<span style="color:#a6e22e">kasan_mem_to_shadow</span>((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)addr),
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">kasan_mem_to_shadow</span>((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)addr <span style="color:#f92672">+</span> size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(ret)) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> last_byte <span style="color:#f92672">=</span> addr <span style="color:#f92672">+</span> size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		s8 <span style="color:#f92672">*</span>last_shadow <span style="color:#f92672">=</span> (s8 <span style="color:#f92672">*</span>)<span style="color:#a6e22e">kasan_mem_to_shadow</span>((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)last_byte);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(ret <span style="color:#f92672">!=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)last_shadow <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>			((<span style="color:#66d9ef">long</span>)(last_byte <span style="color:#f92672">&amp;</span> KASAN_SHADOW_MASK) <span style="color:#f92672">&gt;=</span> <span style="color:#f92672">*</span>last_shadow)))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="实例分析">实例分析</h2>
<h3 id="buddy_kasan">buddy_kasan</h3>
<blockquote>
<p>kasan_alloc_pages: 标记shadow_mem为0, kasan_free_pages: 标记shadow_mem为不可访问</p>
</blockquote>
<h4 id="验证代码">验证代码</h4>
<ul>
<li>编写kasan驱动, 使用alloc_pages调用buddy分配内存, 查看分配后以及释放后的shadow_mem内存(local_addr[0] = &lsquo;\x10&rsquo;; 对buddy分配的内存块做store操作, 会触发__asan_store1代码插桩)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">kasan_ioctl</span>(<span style="color:#66d9ef">struct</span> file<span style="color:#f92672">*</span> filp, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> cmd, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>local_addr <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>local_pg <span style="color:#f92672">=</span> <span style="color:#a6e22e">alloc_pages</span>(GFP_KERNEL, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    local_addr <span style="color:#f92672">=</span> <span style="color:#a6e22e">page_address</span>(local_pg);
</span></span><span style="display:flex;"><span>    local_addr[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\x10&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">__free_pages</span>(local_pg, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printk</span>(KERN_DEBUG <span style="color:#e6db74">&#34;[+] modules kasan debug</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>ida反汇编代码(存在_asan_store1_noabort(v5), 猜测成立)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">__int64</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">kasan_ioctl</span>(file <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> cmd, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">__int64</span> arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">__int64</span> v3; <span style="color:#75715e">// r13
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">__int64</span> v4; <span style="color:#75715e">// r12
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  _BYTE <span style="color:#f92672">*</span>v5; <span style="color:#75715e">// r12
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_fentry__</span>(filp, cmd, arg);
</span></span><span style="display:flex;"><span>  v3 <span style="color:#f92672">=</span> <span style="color:#a6e22e">alloc_pages_current</span>(<span style="color:#ae81ff">3264LL</span>, <span style="color:#ae81ff">2LL</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_asan_load8_noabort</span>(<span style="color:#f92672">&amp;</span>vmemmap_base);
</span></span><span style="display:flex;"><span>  v4 <span style="color:#f92672">=</span> v3 <span style="color:#f92672">-</span> vmemmap_base;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_asan_load8_noabort</span>(<span style="color:#f92672">&amp;</span>page_offset_base);
</span></span><span style="display:flex;"><span>  v5 <span style="color:#f92672">=</span> (_BYTE <span style="color:#f92672">*</span>)(page_offset_base <span style="color:#f92672">+</span> (v4 <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">6</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">12</span>));
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_asan_store1_noabort</span>(v5);
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>v5 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x10</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printk</span>(<span style="color:#f92672">&amp;</span>unk_1C0, v5);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_free_pages</span>(v3, <span style="color:#ae81ff">2LL</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printk</span>(<span style="color:#f92672">&amp;</span>unk_200, <span style="color:#ae81ff">2LL</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="buddy_kasan-动态调试">buddy_kasan 动态调试</h4>
<ul>
<li>
<p>在call __asan_store1处下断点, 查看rdi内容</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>gef<span style="color:#960050;background-color:#1e0010">➤</span>  p <span style="color:#960050;background-color:#1e0010">$</span>rdi
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xffff88805b034000</span>
</span></span></code></pre></div></li>
<li>
<p>计算shadow_mem = addr &raquo; 3 + 0xdffffc0000000000, 所以0xffff88805b034000对应的shadow_mem: 0xffffed100b606800</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">kasan_mem_to_shadow</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>addr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)addr <span style="color:#f92672">&gt;&gt;</span> KASAN_SHADOW_SCALE_SHIFT)
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">+</span> KASAN_SHADOW_OFFSET;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>查看shadow_mem内容(shadow_value=0x0, 表示内存块可访问)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>gef<span style="color:#960050;background-color:#1e0010">➤</span>  x<span style="color:#f92672">/</span><span style="color:#ae81ff">16</span>xg <span style="color:#ae81ff">0xffffed100b606800</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b606800</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0x0000000000000000</span>      <span style="color:#ae81ff">0x0000000000000000</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b606810</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0x0000000000000000</span>      <span style="color:#ae81ff">0x0000000000000000</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b606820</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0x0000000000000000</span>      <span style="color:#ae81ff">0x0000000000000000</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b606830</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0x0000000000000000</span>      <span style="color:#ae81ff">0x0000000000000000</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b606840</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0x0000000000000000</span>      <span style="color:#ae81ff">0x0000000000000000</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b606850</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0x0000000000000000</span>      <span style="color:#ae81ff">0x0000000000000000</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b606860</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0x0000000000000000</span>      <span style="color:#ae81ff">0x0000000000000000</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b606870</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0x0000000000000000</span>      <span style="color:#ae81ff">0x0000000000000000</span>
</span></span></code></pre></div></li>
<li>
<p>程序执行__free_pages, 释放buddy内存块, 再次查看shadow_mem(0xff=-1, 内存块不可访问)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>gef<span style="color:#960050;background-color:#1e0010">➤</span>  x<span style="color:#f92672">/</span><span style="color:#ae81ff">16</span>xg <span style="color:#ae81ff">0xffffed100b606800</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b606800</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0xffffffffffffffff</span>      <span style="color:#ae81ff">0xffffffffffffffff</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b606810</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0xffffffffffffffff</span>      <span style="color:#ae81ff">0xffffffffffffffff</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b606820</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0xffffffffffffffff</span>      <span style="color:#ae81ff">0xffffffffffffffff</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b606830</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0xffffffffffffffff</span>      <span style="color:#ae81ff">0xffffffffffffffff</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b606840</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0xffffffffffffffff</span>      <span style="color:#ae81ff">0xffffffffffffffff</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b606850</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0xffffffffffffffff</span>      <span style="color:#ae81ff">0xffffffffffffffff</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b606860</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0xffffffffffffffff</span>      <span style="color:#ae81ff">0xffffffffffffffff</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b606870</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0xffffffffffffffff</span>      <span style="color:#ae81ff">0xffffffffffffffff</span>
</span></span></code></pre></div></li>
<li>
<p>计算shadow_mem边界(mem:shadow_mem=8:1), alloc_pages申请4页(0x1000 * 4)对应shadow_mem(0x1000 * 4/8=0x800), 发现0xff与0xfc的分界, 猜测成立</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>gef<span style="color:#960050;background-color:#1e0010">➤</span>  x<span style="color:#f92672">/</span><span style="color:#ae81ff">16</span>xg <span style="color:#ae81ff">0xffffed100b606800</span><span style="color:#f92672">+</span><span style="color:#ae81ff">0x800</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0x10</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b606ff0</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0xffffffffffffffff</span>      <span style="color:#ae81ff">0xffffffffffffffff</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b607000</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0xfcfcfcfcfcfcfcfc</span>      <span style="color:#ae81ff">0xfcfcfcfcfcfcfcfc</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b607010</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0xfcfcfcfcfcfcfcfc</span>      <span style="color:#ae81ff">0xfcfcfcfcfcfcfcfc</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b607020</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0xfcfcfcfcfcfcfcfc</span>      <span style="color:#ae81ff">0xfcfcfcfcfcfcfcfc</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b607030</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0xfcfcfcfcfcfcfcfc</span>      <span style="color:#ae81ff">0xfcfcfcfcfcfcfcfc</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b607040</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0xfcfcfcfcfcfcfcfc</span>      <span style="color:#ae81ff">0xfcfcfcfcfcfcfcfc</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b607050</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0xfcfcfcfcfcfcfcfc</span>      <span style="color:#ae81ff">0xfcfcfcfcfcfcfcfc</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b607060</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0xfcfcfcfcfcfcfcfc</span>      <span style="color:#ae81ff">0xfcfcfcfcfcfcfcfc</span>
</span></span></code></pre></div></li>
<li>
<p>由上述调试结果可知, buddy_kasan可有效的检测内存越界以及uaf</p>
</li>
</ul>
<h3 id="slub_kasan">slub_kasan</h3>
<blockquote>
<p>提到slub_kasan不得不提及slub_debug, slub_debug是slub早期的内存检测机制, 想详细的了解可以看一下这篇文章 <a href="http://www.wowotech.net/memory_management/427.html">slub_debug原理</a>, 或者我之前写的一篇文章<a href="https://www.povcfe.site/posts/kernel_mm/">点击此处</a></p>
</blockquote>
<p>在这里我简单的描述一下slub_debug的原理:</p>
<ul>
<li>
<p>首先slub算法将page切割成一个一个的slub_obj, obj的布局大概是当obj空闲时, 复用头部空间用于存储free_list(指向下一个空闲obj)</p>
</li>
<li>
<p>当slub_debug开启后, slub_obj的布局将发生非常大的改变如下, 第一行为初始布局, 第二行为开启slub_debug后的布局</p>
<p><img src="../../kernel_kasan/kernel_kasan_slub_debug.png" alt=""></p>
</li>
<li>
<p>图中red_zone为右边界越界检测, red_left_pad为左边界越界检测, 这里对于red_left_pad着重说一下, 如果从第二幅图来看, 怎么也看不出左边界越界检测原理, 但是如果布局是第三幅图的话, 就非常明了了. 所以重点在于第二幅布局如何变成第三幅布局, slub的实现是, 每个obj在设计时仍然采用第二副布局, 但却在page开头开辟了一个red_left_pad, 这样就巧妙的完成了转换(至于为什么要经过这么一番转换, 只能说是历史遗留问题, 设计右边界越界检测时并没有考虑左边界越界)</p>
</li>
<li>
<p>然后再说一下slub_debug的局限性, slub_debug虽然和kasan一样设计了red_zone但是, slub_debug的安全检测只在alloc/free时启动, 即如果一个越界内存块永远不被释放, 则安全漏洞很难被发现(为了解决这个问题, slub设计了slub_info可以主动的去触发安全检测, 但是和kasan相比, 在检测范围上仍然很局限 &mdash; 只能检测slub内存问题, 同时还有一个非常重要的问题, slub_debug的red_zone是和填充数据位于同一内存块, 是可以被修改的, 有被劫持的风险)</p>
</li>
<li>
<p>关于slub_debug就说这么多, 继续研究slub_kasan(slub_kasan的布局在slub_debug上面再加一个)</p>
</li>
</ul>
<h4 id="slub_debug">slub_debug</h4>
<ul>
<li>
<p>kasan_poison_slab: 当创建kmem_cache时将page对应的shadow_mem标记为KASAN_KMALLOC_REDZONE, 表示内存不可访问</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">kasan_poison_slab</span>(<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">compound_nr</span>(page); i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">page_kasan_tag_reset</span>(page <span style="color:#f92672">+</span> i);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">kasan_poison_shadow</span>(<span style="color:#a6e22e">page_address</span>(page), <span style="color:#a6e22e">page_size</span>(page),
</span></span><span style="display:flex;"><span>			KASAN_KMALLOC_REDZONE);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>__kasan_kmalloc: 当使用kmalloc(x) 申请内存后, 有一部分内存可用, 填充red_zone, 修改shadow_mem(__kasan_kmalloc和下面全局变量修改shadow_mem的原理类似, 可以滑到下面看看全局变量_kasan, 大致思路就是填充从obj_start+size到obj末尾内存为red_zone)</p>
</li>
</ul>
<h3 id="全局变量_kasan">全局变量_kasan</h3>
<blockquote>
<p>__asan_register_globals: 根据 struct kasan_global为全局变量填充shadow_mem, __asan_unregister_globals实现为空</p>
</blockquote>
<h4 id="验证代码-1">验证代码</h4>
<ul>
<li>
<p>目标全局变量为global_var</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">char</span> global_var[<span style="color:#ae81ff">34</span>] <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;c&#39;</span>, <span style="color:#e6db74">&#39;d&#39;</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">kasan_ioctl</span>(<span style="color:#66d9ef">struct</span> file<span style="color:#f92672">*</span> filp, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> cmd, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	global_var[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;x&#39;</span>;
</span></span><span style="display:flex;"><span>	global_var[<span style="color:#ae81ff">34</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;*&#39;</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>ida反汇编代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">__int64</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">kasan_ioctl</span>(file <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> cmd, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">__int64</span> arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">__int64</span> result; <span style="color:#75715e">// rax
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_fentry__</span>(filp, cmd, arg);
</span></span><span style="display:flex;"><span>	global_var[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">120</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_asan_store1_noabort</span>(<span style="color:#f92672">&amp;</span>global_var[<span style="color:#ae81ff">34</span>]);
</span></span><span style="display:flex;"><span>	result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>	global_var[<span style="color:#ae81ff">34</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<h4 id="全局变量-动态调试">全局变量 动态调试</h4>
<ul>
<li>
<p>查看global_var内存(0xffffffffc000a000)与其对应的shadow_mem(0xfffffbfff8001400)发现, global_var存在34 bytes有效内存, 62 bytes为无效内存(red_zone)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>gef<span style="color:#960050;background-color:#1e0010">➤</span>  disassemble
</span></span><span style="display:flex;"><span>Dump of assembler code <span style="color:#66d9ef">for</span> function kasan_ioctl:
</span></span><span style="display:flex;"><span><span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">0xffffffffc0008000</span> <span style="color:#f92672">&lt;+</span><span style="color:#ae81ff">0</span><span style="color:#f92672">&gt;:</span>     data16 data16 data16 xchg ax,ax
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffffffc0008005</span> <span style="color:#f92672">&lt;+</span><span style="color:#ae81ff">5</span><span style="color:#f92672">&gt;:</span>     push   rbp
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffffffc0008006</span> <span style="color:#f92672">&lt;+</span><span style="color:#ae81ff">6</span><span style="color:#f92672">&gt;:</span>     mov    rdi,<span style="color:#ae81ff">0xffffffffc000a022</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffffffc000800d</span> <span style="color:#f92672">&lt;+</span><span style="color:#ae81ff">13</span><span style="color:#f92672">&gt;:</span>    mov    BYTE PTR [rip<span style="color:#f92672">+</span><span style="color:#ae81ff">0x1fec</span>],<span style="color:#ae81ff">0x78</span>        <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">0xffffffffc000a000</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffffffc0008014</span> <span style="color:#f92672">&lt;+</span><span style="color:#ae81ff">20</span><span style="color:#f92672">&gt;:</span>    mov    rbp,rsp
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffffffc0008017</span> <span style="color:#f92672">&lt;+</span><span style="color:#ae81ff">23</span><span style="color:#f92672">&gt;:</span>    call   <span style="color:#ae81ff">0xffffffff8145d790</span> <span style="color:#f92672">&lt;</span>__asan_store1<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffffffc000801c</span> <span style="color:#f92672">&lt;+</span><span style="color:#ae81ff">28</span><span style="color:#f92672">&gt;:</span>    xor    eax,eax
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffffffc000801e</span> <span style="color:#f92672">&lt;+</span><span style="color:#ae81ff">30</span><span style="color:#f92672">&gt;:</span>    mov    BYTE PTR [rip<span style="color:#f92672">+</span><span style="color:#ae81ff">0x1ffd</span>],<span style="color:#ae81ff">0x2a</span>        <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#ae81ff">0xffffffffc000a022</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffffffc0008025</span> <span style="color:#f92672">&lt;+</span><span style="color:#ae81ff">37</span><span style="color:#f92672">&gt;:</span>    pop    rbp
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffffffc0008026</span> <span style="color:#f92672">&lt;+</span><span style="color:#ae81ff">38</span><span style="color:#f92672">&gt;:</span>    ret
</span></span><span style="display:flex;"><span>End of assembler dump.
</span></span><span style="display:flex;"><span>gef<span style="color:#960050;background-color:#1e0010">➤</span>  x<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>xg <span style="color:#ae81ff">0xffffffffc000a000</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffffffc000a000</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0x0000000064636261</span>      <span style="color:#ae81ff">0x0000000000000000</span>
</span></span><span style="display:flex;"><span>gef<span style="color:#960050;background-color:#1e0010">➤</span>  x<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>xg <span style="color:#ae81ff">0xfffffbfff8001400</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xfffffbfff8001400</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0xfafafa0200000000</span>      <span style="color:#ae81ff">0x00000000fafafafa</span>
</span></span><span style="display:flex;"><span>gef<span style="color:#960050;background-color:#1e0010">➤</span>
</span></span></code></pre></div></li>
<li>
<p>进一步验证red_zone原理(ida显示驱动init_array段中存在指向__asan_register_globals的函数指针, 显然在驱动初始化阶段会调用该函数)</p>
</li>
<li>
<p>分析__asan_register_globals源码发现一个用来修饰全局变量的结构体(存放于.data段), 结合ida反汇编结果后填充结构体如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> kasan_global {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>beg<span style="color:#f92672">=</span><span style="color:#ae81ff">0xffffffffc000a000</span>;		<span style="color:#75715e">/* Address of the beginning of the global variable. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">size_t</span> size<span style="color:#f92672">=</span><span style="color:#ae81ff">0x22</span>;			<span style="color:#75715e">/* Size of the global variable. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">size_t</span> size_with_redzone<span style="color:#f92672">=</span><span style="color:#ae81ff">0x60</span>;	<span style="color:#75715e">/* Size of the variable + size of the red zone. 32 bytes aligned */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;global_var&#34;</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>module_name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/home/povcfe/code/modules/kasan/kasan.c&#34;</span>;	<span style="color:#75715e">/* Name of the module where the global variable is declared. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> has_dynamic_init<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;	<span style="color:#75715e">/* This needed for C++ */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if KASAN_ABI_VERSION &gt;= 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> kasan_source_location <span style="color:#f92672">*</span>location;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#if KASAN_ABI_VERSION &gt;= 5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>odr_indicator<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/home/povcfe/code/modules/kasan/kasan.c&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div></li>
<li>
<p>size_with_redzone=0x60, 动调时发现redzone为62(0x3e) bytes, 显然此处size_with_redzone不可能被直接使用, 继续分析源码</p>
</li>
<li>
<p>__asan_register_globals-&gt;register_global(特别关注aligned_size, 这里会解决上诉问题)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">register_global</span>(<span style="color:#66d9ef">struct</span> kasan_global <span style="color:#f92672">*</span>global)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">size_t</span> aligned_size <span style="color:#f92672">=</span> <span style="color:#a6e22e">round_up</span>(global<span style="color:#f92672">-&gt;</span>size, KASAN_SHADOW_SCALE_SIZE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 设置有效内存对应的shadow_mem, 特别注意内存组内有效N byte不足8 bytes时, 需要设置shadow_value=N
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">kasan_unpoison_shadow</span>(global<span style="color:#f92672">-&gt;</span>beg, global<span style="color:#f92672">-&gt;</span>size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 填充8 bytes对齐的redzone对应的shadow_mem为KASAN_GLOBAL_REDZONE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">kasan_poison_shadow</span>(global<span style="color:#f92672">-&gt;</span>beg <span style="color:#f92672">+</span> aligned_size,
</span></span><span style="display:flex;"><span>		global<span style="color:#f92672">-&gt;</span>size_with_redzone <span style="color:#f92672">-</span> aligned_size,
</span></span><span style="display:flex;"><span>		KASAN_GLOBAL_REDZONE);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>aligned_size</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define __round_mask(x, y) ((__typeof__(x))((y)-1))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define round_up(x, y) ((((x)-1) | __round_mask(x, y))+1)
</span></span></span></code></pre></div></li>
<li>
<p>算数太差, 直接用c实现了一下, aligned_size=0x28</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">size_t</span> <span style="color:#a6e22e">__round_mask</span>(<span style="color:#66d9ef">size_t</span> x, <span style="color:#66d9ef">size_t</span> y)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ((<span style="color:#a6e22e">__typeof__</span>(x))((y)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">size_t</span> <span style="color:#a6e22e">round_up</span>(<span style="color:#66d9ef">size_t</span> x, <span style="color:#66d9ef">size_t</span> y)
</span></span><span style="display:flex;"><span>{   
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ((((x)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">|</span> <span style="color:#a6e22e">__round_mask</span>(x, y))<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">size_t</span> res <span style="color:#f92672">=</span> <span style="color:#a6e22e">round_up</span>(<span style="color:#ae81ff">0x22</span>, <span style="color:#ae81ff">7</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;0x%lx&#34;</span>, res);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>故 global-&gt;size_with_redzone(0x60) = 0x28(0x22(size) + 0x6(red_zone)) + 0x38(red_zone), 即有效内存空间0x22 bytes, red_zone(0x6 + 0x38) bytes</p>
</li>
</ul>
<h3 id="栈变量_kasan">栈变量_kasan</h3>
<blockquote>
<p>__kasan_unpoison_stack: 设置栈内有效内存shadow_mem</p>
</blockquote>
<h4 id="验证代码-2">验证代码</h4>
<ul>
<li>
<p>目标栈变量 stack_var</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">kasan_ioctl</span>(<span style="color:#66d9ef">struct</span> file<span style="color:#f92672">*</span> filp, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> cmd, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span> stack_var[<span style="color:#ae81ff">0x4</span>] <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;c&#39;</span>, <span style="color:#e6db74">&#39;d&#39;</span>};
</span></span><span style="display:flex;"><span>	stack_var[<span style="color:#ae81ff">0x0</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;x&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printk</span>(KERN_DEBUG <span style="color:#e6db74">&#34;[+] %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, stack_var);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>ida反汇编代码(注意到0xF1(KASAN_STACK_LEFT), 0xF3(KASAN_STACK_RIGHT)字段, 猜测stack_kasan的shadow_mem填充代码是直接通过编译器插入源代码中的)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">__int64</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">kasan_ioctl</span>(file <span style="color:#f92672">*</span>filp, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> cmd, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">__int64</span> arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	_DWORD <span style="color:#f92672">*</span>v3; <span style="color:#75715e">// rbx
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	_QWORD v5[<span style="color:#ae81ff">4</span>]; <span style="color:#75715e">// [rsp-70h] [rbp-70h] BYREF
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> v6; <span style="color:#75715e">// [rsp-50h] [rbp-50h] BYREF
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">__int64</span> v7; <span style="color:#75715e">// [rsp-18h] [rbp-18h]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_fentry__</span>(filp, cmd, arg);
</span></span><span style="display:flex;"><span>	v3 <span style="color:#f92672">=</span> (_DWORD <span style="color:#f92672">*</span>)(((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">__int64</span>)v5 <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">3</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x2000040000000000LL</span>);
</span></span><span style="display:flex;"><span>	v5[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1102416563LL</span>;
</span></span><span style="display:flex;"><span>	v5[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1 32 4 12 stack_var:15&#34;</span>;
</span></span><span style="display:flex;"><span>	v5[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> kasan_ioctl;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>v3 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xF1F1F1F1</span>;
</span></span><span style="display:flex;"><span>	v3[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xF3F3F304</span>;
</span></span><span style="display:flex;"><span>	v7 <span style="color:#f92672">=</span> <span style="color:#a6e22e">__readgsqword</span>(<span style="color:#ae81ff">0x28u</span>);
</span></span><span style="display:flex;"><span>	v6 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x64636278</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printk</span>(<span style="color:#f92672">&amp;</span>unk_220, <span style="color:#f92672">&amp;</span>v6);
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>(_QWORD <span style="color:#f92672">*</span>)v3 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<h4 id="栈变量-动态调试">栈变量 动态调试</h4>
<ul>
<li>
<p>根据ida反汇编代码猜测栈变量存在左右边界(red_zone)且关于32 bytes对齐</p>
</li>
<li>
<p>stack_var(0xffff88805b02fcf0)与其shadow_mem(0xffffed100b605f9e)内容如下, 可知栈变量有效内存为4 bytes, red_zone_size: (8 * 3 + 8 - 4) + 8 * 3 = 52(左边界red_zone为32bytes, 右边界red_zone+size关于32 bytes对齐, 总red_zone大小与全局变量相同)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>gef<span style="color:#960050;background-color:#1e0010">➤</span>  x<span style="color:#f92672">/</span><span style="color:#ae81ff">8</span>xg <span style="color:#ae81ff">0xffff88805b02fcf0</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0x20</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffff88805b02fcd0</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0x0000000041b58ab3</span>      <span style="color:#ae81ff">0xffffffffc000903c</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffff88805b02fce0</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0xffffffffc00080e1</span>      <span style="color:#ae81ff">0xffff88805e404500</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffff88805b02fcf0</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0xffff888064636261</span>      <span style="color:#ae81ff">0x0000000200000101</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffff88805b02fd00</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0x000000000000004c</span>      <span style="color:#ae81ff">0x0000000000000000</span>
</span></span><span style="display:flex;"><span>gef<span style="color:#960050;background-color:#1e0010">➤</span>  x<span style="color:#f92672">/</span><span style="color:#ae81ff">4</span>xg <span style="color:#ae81ff">0xffffed100b605f9e</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0x10</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b605f8e</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0x0000000000000000</span>      <span style="color:#ae81ff">0xf1f1f1f100000000</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xffffed100b605f9e</span><span style="color:#f92672">:</span>     <span style="color:#ae81ff">0x00000000f3f3f304</span>      <span style="color:#ae81ff">0x0000000000000000</span>
</span></span><span style="display:flex;"><span>gef<span style="color:#960050;background-color:#1e0010">➤</span>
</span></span></code></pre></div></li>
<li>
<p>待函数返回(栈变量销毁时), 会将shadow_mem置0(见ida伪代码)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f92672">*</span>(_QWORD <span style="color:#f92672">*</span>)v3 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0LL</span>;
</span></span></code></pre></div></li>
<li>
<p>在kasan源码中没有找到填充red_zone的代码, 且栈变量左边界red_zone对应的内存处存放了栈变量信息, 函数信息. 所以猜测栈变量填充red_zone是在编译阶段实现的, 且左边界填充内容为用于描述栈的结构体</p>
</li>
</ul>
</section>

  
  

  
  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    <a
      class="flex w-1/2 items-center rounded-l-md p-6 pr-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]"
      href="https://www.povcfe.site/post/kernel_net/"
      ><span class="mr-1.5">←</span><span>linux内核(5.4.81)---网络模块源码分析</span></a
    >
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]"
      href="https://www.povcfe.site/post/reprint/"
      ><span>一些思考</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  
  

  
  

  
  

  


  
</article>


    </main>

    <footer
  class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"
>
  <div class="mr-auto">
    &copy; 2024
    <a class="link" href="https://www.povcfe.site/">povcfe&#39;s site</a>
  </div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank"
    >Powered by Hugo️️</a
  >️
  <a
    class="link"
    href="https://github.com/nanxiaobei/hugo-paper"
    rel="noopener"
    target="_blank"
    >✎ Paper</a
  >
</footer>

  </body>
</html>
