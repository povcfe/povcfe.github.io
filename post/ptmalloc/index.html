<!doctype html>









































<html
  class="not-ready lg:text-base"
  style="--bg: #faf8f1"
  lang="en-us"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>glibc2.23 ptmalloc 原理概述 - povcfe&#39;s site</title>

  
  <meta name="theme-color" />

  
  
  
  
  <meta name="description" content="发表于看雪论坛
linux用户态下的堆溢出利用即是对ptmalloc2安全机制的绕过，只有深入的了解ptmalloc，才能进行精准的堆溢出攻击
malloc __libc_malloc(传入参数:size) 判断 是否定义hook函数 ，如果存在则调用hook函数，否则跳到2 void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); 执行arena_get得到空闲分配区 arena_get (ar_ptr, bytes); 调用_int_malloc()获得内存地址 victim = _int_malloc (ar_ptr, bytes); 如果分配失败，ptmalloc会尝试再去寻找一个可用的arena并进行内存分配 if (!victim &amp;&amp; ar_ptr != NULL) { LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); } 得到内存地址后解锁分配区 if (ar_ptr != NULL) (void) mutex_unlock (&amp;ar_ptr-&gt;mutex); 如果在上面的步骤中获得非mmap得到的chunk，但是chunk对应的分配区与实际的分配区不相符，则程序终止 assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); _int_malloc errout: 打印错误字符串并 return 判断 size是否大于(unsigned long)(-2*MINSIZE) MINSIZE=chunk的最小大小 ，如果是则return，否则将size转换为chunk_size #define checked_request2size(req, sz) \ if (REQUEST_OUT_OF_RANGE (req)) {	\ __set_errno (ENOMEM);	\ return 0;	\ }	\ (sz) = request2size (req); 判断 前面是否没有获得空闲分配区 如果是则跳到3，否则跳到4 if (__glibc_unlikely (av == NULL)) 调用sysmalloc尝试获得chunk地址，如果得到则调用alloc_perturb 将清理空间数据，return chunk地址 if (__glibc_unlikely (av == NULL)) { void *p = sysmalloc (nb, av); if (p !" />
  <meta name="author" content="povcfe" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://povcfe.github.io/main.min.css" />

  
  
  
  
  
  <link rel="preload" as="image" href="https://povcfe.github.io/theme.png" />

  
  
  
  
  <link rel="preload" as="image" href="https://povcfe.github.io/avatar.jpg" />
  
  

  
  
  <link rel="preload" as="image" href="https://povcfe.github.io/twitter.svg" />
  
  <link rel="preload" as="image" href="https://povcfe.github.io/github.svg" />
  
  <link rel="preload" as="image" href="https://povcfe.github.io/rss.svg" />
  
  

  
  
  <script
    defer
    src="https://povcfe.github.io/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
  
  

  
  <link rel="icon" href="https://povcfe.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://povcfe.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.111.3">

  
  
  
  
  
  <meta itemprop="name" content="glibc2.23 ptmalloc 原理概述">
<meta itemprop="description" content="发表于看雪论坛
linux用户态下的堆溢出利用即是对ptmalloc2安全机制的绕过，只有深入的了解ptmalloc，才能进行精准的堆溢出攻击
malloc __libc_malloc(传入参数:size) 判断 是否定义hook函数 ，如果存在则调用hook函数，否则跳到2 void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); 执行arena_get得到空闲分配区 arena_get (ar_ptr, bytes); 调用_int_malloc()获得内存地址 victim = _int_malloc (ar_ptr, bytes); 如果分配失败，ptmalloc会尝试再去寻找一个可用的arena并进行内存分配 if (!victim &amp;&amp; ar_ptr != NULL) { LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); } 得到内存地址后解锁分配区 if (ar_ptr != NULL) (void) mutex_unlock (&amp;ar_ptr-&gt;mutex); 如果在上面的步骤中获得非mmap得到的chunk，但是chunk对应的分配区与实际的分配区不相符，则程序终止 assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); _int_malloc errout: 打印错误字符串并 return 判断 size是否大于(unsigned long)(-2*MINSIZE) MINSIZE=chunk的最小大小 ，如果是则return，否则将size转换为chunk_size #define checked_request2size(req, sz) \ if (REQUEST_OUT_OF_RANGE (req)) {	\ __set_errno (ENOMEM);	\ return 0;	\ }	\ (sz) = request2size (req); 判断 前面是否没有获得空闲分配区 如果是则跳到3，否则跳到4 if (__glibc_unlikely (av == NULL)) 调用sysmalloc尝试获得chunk地址，如果得到则调用alloc_perturb 将清理空间数据，return chunk地址 if (__glibc_unlikely (av == NULL)) { void *p = sysmalloc (nb, av); if (p !"><meta itemprop="datePublished" content="2019-10-06T00:00:00-04:00" />
<meta itemprop="dateModified" content="2019-10-06T00:00:00-04:00" />
<meta itemprop="wordCount" content="1644">
<meta itemprop="keywords" content="" />
  
  <meta property="og:title" content="glibc2.23 ptmalloc 原理概述" />
<meta property="og:description" content="发表于看雪论坛
linux用户态下的堆溢出利用即是对ptmalloc2安全机制的绕过，只有深入的了解ptmalloc，才能进行精准的堆溢出攻击
malloc __libc_malloc(传入参数:size) 判断 是否定义hook函数 ，如果存在则调用hook函数，否则跳到2 void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); 执行arena_get得到空闲分配区 arena_get (ar_ptr, bytes); 调用_int_malloc()获得内存地址 victim = _int_malloc (ar_ptr, bytes); 如果分配失败，ptmalloc会尝试再去寻找一个可用的arena并进行内存分配 if (!victim &amp;&amp; ar_ptr != NULL) { LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); } 得到内存地址后解锁分配区 if (ar_ptr != NULL) (void) mutex_unlock (&amp;ar_ptr-&gt;mutex); 如果在上面的步骤中获得非mmap得到的chunk，但是chunk对应的分配区与实际的分配区不相符，则程序终止 assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); _int_malloc errout: 打印错误字符串并 return 判断 size是否大于(unsigned long)(-2*MINSIZE) MINSIZE=chunk的最小大小 ，如果是则return，否则将size转换为chunk_size #define checked_request2size(req, sz) \ if (REQUEST_OUT_OF_RANGE (req)) {	\ __set_errno (ENOMEM);	\ return 0;	\ }	\ (sz) = request2size (req); 判断 前面是否没有获得空闲分配区 如果是则跳到3，否则跳到4 if (__glibc_unlikely (av == NULL)) 调用sysmalloc尝试获得chunk地址，如果得到则调用alloc_perturb 将清理空间数据，return chunk地址 if (__glibc_unlikely (av == NULL)) { void *p = sysmalloc (nb, av); if (p !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://povcfe.github.io/post/ptmalloc/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-10-06T00:00:00-04:00" />
<meta property="article:modified_time" content="2019-10-06T00:00:00-04:00" />

  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="glibc2.23 ptmalloc 原理概述"/>
<meta name="twitter:description" content="发表于看雪论坛
linux用户态下的堆溢出利用即是对ptmalloc2安全机制的绕过，只有深入的了解ptmalloc，才能进行精准的堆溢出攻击
malloc __libc_malloc(传入参数:size) 判断 是否定义hook函数 ，如果存在则调用hook函数，否则跳到2 void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); 执行arena_get得到空闲分配区 arena_get (ar_ptr, bytes); 调用_int_malloc()获得内存地址 victim = _int_malloc (ar_ptr, bytes); 如果分配失败，ptmalloc会尝试再去寻找一个可用的arena并进行内存分配 if (!victim &amp;&amp; ar_ptr != NULL) { LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); } 得到内存地址后解锁分配区 if (ar_ptr != NULL) (void) mutex_unlock (&amp;ar_ptr-&gt;mutex); 如果在上面的步骤中获得非mmap得到的chunk，但是chunk对应的分配区与实际的分配区不相符，则程序终止 assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); _int_malloc errout: 打印错误字符串并 return 判断 size是否大于(unsigned long)(-2*MINSIZE) MINSIZE=chunk的最小大小 ，如果是则return，否则将size转换为chunk_size #define checked_request2size(req, sz) \ if (REQUEST_OUT_OF_RANGE (req)) {	\ __set_errno (ENOMEM);	\ return 0;	\ }	\ (sz) = request2size (req); 判断 前面是否没有获得空闲分配区 如果是则跳到3，否则跳到4 if (__glibc_unlikely (av == NULL)) 调用sysmalloc尝试获得chunk地址，如果得到则调用alloc_perturb 将清理空间数据，return chunk地址 if (__glibc_unlikely (av == NULL)) { void *p = sysmalloc (nb, av); if (p !"/>

  
  
  
  <link rel="canonical" href="https://povcfe.github.io/post/ptmalloc/" />
  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center">
  <div class="relative z-50 mr-auto flex items-center">
    <a
      class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold"
      href="https://povcfe.github.io/"
      >povcfe&#39;s site</a
    >
    <div
      class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]"
      role="button"
      aria-label="Dark"
    ></div>
  </div>

  <div
    class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
    role="button"
    aria-label="Menu"
  ></div>

  

  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = '#faf8f1'.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"
    >
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./twitter.svg)"
        href="https://twitter.com/povcfe"
        target="_blank"
        rel="me"
      >
        twitter
      </a>
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href="https://github.com/povcfe"
        target="_blank"
        rel="me"
      >
        github
      </a>
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./rss.svg)"
        href="https://povcfe.github.io/index.xml"
        target="_blank"
        rel="alternate"
      >
        rss
      </a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"
    >
      

<article>
  <header class="mb-16">
    <h1 class="!my-0 pb-2.5">glibc2.23 ptmalloc 原理概述</h1>

    
    <div class="text-sm antialiased opacity-60">
      
      <time>Oct 6, 2019</time>
      
      
      
      
    </div>
    
  </header>

  <section><p><a href="https://bbs.pediy.com/user-839858.htm">发表于看雪论坛</a></p>
<blockquote>
<p>linux用户态下的堆溢出利用即是对ptmalloc2安全机制的绕过，只有深入的了解ptmalloc，才能进行精准的堆溢出攻击</p>
</blockquote>
<h2 id="malloc">malloc</h2>
<h3 id="__libc_malloc传入参数size">__libc_malloc(传入参数:size)</h3>
<ol>
<li>判断 <strong>是否定义hook函数</strong> ，如果存在则调用hook函数，否则跳到2</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>hook) (<span style="color:#66d9ef">size_t</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">=</span> <span style="color:#a6e22e">atomic_forced_read</span> (__malloc_hook);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">__builtin_expect</span> (hook <span style="color:#f92672">!=</span> NULL, <span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#f92672">*</span>hook)(bytes, <span style="color:#a6e22e">RETURN_ADDRESS</span> (<span style="color:#ae81ff">0</span>));
</span></span></code></pre></div><ol start="2">
<li>执行arena_get得到空闲分配区</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">arena_get</span> (ar_ptr, bytes);
</span></span></code></pre></div><ol start="3">
<li>调用_int_malloc()获得内存地址</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>victim <span style="color:#f92672">=</span> <span style="color:#a6e22e">_int_malloc</span> (ar_ptr, bytes);
</span></span></code></pre></div><ol start="4">
<li>如果分配失败，ptmalloc会尝试再去寻找一个可用的arena并进行内存分配</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>victim <span style="color:#f92672">&amp;&amp;</span> ar_ptr <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">LIBC_PROBE</span> (memory_malloc_retry, <span style="color:#ae81ff">1</span>, bytes);
</span></span><span style="display:flex;"><span>      ar_ptr <span style="color:#f92672">=</span> <span style="color:#a6e22e">arena_get_retry</span> (ar_ptr, bytes);
</span></span><span style="display:flex;"><span>      victim <span style="color:#f92672">=</span> <span style="color:#a6e22e">_int_malloc</span> (ar_ptr, bytes);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><ol start="5">
<li>得到内存地址后解锁分配区</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (ar_ptr <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">void</span>) <span style="color:#a6e22e">mutex_unlock</span> (<span style="color:#f92672">&amp;</span>ar_ptr<span style="color:#f92672">-&gt;</span>mutex);
</span></span></code></pre></div><ol start="6">
<li>如果在上面的步骤中获得非mmap得到的chunk，但是chunk对应的分配区与实际的分配区不相符，则程序终止</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">assert</span> (<span style="color:#f92672">!</span>victim <span style="color:#f92672">||</span> <span style="color:#a6e22e">chunk_is_mmapped</span> (<span style="color:#a6e22e">mem2chunk</span> (victim)) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>          ar_ptr <span style="color:#f92672">==</span> <span style="color:#a6e22e">arena_for_chunk</span> (<span style="color:#a6e22e">mem2chunk</span> (victim)));
</span></span></code></pre></div><h3 id="_int_malloc">_int_malloc</h3>
<ul>
<li>errout:
<ul>
<li>打印错误字符串并 return</li>
</ul>
</li>
</ul>
<ol>
<li>判断 <strong>size是否大于(unsigned long)(-2*MINSIZE)</strong> MINSIZE=chunk的最小大小 ，如果是则return，否则将size转换为chunk_size</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define checked_request2size(req, sz)                             \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  if (REQUEST_OUT_OF_RANGE (req)) {					      \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">      __set_errno (ENOMEM);						      \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">      return 0;								      \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    }									      \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  (sz) = request2size (req);
</span></span></span></code></pre></div><ol start="2">
<li>判断 <strong>前面是否没有获得空闲分配区</strong> 如果是则跳到3，否则跳到4</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">__glibc_unlikely</span> (av <span style="color:#f92672">==</span> NULL))
</span></span></code></pre></div><ol start="3">
<li>调用sysmalloc尝试获得chunk地址，如果得到则调用alloc_perturb 将清理空间数据，return chunk地址</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">__glibc_unlikely</span> (av <span style="color:#f92672">==</span> NULL))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#a6e22e">sysmalloc</span> (nb, av);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (p <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">alloc_perturb</span> (p, bytes);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><ol start="4">
<li>(从fastbin中分配chunk) 判断 <strong>size是否小于global_max_fast</strong> ,如果是跳到5，否则跳到10</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> ((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) (nb) <span style="color:#f92672">&lt;=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) (<span style="color:#a6e22e">get_max_fast</span> ()))
</span></span></code></pre></div><ol start="5">
<li>根据size获得fastbin索引x，定位当前分配区fastbin<input checked="" disabled="" type="checkbox"> </li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> ((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) (nb) <span style="color:#f92672">&lt;=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) (<span style="color:#a6e22e">get_max_fast</span> ()))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    idx <span style="color:#f92672">=</span> <span style="color:#a6e22e">fastbin_index</span> (nb);
</span></span><span style="display:flex;"><span>    mfastbinptr <span style="color:#f92672">*</span>fb <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">fastbin</span> (av, idx);
</span></span><span style="display:flex;"><span>    mchunkptr pp <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>fb;
</span></span></code></pre></div><ol start="6">
<li>令victim=fastbin<input checked="" disabled="" type="checkbox"> ,判断 <strong>victim是否等于NULL</strong> 如果是则跳到7，否则fastbin<input checked="" disabled="" type="checkbox"> =fastbin<input checked="" disabled="" type="checkbox"> -&gt;fd</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    victim <span style="color:#f92672">=</span> pp;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (victim <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> ((pp <span style="color:#f92672">=</span> <span style="color:#a6e22e">catomic_compare_and_exchange_val_acq</span> (fb, victim<span style="color:#f92672">-&gt;</span>fd, victim))
</span></span><span style="display:flex;"><span>             <span style="color:#f92672">!=</span> victim);
</span></span></code></pre></div><ol start="7">
<li>
<p>判断 <strong>victim是否不等于0</strong> 如果是跳到8，否则跳到10</p>
</li>
<li>
<p>判断 <strong>victim_size对应的fastbin索引是否不等于size对应的fastbin索引</strong> ，如果是则goto errout <strong>(errstr = &ldquo;malloc(): memory corruption (fast)&rdquo;)</strong> 否则跳到9</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">__builtin_expect</span> (<span style="color:#a6e22e">fastbin_index</span> (<span style="color:#a6e22e">chunksize</span> (victim)) <span style="color:#f92672">!=</span> idx, <span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        errstr <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;malloc(): memory corruption (fast)&#34;</span>;
</span></span><span style="display:flex;"><span>    errout:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">malloc_printerr</span> (check_action, errstr, <span style="color:#a6e22e">chunk2mem</span> (victim), av);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><ol start="9">
<li>将victim chunk指针转换为用户数据区指针，调用alloc_perturb()对用户数据区进行初始化，return</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#a6e22e">chunk2mem</span> (victim);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">alloc_perturb</span> (p, bytes);
</span></span></code></pre></div><ol start="10">
<li>(从smallbin中分配chunk) 判断 <strong>size是否在smallbin范围(小于MIN_LARGE_SIZE)内</strong> 如果是则跳到11，否则跳到18</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">in_smallbin_range</span> (nb))
</span></span></code></pre></div><ol start="11">
<li>根据size获得smallbin的索引x，定位本分配区的smallbin<input checked="" disabled="" type="checkbox"> </li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>idx <span style="color:#f92672">=</span> <span style="color:#a6e22e">smallbin_index</span> (nb);
</span></span><span style="display:flex;"><span>bin <span style="color:#f92672">=</span> <span style="color:#a6e22e">bin_at</span> (av, idx);
</span></span></code></pre></div><ol start="12">
<li>
<p>令victim等于smallbin<input checked="" disabled="" type="checkbox"> -&gt;bk,判断 <strong>smallbin<input checked="" disabled="" type="checkbox"> -&gt;bk是否不等于smallbin<input checked="" disabled="" type="checkbox"> (即smallbin是否不为空)</strong> 如果是则跳到13，否则跳到18</p>
</li>
<li>
<p>判断 <strong>smallbin<input checked="" disabled="" type="checkbox"> -&gt;bk是否等于0</strong> 如果是则执行malloc_consolidate进行初始化，否则跳到14</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (victim <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#75715e">/* initialization check */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">malloc_consolidate</span> (av);
</span></span></code></pre></div><ol start="14">
<li>判断 <strong>victim-&gt;bk-&gt;fd是否不等于victim</strong> 如果是则goto errout <strong>(errstr = &ldquo;malloc(): smallbin double linked list corrupted&rdquo;)</strong> 否则跳到15</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>bck <span style="color:#f92672">=</span> victim<span style="color:#f92672">-&gt;</span>bk;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">__glibc_unlikely</span> (bck<span style="color:#f92672">-&gt;</span>fd <span style="color:#f92672">!=</span> victim))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        errstr <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;malloc(): smallbin double linked list corrupted&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> errout;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><ol start="15">
<li>设置victim的下一个chunk 标志位为pre_chunk_inuse,将smallbin<input checked="" disabled="" type="checkbox"> -&gt;bk从双链表中摘除(smallbin<input checked="" disabled="" type="checkbox"> -&gt;bk＝smallbin<input checked="" disabled="" type="checkbox"> -&gt;bk-&gt;bk,smallbin<input checked="" disabled="" type="checkbox"> -&gt;bk-&gt;fd=smallbin<input checked="" disabled="" type="checkbox"> )</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">set_inuse_bit_at_offset</span> (victim, nb);
</span></span><span style="display:flex;"><span>bin<span style="color:#f92672">-&gt;</span>bk <span style="color:#f92672">=</span> bck;
</span></span><span style="display:flex;"><span>bck<span style="color:#f92672">-&gt;</span>fd <span style="color:#f92672">=</span> bin;
</span></span></code></pre></div><ol start="16">
<li>如果当前分配区不是main_arena,则设置victim的标志位为NON_MAIN_ARENA</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (av <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>main_arena)
</span></span><span style="display:flex;"><span>    victim<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">|=</span> NON_MAIN_ARENA;
</span></span></code></pre></div><ol start="17">
<li>将victim chunk指针转换为用户数据区指针，调用alloc_perturb()对用户数据区进行初始化，return</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#a6e22e">chunk2mem</span> (victim);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">alloc_perturb</span> (p, bytes);
</span></span></code></pre></div><ol start="18">
<li>根据size获得largebin的索引x</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>idx <span style="color:#f92672">=</span> <span style="color:#a6e22e">largebin_index</span> (nb);
</span></span></code></pre></div><ol start="19">
<li>判断<strong>当前分配区是否存在fastbin</strong> (通过flag标志位)如果是则执行malloc_consolidate合并fastbin</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">have_fastchunks</span> (av))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">malloc_consolidate</span> (av);
</span></span></code></pre></div><ol start="20">
<li>(处理unsortedbin) 令victim等于unsortedbin-&gt;bk, (while循环/20-32/ 直至unsortedbin为空) 判断 <strong>unsortedbin-&gt;bk是否不等于unsortedbin</strong> ，如果是跳到21，否则跳到32</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">while</span> ((victim <span style="color:#f92672">=</span> <span style="color:#a6e22e">unsorted_chunks</span> (av)<span style="color:#f92672">-&gt;</span>bk) <span style="color:#f92672">!=</span> <span style="color:#a6e22e">unsorted_chunks</span> (av))
</span></span></code></pre></div><ol start="21">
<li>判断 <strong>victim_size是否小于等于2*SIZE_SZ或者victim_size是否大于system_mem</strong> ,如果是则打印错误 <strong>(&ldquo;malloc(): memory corruption&rdquo;)</strong> 并退出，否则跳到22</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">__builtin_expect</span> (victim<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> SIZE_SZ, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">||</span> <span style="color:#a6e22e">__builtin_expect</span> (victim<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">&gt;</span> av<span style="color:#f92672">-&gt;</span>system_mem, <span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">malloc_printerr</span> (check_action, <span style="color:#e6db74">&#34;malloc(): memory corruption&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">chunk2mem</span> (victim), av);
</span></span></code></pre></div><ol start="22">
<li>判断 <strong>size是否在smallbin范围内并且victim-&gt;bk是否等于unsortedbin(即unsorted bin 是否只存在一个chunk)并且unsortedbin的当前chunk是否为last_remainder并且victim_size是否大于(nb+MINSIZE)</strong> 如果是则切割chunk并产生last_remainder,否则跳到25</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">in_smallbin_range</span> (nb) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>              bck <span style="color:#f92672">==</span> <span style="color:#a6e22e">unsorted_chunks</span> (av) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>              victim <span style="color:#f92672">==</span> av<span style="color:#f92672">-&gt;</span>last_remainder <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>              (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) (size) <span style="color:#f92672">&gt;</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) (nb <span style="color:#f92672">+</span> MINSIZE))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* split and reattach remainder */</span>
</span></span><span style="display:flex;"><span>    remainder_size <span style="color:#f92672">=</span> size <span style="color:#f92672">-</span> nb;
</span></span><span style="display:flex;"><span>    remainder <span style="color:#f92672">=</span> <span style="color:#a6e22e">chunk_at_offset</span> (victim, nb);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">unsorted_chunks</span> (av)<span style="color:#f92672">-&gt;</span>bk <span style="color:#f92672">=</span> <span style="color:#a6e22e">unsorted_chunks</span> (av)<span style="color:#f92672">-&gt;</span>fd <span style="color:#f92672">=</span> remainder;
</span></span><span style="display:flex;"><span>    av<span style="color:#f92672">-&gt;</span>last_remainder <span style="color:#f92672">=</span> remainder;
</span></span></code></pre></div><ol start="23">
<li>如果切割后的last_remainder_size在smallbin范围内，则将新的last_remainder的fd_nextsize和bk_nextsize清零</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">in_smallbin_range</span> (remainder_size))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    remainder<span style="color:#f92672">-&gt;</span>fd_nextsize <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    remainder<span style="color:#f92672">-&gt;</span>bk_nextsize <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="24">
<li>设置victim的pre_inuse和main_arena标志位，设置last_remainder的pre_inuse标志位和last_remainder下一个块的pre_inuse标志位，将victim转换为用户数据区地址，调用alloc_perturb()对用户数据区进行初始化，return</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">set_head</span> (victim, nb <span style="color:#f92672">|</span> PREV_INUSE <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>                        (av <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>main_arena <span style="color:#f92672">?</span> NON_MAIN_ARENA : <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">set_head</span> (remainder, remainder_size <span style="color:#f92672">|</span> PREV_INUSE);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">set_foot</span> (remainder, remainder_size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">check_malloced_chunk</span> (av, victim, nb);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#a6e22e">chunk2mem</span> (victim);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">alloc_perturb</span> (p, bytes);
</span></span></code></pre></div><ol start="25">
<li>将victim从unsortedbin中移除</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">unsorted_chunks</span> (av)<span style="color:#f92672">-&gt;</span>bk <span style="color:#f92672">=</span> bck;
</span></span><span style="display:flex;"><span>bck<span style="color:#f92672">-&gt;</span>fd <span style="color:#f92672">=</span> <span style="color:#a6e22e">unsorted_chunks</span> (av);
</span></span></code></pre></div><ol start="26">
<li>
<p>判断 <strong>victim_size是否等于size(即当前unsortedbin是否与请求等大)</strong> 如果是则跳到27，否则跳到28</p>
</li>
<li>
<p>设置victim下一个块的pre_inuse标志位，设置victim的main_arena标志位，将victim转换为用户数据区地址，调用alloc_perturb()对用户数据区进行初始化，return</p>
</li>
<li>
<p>(将unsortedbin放入对应的smallbin或者largebin) 判断 <strong>victim_size是否在smallbin范围内</strong> 如果是则获得victim在smallbin中的索引y及其在smallbin[y]目标放置位的前一个块和后一个块(放在smallbin的头部)然后跳到31，否则跳到29</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">in_smallbin_range</span> (size))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    victim_index <span style="color:#f92672">=</span> <span style="color:#a6e22e">smallbin_index</span> (size);
</span></span><span style="display:flex;"><span>    bck <span style="color:#f92672">=</span> <span style="color:#a6e22e">bin_at</span> (av, victim_index);
</span></span><span style="display:flex;"><span>    fwd <span style="color:#f92672">=</span> bck<span style="color:#f92672">-&gt;</span>fd;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="29">
<li>获得victim在largebin中的索引y及其前一个块和后一个块(largebin[y]中chunk按大小排列,具体方法见30)</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>victim_index <span style="color:#f92672">=</span> <span style="color:#a6e22e">largebin_index</span> (size);
</span></span><span style="display:flex;"><span>bck <span style="color:#f92672">=</span> <span style="color:#a6e22e">bin_at</span> (av, victim_index);
</span></span><span style="display:flex;"><span>fwd <span style="color:#f92672">=</span> bck<span style="color:#f92672">-&gt;</span>fd;
</span></span></code></pre></div><ol start="30">
<li>
<p>利用循环和fd_nextsize指针寻找大于victim_size的chunk(如果victim_size小于最小的chunk,则不进入循环)</p>
</li>
<li>
<p>设置分配区的binmap，将victim插入目标放置</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">mark_bin</span> (av, victim_index);
</span></span><span style="display:flex;"><span>victim<span style="color:#f92672">-&gt;</span>bk <span style="color:#f92672">=</span> bck;
</span></span><span style="display:flex;"><span>victim<span style="color:#f92672">-&gt;</span>fd <span style="color:#f92672">=</span> fwd;
</span></span><span style="display:flex;"><span>fwd<span style="color:#f92672">-&gt;</span>bk <span style="color:#f92672">=</span> victim;
</span></span><span style="display:flex;"><span>bck<span style="color:#f92672">-&gt;</span>fd <span style="color:#f92672">=</span> victim;
</span></span></code></pre></div><ol start="32">
<li>迭代器＋1，当迭代器小于10000时，跳回20</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define MAX_ITERS       10000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">++</span>iters <span style="color:#f92672">&gt;=</span> MAX_ITERS)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">break</span>;
</span></span></code></pre></div><ol start="33">
<li>(从largebin中分配chunk) 判断 <strong>size是否不在smallbin范围内</strong> 如果是跳到34，否则跳到40</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">in_smallbin_range</span> (nb))
</span></span></code></pre></div><ol start="34">
<li>定位largebin<input checked="" disabled="" type="checkbox"> ,令victim = largebin<input checked="" disabled="" type="checkbox"> -&gt;fd,判断 <strong>victim是否不等于&amp;largebin<input checked="" disabled="" type="checkbox"> (largebin 是否不为空)并且victim_size是否大于等于size</strong> 如果是则跳到35，否则跳到40</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> ((victim <span style="color:#f92672">=</span> <span style="color:#a6e22e">first</span> (bin)) <span style="color:#f92672">!=</span> bin <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) (victim<span style="color:#f92672">-&gt;</span>size) <span style="color:#f92672">&gt;=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) (nb))
</span></span></code></pre></div><ol start="35">
<li>利用bk_nextsize找到chunk(同步赋值给victim),使得victim_size大于size</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>victim <span style="color:#f92672">=</span> victim<span style="color:#f92672">-&gt;</span>bk_nextsize;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) (size <span style="color:#f92672">=</span> <span style="color:#a6e22e">chunksize</span> (victim)) <span style="color:#f92672">&lt;</span>
</span></span><span style="display:flex;"><span>        (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) (nb)))
</span></span><span style="display:flex;"><span>victim <span style="color:#f92672">=</span> victim<span style="color:#f92672">-&gt;</span>bk_nextsize;
</span></span></code></pre></div><ol start="36">
<li>如果victim不等于largebin<input checked="" disabled="" type="checkbox"> -&gt;bk且victim_size等于victim-&gt;fd-&gt;size，则令victim=victim-&gt;fd</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (victim <span style="color:#f92672">!=</span> <span style="color:#a6e22e">last</span> (bin) <span style="color:#f92672">&amp;&amp;</span> victim<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">==</span> victim<span style="color:#f92672">-&gt;</span>fd<span style="color:#f92672">-&gt;</span>size)
</span></span><span style="display:flex;"><span>    victim <span style="color:#f92672">=</span> victim<span style="color:#f92672">-&gt;</span>fd;
</span></span></code></pre></div><ol start="37">
<li>使用unlink取出victim，切割largebin，判断 <strong>remainder_size是否小于MINSIZE</strong> 如果是则只设置victim的下一个块的标志位pre_inuse和main_arena，否则跳到38</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>remainder_size <span style="color:#f92672">=</span> size <span style="color:#f92672">-</span> nb;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">unlink</span> (av, victim, bck, fwd);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (remainder_size <span style="color:#f92672">&lt;</span> MINSIZE)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">set_inuse_bit_at_offset</span> (victim, size);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (av <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>main_arena)
</span></span><span style="display:flex;"><span>    victim<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">|=</span> NON_MAIN_ARENA;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="38">
<li>将剩余的chunk放入unsortedbin 判断 <strong>unsortedbin-&gt;fd-&gt;bk是否不等于unsortedbin</strong> ，如果是则goto errout <strong>errstr = &ldquo;malloc(): corrupted unsorted chunks&rdquo;</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>remainder <span style="color:#f92672">=</span> <span style="color:#a6e22e">chunk_at_offset</span> (victim, nb);
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* We cannot assume the unsorted list is empty and therefore
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    have to perform a complete insert here.  */</span>
</span></span><span style="display:flex;"><span>bck <span style="color:#f92672">=</span> <span style="color:#a6e22e">unsorted_chunks</span> (av);
</span></span><span style="display:flex;"><span>fwd <span style="color:#f92672">=</span> bck<span style="color:#f92672">-&gt;</span>fd;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">__glibc_unlikely</span> (fwd<span style="color:#f92672">-&gt;</span>bk <span style="color:#f92672">!=</span> bck))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    errstr <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;malloc(): corrupted unsorted chunks&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> errout;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="39">
<li>
<p>设置剩余chunk的标志位及bin链表，将victim转换为用户数据区地址，调用alloc_perturb()对用户数据区进行初始化，return</p>
</li>
<li>
<p>遍历largebin寻找满足要求的空闲块(使用binmap和block缩短检索时间)，如果找到则按照上诉方式分配victim，否则跳到41</p>
</li>
<li>
<p>(从top_chunk中分配chunk) 令victim等于top_chunk,判断 <strong>top_chunk_size是否大于等于(size+MINSIZE)</strong> 如果是则切割top_chunk赋值给victim,将victim转换为用户数据区地址，调用alloc_perturb()对用户数据区进行初始化，return 否则跳到42</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>victim <span style="color:#f92672">=</span> av<span style="color:#f92672">-&gt;</span>top;
</span></span><span style="display:flex;"><span>size <span style="color:#f92672">=</span> <span style="color:#a6e22e">chunksize</span> (victim);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> ((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) (size) <span style="color:#f92672">&gt;=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) (nb <span style="color:#f92672">+</span> MINSIZE))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    remainder_size <span style="color:#f92672">=</span> size <span style="color:#f92672">-</span> nb;
</span></span><span style="display:flex;"><span>    remainder <span style="color:#f92672">=</span> <span style="color:#a6e22e">chunk_at_offset</span> (victim, nb);
</span></span><span style="display:flex;"><span>    av<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> remainder;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">set_head</span> (victim, nb <span style="color:#f92672">|</span> PREV_INUSE <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>            (av <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>main_arena <span style="color:#f92672">?</span> NON_MAIN_ARENA : <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">set_head</span> (remainder, remainder_size <span style="color:#f92672">|</span> PREV_INUSE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">check_malloced_chunk</span> (av, victim, nb);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#a6e22e">chunk2mem</span> (victim);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">alloc_perturb</span> (p, bytes);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="42">
<li>判断 <strong>分配区是否存在fastbin</strong> 如果存在则执行malloc_consolidate()，获得size 在bin中的索引，否则跳到43</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (<span style="color:#a6e22e">have_fastchunks</span> (av))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">malloc_consolidate</span> (av);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* restore original bin index */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">in_smallbin_range</span> (nb))
</span></span><span style="display:flex;"><span>    idx <span style="color:#f92672">=</span> <span style="color:#a6e22e">smallbin_index</span> (nb);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    idx <span style="color:#f92672">=</span> <span style="color:#a6e22e">largebin_index</span> (nb);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="43">
<li>使用sysmalloc分配空间，使用alloc_perturb 清空内存，return</li>
</ol>
<pre tabindex="0"><code>else
{
    void *p = sysmalloc (nb, av);
    if (p != NULL)
    alloc_perturb (p, bytes);
    return p;
}
</code></pre><h3 id="malloc_consolidate">malloc_consolidate</h3>
<ol>
<li>如果max_fast不为0，则清空分配区have_fastbin标志，否则执行malloc_init_state进行初始化</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">get_max_fast</span> () <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">clear_fastchunks</span>(av);
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">malloc_init_state</span>(av);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">check_malloc_state</span>(av);
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><ol start="2">
<li>获得unsortedbin，fastbin[0]，fastbin[MAX]地址</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>maxfb <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">fastbin</span> (av, NFASTBINS <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>fb <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">fastbin</span> (av, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><ol start="3">
<li>
<p>遍历fastbin中的所有chunk，对每个chunk做如下操作</p>
</li>
<li>
<p>获得chunk_size,下一个块的地址与next_chunk_size</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>size <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>(PREV_INUSE<span style="color:#f92672">|</span>NON_MAIN_ARENA);
</span></span><span style="display:flex;"><span>nextchunk <span style="color:#f92672">=</span> <span style="color:#a6e22e">chunk_at_offset</span>(p, size);
</span></span><span style="display:flex;"><span>nextsize <span style="color:#f92672">=</span> <span style="color:#a6e22e">chunksize</span>(nextchunk);
</span></span></code></pre></div><ol start="5">
<li>判断 <strong>上一个块是否空闲</strong> 如果是则合并chunk，并使用unlink将上一个块从bin中释放，否则跳到6</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">prev_inuse</span>(p)) {
</span></span><span style="display:flex;"><span>    prevsize <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>prev_size;
</span></span><span style="display:flex;"><span>    size <span style="color:#f92672">+=</span> prevsize;
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> <span style="color:#a6e22e">chunk_at_offset</span>(p, <span style="color:#f92672">-</span>((<span style="color:#66d9ef">long</span>) prevsize));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">unlink</span>(av, p, bck, fwd);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><ol start="6">
<li>
<p>判断 <strong>下一个块是否不是是top_chunk</strong> 如果是则跳到7，否则跳到9</p>
</li>
<li>
<p>判断 <strong>下一个块是否空闲</strong> 如果是则合并chunk，并使用unlink将下一个块从bin中释放，否则跳到8</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>nextinuse <span style="color:#f92672">=</span> <span style="color:#a6e22e">inuse_bit_at_offset</span>(nextchunk, nextsize);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>nextinuse) {
</span></span><span style="display:flex;"><span>    size <span style="color:#f92672">+=</span> nextsize;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">unlink</span>(av, nextchunk, bck, fwd);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="8">
<li>将chunk插入unsortedbin头部，return</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>unsorted_bin<span style="color:#f92672">-&gt;</span>fd <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>first_unsorted<span style="color:#f92672">-&gt;</span>bk <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">in_smallbin_range</span> (size)) {
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">-&gt;</span>fd_nextsize <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    p<span style="color:#f92672">-&gt;</span>bk_nextsize <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">set_head</span>(p, size <span style="color:#f92672">|</span> PREV_INUSE);
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">-&gt;</span>bk <span style="color:#f92672">=</span> unsorted_bin;
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">-&gt;</span>fd <span style="color:#f92672">=</span> first_unsorted;
</span></span></code></pre></div><ol start="9">
<li>将chunk与top_chunk合并，return</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    size <span style="color:#f92672">+=</span> nextsize;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">set_head</span>(p, size <span style="color:#f92672">|</span> PREV_INUSE);
</span></span><span style="display:flex;"><span>    av<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="free">free</h2>
<h3 id="__libc_free传入参数待释放指针">__libc_free(传入参数:待释放指针)</h3>
<ol>
<li>判断 <strong>是否定义hook函数</strong> ，如果存在则调用hook函数，否则跳到2</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>hook) (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">=</span> <span style="color:#a6e22e">atomic_forced_read</span> (__free_hook);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">__builtin_expect</span> (hook <span style="color:#f92672">!=</span> NULL, <span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    (<span style="color:#f92672">*</span>hook)(mem, <span style="color:#a6e22e">RETURN_ADDRESS</span> (<span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="2">
<li>判断 <strong>传入指针是否为0</strong> ，如果为0(0为无效指针)则return，否则跳到3</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (mem <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)                              <span style="color:#75715e">/* free(0) has no effect */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span></code></pre></div><ol start="3">
<li>
<p>将传入指针转换为chunk指针</p>
</li>
<li>
<p>判断 <strong>chunk是否是由mmap分配得到</strong> ，如果是则跳到5，否则跳到8</p>
</li>
<li>
<p>判断 <strong>是否没有禁用动态阈值选项且chunk大小是否大于mmap分配阈值且chunk大小是否小于mmap默认最大分配阈值</strong> ，如果是则跳到6，否则跳到7</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">chunk_is_mmapped</span> (p))                       <span style="color:#75715e">/* release mmapped memory. */</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* see if the dynamic brk/mmap threshold needs adjusting */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>mp_.no_dyn_threshold
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;&amp;</span> p<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">&gt;</span> mp_.mmap_threshold
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;&amp;</span> p<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">&lt;=</span> DEFAULT_MMAP_THRESHOLD_MAX)
</span></span></code></pre></div><ol start="6">
<li>设置mmap分配阈值等于chunk_size，top_chunk收缩阈值等于chunk_size*2</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    mp_.mmap_threshold <span style="color:#f92672">=</span> <span style="color:#a6e22e">chunksize</span> (p);
</span></span><span style="display:flex;"><span>    mp_.trim_threshold <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> mp_.mmap_threshold;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">LIBC_PROBE</span> (memory_mallopt_free_dyn_thresholds, <span style="color:#ae81ff">2</span>,
</span></span><span style="display:flex;"><span>        mp_.mmap_threshold, mp_.trim_threshold);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="7">
<li>执行munmap_chunk释放chunk，然后return</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">munmap_chunk</span> (p);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span>;
</span></span></code></pre></div><ol start="8">
<li>获得chunk的分配区，并执行_int_free函数</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>ar_ptr <span style="color:#f92672">=</span> <span style="color:#a6e22e">arena_for_chunk</span> (p);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">_int_free</span> (ar_ptr, p, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><h3 id="_int_free1分配区指针2chunk指针3分配区互斥锁">_int_free(1.分配区指针，2.chunk指针，3.分配区互斥锁)</h3>
<ul>
<li>errout:
<ol>
<li>判断 <strong>分配区是否被锁</strong> ，如果是则解锁分配区</li>
<li>打印错误字符串并 return</li>
</ol>
</li>
</ul>
<ol>
<li>获得chunk_size</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>size <span style="color:#f92672">=</span> <span style="color:#a6e22e">chunksize</span> (p);
</span></span></code></pre></div><ol start="2">
<li>判断 <strong>chunk指针是否大于-chunk_size(unsigned)或者chunk指针是否不关于MALOOC_ALIGN_MASK字节对齐</strong> 如果是则goto errout <strong>errstr = &ldquo;free(): invalid pointer&rdquo;</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">__builtin_expect</span> ((<span style="color:#66d9ef">uintptr_t</span>) p <span style="color:#f92672">&gt;</span> (<span style="color:#66d9ef">uintptr_t</span>) <span style="color:#f92672">-</span>size, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">||</span> <span style="color:#a6e22e">__builtin_expect</span> (<span style="color:#a6e22e">misaligned_chunk</span> (p), <span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    errstr <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;free(): invalid pointer&#34;</span>;
</span></span><span style="display:flex;"><span>errout:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>have_lock <span style="color:#f92672">&amp;&amp;</span> locked)
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">void</span>) <span style="color:#a6e22e">mutex_unlock</span> (<span style="color:#f92672">&amp;</span>av<span style="color:#f92672">-&gt;</span>mutex);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">malloc_printerr</span> (check_action, errstr, <span style="color:#a6e22e">chunk2mem</span> (p), av);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="3">
<li>判断 <strong>chunk_size是否小于MINSIZE或者chunk_size是否不关于MALOOC_ALIGN_MASK字节对齐</strong> 如果是则goto errout <strong>(errstr = &ldquo;free(): invalid size&rdquo;)</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">__glibc_unlikely</span> (size <span style="color:#f92672">&lt;</span> MINSIZE <span style="color:#f92672">||</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">aligned_OK</span> (size)))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    errstr <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;free(): invalid size&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> errout;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="4">
<li>(释放到fastbin) 判断 <strong>chunk_size是否小于等于global_max_fast</strong> 如果是则跳到5，否则跳到10</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> ((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)(size) <span style="color:#f92672">&lt;=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)(<span style="color:#a6e22e">get_max_fast</span> ())
</span></span></code></pre></div><ol start="5">
<li>分配区加锁，判断 <strong>分配区是否加锁或者next_chunk_size是否小于等于2*sizeof(INTERNAL_SIZE_T)或者next_chunk_size是否大于等于av-&gt;system_mem</strong> ，如果是则goto errout <strong>(errstr = &ldquo;free(): invalid next size (fast)&rdquo;</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (have_lock
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">||</span> ({ <span style="color:#a6e22e">assert</span> (locked <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mutex_lock</span>(<span style="color:#f92672">&amp;</span>av<span style="color:#f92672">-&gt;</span>mutex);
</span></span><span style="display:flex;"><span>        locked <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">chunk_at_offset</span> (p, size)<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> SIZE_SZ
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">||</span> <span style="color:#a6e22e">chunksize</span> (<span style="color:#a6e22e">chunk_at_offset</span> (p, size)) <span style="color:#f92672">&gt;=</span> av<span style="color:#f92672">-&gt;</span>system_mem;
</span></span><span style="display:flex;"><span>        }))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>errstr <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;free(): invalid next size (fast)&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">goto</span> errout;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="6">
<li>解锁分配区，设置分配区flag的has_fastbin比特位为1，根据chunk_size寻找对应fastbins的索引x，根据分配区和索引位置找到chunk对应的&amp;fastbin<input checked="" disabled="" type="checkbox"> </li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">set_fastchunks</span>(av);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#a6e22e">fastbin_index</span>(size);
</span></span><span style="display:flex;"><span>fb <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">fastbin</span> (av, idx);
</span></span></code></pre></div><ol start="7">
<li>判断 <strong>chunk是否等于fastbin<input checked="" disabled="" type="checkbox"> </strong> 如果是则goto errout <strong>(errstr = &ldquo;double free or corruption (fasttop)&rdquo;)</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">__builtin_expect</span> (old <span style="color:#f92672">==</span> p, <span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    errstr <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;double free or corruption (fasttop)&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> errout;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="8">
<li>获得fastbin<input checked="" disabled="" type="checkbox"> -&gt;size对应的fastbin索引y，将chunk插入fastbin头部</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>old_idx <span style="color:#f92672">=</span> <span style="color:#a6e22e">fastbin_index</span>(<span style="color:#a6e22e">chunksize</span>(old));
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">-&gt;</span>fd <span style="color:#f92672">=</span> old2 <span style="color:#f92672">=</span> old;
</span></span></code></pre></div><ol start="9">
<li>判断 <strong>分配区是否加锁且fastbin<input checked="" disabled="" type="checkbox"> 是否不为0且x与y是否不相同</strong> 如果是，则goto errout <strong>(errstr = &ldquo;invalid fastbin entry (free)&rdquo;</strong> 否则return</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (have_lock <span style="color:#f92672">&amp;&amp;</span> old <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">__builtin_expect</span> (old_idx <span style="color:#f92672">!=</span> idx, <span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    errstr <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;invalid fastbin entry (free)&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> errout;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="10">
<li>
<p>(释放到unsortedbin) 判断 <strong>chunk是否不是mmap函数分配的</strong> 如果是则跳到11，否则跳到27</p>
</li>
<li>
<p>分配区加锁</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">chunk_is_mmapped</span>(p)) {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span> have_lock) {
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">mutex_lock</span>(<span style="color:#f92672">&amp;</span>av<span style="color:#f92672">-&gt;</span>mutex);
</span></span><span style="display:flex;"><span>    locked <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="12">
<li>判断 <strong>chunk是否是top_chunk</strong> 如果是则goto errout <strong>(errstr = &ldquo;double free or corruption (top)&rdquo;</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>nextchunk <span style="color:#f92672">=</span> <span style="color:#a6e22e">chunk_at_offset</span>(p, size);
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Lightweight tests: check whether the block is already the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    top block.  */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">__glibc_unlikely</span> (p <span style="color:#f92672">==</span> av<span style="color:#f92672">-&gt;</span>top))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    errstr <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;double free or corruption (top)&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> errout;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="13">
<li>判断 <strong>分配区是否可以分配连续空间且next_chunk指针是否大于(top_chunk指针+top_chunk_size)</strong> 如果是则goto errout <strong>(errstr = &ldquo;double free or corruption (out)&rdquo;</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">__builtin_expect</span> (<span style="color:#a6e22e">contiguous</span> (av)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>) nextchunk
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&gt;=</span> ((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>) av<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">+</span> <span style="color:#a6e22e">chunksize</span>(av<span style="color:#f92672">-&gt;</span>top)), <span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    errstr <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;double free or corruption (out)&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> errout;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="14">
<li>判断 <strong>next_chunk的pre_inuse标志是否为0</strong> 如果是，则goto errout <strong>(errstr = &ldquo;double free or corruption (!prev)&rdquo;</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">__glibc_unlikely</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">prev_inuse</span>(nextchunk)))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    errstr <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;double free or corruption (!prev)&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> errout;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="15">
<li>判断 <strong>next_chunk_size是否小于2*sizeof(size_t)或者next_chunk_size是否大于av-&gt;system_mem</strong> 如果是则goto errout <strong>(errstr = &ldquo;free(): invalid next size (normal)&rdquo;</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>nextsize <span style="color:#f92672">=</span> <span style="color:#a6e22e">chunksize</span>(nextchunk);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">__builtin_expect</span> (nextchunk<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> SIZE_SZ, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">||</span> <span style="color:#a6e22e">__builtin_expect</span> (nextsize <span style="color:#f92672">&gt;=</span> av<span style="color:#f92672">-&gt;</span>system_mem, <span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    errstr <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;free(): invalid next size (normal)&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> errout;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="16">
<li>判断 <strong>pre_chunk是否是空闲的</strong> 如果是则使用unlink取出pre_chunk，使chunk等于pre_chunk</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">prev_inuse</span>(p)) {
</span></span><span style="display:flex;"><span>    prevsize <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>prev_size;
</span></span><span style="display:flex;"><span>    size <span style="color:#f92672">+=</span> prevsize;
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> <span style="color:#a6e22e">chunk_at_offset</span>(p, <span style="color:#f92672">-</span>((<span style="color:#66d9ef">long</span>) prevsize));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">unlink</span>(av, p, bck, fwd);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="17">
<li>
<p>判断 <strong>next_chunk是否等于top_chunk</strong> 如果是，则跳到22</p>
</li>
<li>
<p>判断 <strong>next_chunk是否是空闲的</strong> 如果是则使用unlink取出next_chunk,否则清空next_chunk的pre_inuse</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>nextinuse) {
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">unlink</span>(av, nextchunk, bck, fwd);
</span></span><span style="display:flex;"><span>size <span style="color:#f92672">+=</span> nextsize;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">clear_inuse_bit_at_offset</span>(nextchunk, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><ol start="19">
<li>
<p>获得unsorted_bin地址</p>
</li>
<li>
<p>判断 <strong>unsorted_bin-&gt;fd-&gt;bk是否不等于unsorted_bin</strong> 如果是，则goto errout <strong>(errstr = &ldquo;free(): corrupted unsorted chunks&rdquo;</strong></p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>bck <span style="color:#f92672">=</span> <span style="color:#a6e22e">unsorted_chunks</span>(av);
</span></span><span style="display:flex;"><span>fwd <span style="color:#f92672">=</span> bck<span style="color:#f92672">-&gt;</span>fd;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">__glibc_unlikely</span> (fwd<span style="color:#f92672">-&gt;</span>bk <span style="color:#f92672">!=</span> bck))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    errstr <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;free(): corrupted unsorted chunks&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> errout;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="21">
<li>
<p>将chunk插入unsortedbin(bk处),如果chunk_size不在small_bin范围则清空chunk的fd_nextsize和bk_nextsize区域，设置chunk的pre_inuse,size，跳到23</p>
</li>
<li>
<p>跳到此处说明，chunk与top_chunk相邻，top_chunk会合并当前chunk</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    size <span style="color:#f92672">+=</span> nextsize;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">set_head</span>(p, size <span style="color:#f92672">|</span> PREV_INUSE);
</span></span><span style="display:flex;"><span>    av<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">check_chunk</span>(av, p);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="23">
<li>判断 <strong>被释放的最终size是否大于FASTBIN_CONSOLIDATION_THRESHOLD(65536UL)</strong> 如果是则触发malloc_consolidate函数合并fastbin</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> ((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)(size) <span style="color:#f92672">&gt;=</span> FASTBIN_CONSOLIDATION_THRESHOLD) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">have_fastchunks</span>(av))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">malloc_consolidate</span>(av);
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="24">
<li>判断 <strong>分配区是否是main_arena</strong> 如果是则当top_chunk_size大于收缩阈值时，执行systrim函数，收缩top_chunk</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (av <span style="color:#f92672">==</span> <span style="color:#f92672">&amp;</span>main_arena) {
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifndef MORECORE_CANNOT_TRIM
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> ((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)(<span style="color:#a6e22e">chunksize</span>(av<span style="color:#f92672">-&gt;</span>top)) <span style="color:#f92672">&gt;=</span>
</span></span><span style="display:flex;"><span>	    (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)(mp_.trim_threshold))
</span></span><span style="display:flex;"><span>	  <span style="color:#a6e22e">systrim</span>(mp_.top_pad, av);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><ol start="25">
<li>如果不是则匹配top_chunk对应的子分配区，当子分配区与当前分配区相同时，执行heap_trim，尝试收缩top_chunk</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Always try heap_trim(), even if the top chunk is not
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    large, because the corresponding heap might go away.  */</span>
</span></span><span style="display:flex;"><span>    heap_info <span style="color:#f92672">*</span>heap <span style="color:#f92672">=</span> <span style="color:#a6e22e">heap_for_ptr</span>(<span style="color:#a6e22e">top</span>(av));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">assert</span>(heap<span style="color:#f92672">-&gt;</span>ar_ptr <span style="color:#f92672">==</span> av);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">heap_trim</span>(heap, mp_.top_pad);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="26">
<li>解锁分配区，然后return</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>(<span style="color:#66d9ef">void</span>)<span style="color:#a6e22e">mutex_unlock</span>(<span style="color:#f92672">&amp;</span>av<span style="color:#f92672">-&gt;</span>mutex);
</span></span></code></pre></div><ol start="27">
<li>(通过munmap释放chunk) 执行munmap_chunk释放chunk</li>
</ol>
</section>

  
  

  
  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    <a
      class="flex w-1/2 items-center rounded-l-md p-6 pr-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]"
      href="https://povcfe.github.io/post/kernel_rop1/"
      ><span class="mr-1.5">←</span><span>linux 内核提权总结(demo&#43;exp分析) -- ROP(一)</span></a
    >
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]"
      href="https://povcfe.github.io/post/pwn/"
      ><span>Pwn思维导图</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  
  

  
  

  
  

  


  
</article>


    </main>

    <footer
  class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"
>
  <div class="mr-auto">
    &copy; 2024
    <a class="link" href="https://povcfe.github.io/">povcfe&#39;s site</a>
  </div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank"
    >Powered by Hugo️️</a
  >️
  <a
    class="link"
    href="https://github.com/nanxiaobei/hugo-paper"
    rel="noopener"
    target="_blank"
    >✎ Paper</a
  >
</footer>

  </body>
</html>
