<!doctype html>









































<html
  class="not-ready lg:text-base"
  style="--bg: #faf8f1"
  lang="en-us"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>linux内核(5.4.81)---网络模块源码分析 - povcfe&#39;s site</title>

  
  <meta name="theme-color" />

  
  
  
  
  <meta name="description" content="发表于安全客
1. socket 1.1 sock_create 1.1.1 sock_alloc 1.1.2 inet_create 1.1.2.1 sk_alloc 1.2 sock_map_fd 2. send(运输层) 2.1 import_single_range 2.2 sockfd_lookup_light 2.3 sock_sendmsg 2.4 udp_sendmsg 2.4.1 udp_cmsg_send 2.4.2 TOS 2.4.3 多播/本地广播 2.4.4 检查sock中路由信息是否过期 2.4.5 udp_send_skb 2.4.6 udp_push_pending_frames 3. recv(运输层) 2.1 udp_recvmsg 2.1.1 __skb_recv_udp 2.1.1.1 __skb_try_recv_from_queue 4. IP(网络层) 4.1 ip_cmsg_send 4.2 ip_make_skb 4.2.1 ip_setup_cork 4.2.2 __ip_make_skb 4.3 ip_append_data 4.3.1 __ip_append_data 4.4 ip_send_skb 4.4.1 __ip_local_out 1. socket SOCK_CLOEXEC 和 SOCK_NONBLOCK是2.6.27版本后增加的sock类型:
SOCK_CLOEXEC 借助文件描述符FD_CLOEXEC 实现子进程运行exec后关闭sock_fd机制
SOCK_NONBLOCK 借助文件描述符O_NONBLOCK 实现非阻塞IO通信" />
  <meta name="author" content="povcfe" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://povcfe.github.io/main.min.css" />

  
  
  
  
  
  <link rel="preload" as="image" href="https://povcfe.github.io/theme.png" />

  
  
  
  
  <link rel="preload" as="image" href="https://povcfe.github.io/avatar.jpg" />
  
  

  
  
  <link rel="preload" as="image" href="https://povcfe.github.io/twitter.svg" />
  
  <link rel="preload" as="image" href="https://povcfe.github.io/github.svg" />
  
  <link rel="preload" as="image" href="https://povcfe.github.io/rss.svg" />
  
  

  
  
  <script
    defer
    src="https://povcfe.github.io/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
  
  

  
  <link rel="icon" href="https://povcfe.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://povcfe.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.111.3">

  
  
  
  
  
  <meta itemprop="name" content="linux内核(5.4.81)---网络模块源码分析">
<meta itemprop="description" content="发表于安全客
1. socket 1.1 sock_create 1.1.1 sock_alloc 1.1.2 inet_create 1.1.2.1 sk_alloc 1.2 sock_map_fd 2. send(运输层) 2.1 import_single_range 2.2 sockfd_lookup_light 2.3 sock_sendmsg 2.4 udp_sendmsg 2.4.1 udp_cmsg_send 2.4.2 TOS 2.4.3 多播/本地广播 2.4.4 检查sock中路由信息是否过期 2.4.5 udp_send_skb 2.4.6 udp_push_pending_frames 3. recv(运输层) 2.1 udp_recvmsg 2.1.1 __skb_recv_udp 2.1.1.1 __skb_try_recv_from_queue 4. IP(网络层) 4.1 ip_cmsg_send 4.2 ip_make_skb 4.2.1 ip_setup_cork 4.2.2 __ip_make_skb 4.3 ip_append_data 4.3.1 __ip_append_data 4.4 ip_send_skb 4.4.1 __ip_local_out 1. socket SOCK_CLOEXEC 和 SOCK_NONBLOCK是2.6.27版本后增加的sock类型:
SOCK_CLOEXEC 借助文件描述符FD_CLOEXEC 实现子进程运行exec后关闭sock_fd机制
SOCK_NONBLOCK 借助文件描述符O_NONBLOCK 实现非阻塞IO通信"><meta itemprop="datePublished" content="2021-03-28T00:00:00-04:00" />
<meta itemprop="dateModified" content="2021-03-28T00:00:00-04:00" />
<meta itemprop="wordCount" content="6103">
<meta itemprop="keywords" content="" />
  
  <meta property="og:title" content="linux内核(5.4.81)---网络模块源码分析" />
<meta property="og:description" content="发表于安全客
1. socket 1.1 sock_create 1.1.1 sock_alloc 1.1.2 inet_create 1.1.2.1 sk_alloc 1.2 sock_map_fd 2. send(运输层) 2.1 import_single_range 2.2 sockfd_lookup_light 2.3 sock_sendmsg 2.4 udp_sendmsg 2.4.1 udp_cmsg_send 2.4.2 TOS 2.4.3 多播/本地广播 2.4.4 检查sock中路由信息是否过期 2.4.5 udp_send_skb 2.4.6 udp_push_pending_frames 3. recv(运输层) 2.1 udp_recvmsg 2.1.1 __skb_recv_udp 2.1.1.1 __skb_try_recv_from_queue 4. IP(网络层) 4.1 ip_cmsg_send 4.2 ip_make_skb 4.2.1 ip_setup_cork 4.2.2 __ip_make_skb 4.3 ip_append_data 4.3.1 __ip_append_data 4.4 ip_send_skb 4.4.1 __ip_local_out 1. socket SOCK_CLOEXEC 和 SOCK_NONBLOCK是2.6.27版本后增加的sock类型:
SOCK_CLOEXEC 借助文件描述符FD_CLOEXEC 实现子进程运行exec后关闭sock_fd机制
SOCK_NONBLOCK 借助文件描述符O_NONBLOCK 实现非阻塞IO通信" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://povcfe.github.io/post/kernel_net/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-03-28T00:00:00-04:00" />
<meta property="article:modified_time" content="2021-03-28T00:00:00-04:00" />

  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="linux内核(5.4.81)---网络模块源码分析"/>
<meta name="twitter:description" content="发表于安全客
1. socket 1.1 sock_create 1.1.1 sock_alloc 1.1.2 inet_create 1.1.2.1 sk_alloc 1.2 sock_map_fd 2. send(运输层) 2.1 import_single_range 2.2 sockfd_lookup_light 2.3 sock_sendmsg 2.4 udp_sendmsg 2.4.1 udp_cmsg_send 2.4.2 TOS 2.4.3 多播/本地广播 2.4.4 检查sock中路由信息是否过期 2.4.5 udp_send_skb 2.4.6 udp_push_pending_frames 3. recv(运输层) 2.1 udp_recvmsg 2.1.1 __skb_recv_udp 2.1.1.1 __skb_try_recv_from_queue 4. IP(网络层) 4.1 ip_cmsg_send 4.2 ip_make_skb 4.2.1 ip_setup_cork 4.2.2 __ip_make_skb 4.3 ip_append_data 4.3.1 __ip_append_data 4.4 ip_send_skb 4.4.1 __ip_local_out 1. socket SOCK_CLOEXEC 和 SOCK_NONBLOCK是2.6.27版本后增加的sock类型:
SOCK_CLOEXEC 借助文件描述符FD_CLOEXEC 实现子进程运行exec后关闭sock_fd机制
SOCK_NONBLOCK 借助文件描述符O_NONBLOCK 实现非阻塞IO通信"/>

  
  
  
  <link rel="canonical" href="https://povcfe.github.io/post/kernel_net/" />
  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center">
  <div class="relative z-50 mr-auto flex items-center">
    <a
      class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold"
      href="https://povcfe.github.io/"
      >povcfe&#39;s site</a
    >
    <div
      class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]"
      role="button"
      aria-label="Dark"
    ></div>
  </div>

  <div
    class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
    role="button"
    aria-label="Menu"
  ></div>

  

  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = '#faf8f1'.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"
    >
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./twitter.svg)"
        href="https://twitter.com/povcfe"
        target="_blank"
        rel="me"
      >
        twitter
      </a>
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href="https://github.com/povcfe"
        target="_blank"
        rel="me"
      >
        github
      </a>
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./rss.svg)"
        href="https://povcfe.github.io/index.xml"
        target="_blank"
        rel="alternate"
      >
        rss
      </a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"
    >
      

<article>
  <header class="mb-16">
    <h1 class="!my-0 pb-2.5">linux内核(5.4.81)---网络模块源码分析</h1>

    
    <div class="text-sm antialiased opacity-60">
      
      <time>Mar 28, 2021</time>
      
      
      
      
    </div>
    
  </header>

  <section><p>发表于<a href="https://www.anquanke.com/post/id/243044">安全客</a></p>
<ul>
<li><a href="#socket">1. socket</a>
<ul>
<li><a href="#sock_create">1.1 sock_create</a></li>
<li><a href="#sock_alloc">1.1.1 sock_alloc</a></li>
<li><a href="#inet_create">1.1.2 inet_create</a></li>
<li><a href="#sk_alloc">1.1.2.1 sk_alloc</a></li>
<li><a href="#sock_map_fd">1.2 sock_map_fd</a></li>
</ul>
</li>
<li><a href="#send">2. send(运输层)</a>
<ul>
<li><a href="#import_single_range">2.1 import_single_range</a></li>
<li><a href="#sockfd_lookup_light">2.2 sockfd_lookup_light</a></li>
<li><a href="#sock_sendmsg">2.3 sock_sendmsg</a></li>
<li><a href="#udp_sendmsg">2.4 udp_sendmsg</a></li>
<li><a href="#udp_cmsg_send">2.4.1 udp_cmsg_send</a></li>
<li><a href="#TOS">2.4.2 TOS</a></li>
<li><a href="#">2.4.3 多播/本地广播</a></li>
<li><a href="#sock">2.4.4 检查sock中路由信息是否过期</a></li>
<li><a href="#udp_send_skb">2.4.5 udp_send_skb</a></li>
<li><a href="#udp_push_pending_frames">2.4.6 udp_push_pending_frames</a></li>
</ul>
</li>
<li><a href="#recv">3. recv(运输层)</a>
<ul>
<li><a href="#udp_recvmsg">2.1 udp_recvmsg</a></li>
<li><a href="#skb_recv_udp">2.1.1 __skb_recv_udp</a></li>
<li><a href="#skb_try_recv_from_queue">2.1.1.1 __skb_try_recv_from_queue</a></li>
</ul>
</li>
<li><a href="#IP">4. IP(网络层)</a>
<ul>
<li><a href="#ip_cmsg_send">4.1 ip_cmsg_send</a></li>
<li><a href="#ip_make_skb">4.2 ip_make_skb</a></li>
<li><a href="#ip_setup_cork">4.2.1 ip_setup_cork</a></li>
<li><a href="#ip_make_skb-1">4.2.2 __ip_make_skb</a></li>
<li><a href="#ip_append_data">4.3 ip_append_data</a></li>
<li><a href="#ip_append_data-1">4.3.1 __ip_append_data</a></li>
<li><a href="#ip_send_skb">4.4 ip_send_skb</a></li>
<li><a href="#ip_local_out">4.4.1 __ip_local_out</a></li>
</ul>
</li>
</ul>
<h2 id="1-socket">1. socket</h2>
<ul>
<li>
<p>SOCK_CLOEXEC 和 SOCK_NONBLOCK是2.6.27版本后增加的sock类型:</p>
<ul>
<li>
<p>SOCK_CLOEXEC 借助文件描述符FD_CLOEXEC 实现子进程运行exec后关闭sock_fd机制</p>
</li>
<li>
<p>SOCK_NONBLOCK 借助文件描述符O_NONBLOCK 实现非阻塞IO通信</p>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">__sys_socket</span>(<span style="color:#66d9ef">int</span> family, <span style="color:#66d9ef">int</span> type, <span style="color:#66d9ef">int</span> protocol)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> retval;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> socket <span style="color:#f92672">*</span>sock;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> flags;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Check the SOCK_* constants for consistency.  */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">BUILD_BUG_ON</span>(SOCK_CLOEXEC <span style="color:#f92672">!=</span> O_CLOEXEC);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">BUILD_BUG_ON</span>((SOCK_MAX <span style="color:#f92672">|</span> SOCK_TYPE_MASK) <span style="color:#f92672">!=</span> SOCK_TYPE_MASK);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">BUILD_BUG_ON</span>(SOCK_CLOEXEC <span style="color:#f92672">&amp;</span> SOCK_TYPE_MASK);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">BUILD_BUG_ON</span>(SOCK_NONBLOCK <span style="color:#f92672">&amp;</span> SOCK_TYPE_MASK);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果flags除SOCK_CLOEXEC/SOCK_NONBLOCK掩码外不存在其他flag标志, 直接返回错误码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	flags <span style="color:#f92672">=</span> type <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>SOCK_TYPE_MASK;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (flags <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>(SOCK_CLOEXEC <span style="color:#f92672">|</span> SOCK_NONBLOCK))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>	type <span style="color:#f92672">&amp;=</span> SOCK_TYPE_MASK;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 因为SOCK_NONBLOCK实现的本质是借助O_NONBLOCK, 所以二者内容矛盾时, 使用O_NONBLOCK替换SOCK_NONBLOCK
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (SOCK_NONBLOCK <span style="color:#f92672">!=</span> O_NONBLOCK <span style="color:#f92672">&amp;&amp;</span> (flags <span style="color:#f92672">&amp;</span> SOCK_NONBLOCK))
</span></span><span style="display:flex;"><span>		flags <span style="color:#f92672">=</span> (flags <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>SOCK_NONBLOCK) <span style="color:#f92672">|</span> O_NONBLOCK;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建socket, 详细见1.1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	retval <span style="color:#f92672">=</span> <span style="color:#a6e22e">sock_create</span>(family, type, protocol, <span style="color:#f92672">&amp;</span>sock);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (retval <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> retval;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将fd, file, socket互相绑定, 详细见1.2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sock_map_fd</span>(sock, flags <span style="color:#f92672">&amp;</span> (O_CLOEXEC <span style="color:#f92672">|</span> O_NONBLOCK));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="11-sock_create">1.1 sock_create</h3>
<blockquote>
<p>sock_create</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sock_create</span>(<span style="color:#66d9ef">int</span> family, <span style="color:#66d9ef">int</span> type, <span style="color:#66d9ef">int</span> protocol, <span style="color:#66d9ef">struct</span> socket <span style="color:#f92672">**</span>res)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">__sock_create</span>(current<span style="color:#f92672">-&gt;</span>nsproxy<span style="color:#f92672">-&gt;</span>net_ns, family, type, protocol, res, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>__sock_create</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">__sock_create</span>(<span style="color:#66d9ef">struct</span> net <span style="color:#f92672">*</span>net, <span style="color:#66d9ef">int</span> family, <span style="color:#66d9ef">int</span> type, <span style="color:#66d9ef">int</span> protocol,
</span></span><span style="display:flex;"><span>			 <span style="color:#66d9ef">struct</span> socket <span style="color:#f92672">**</span>res, <span style="color:#66d9ef">int</span> kern)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> err;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> socket <span style="color:#f92672">*</span>sock;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> net_proto_family <span style="color:#f92672">*</span>pf;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *      Check protocol is in range
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 检查协议族是否超出范围
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (family <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> family <span style="color:#f92672">&gt;=</span> NPROTO)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EAFNOSUPPORT;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 检查socket类型是否超出范围
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (type <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> type <span style="color:#f92672">&gt;=</span> SOCK_MAX)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Compatibility.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	   This uglymoron is moved from INET layer to here to avoid
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	   deadlock in module load.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// SOCK_PACKET被从PF_INET族移入PF_PACKET
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (family <span style="color:#f92672">==</span> PF_INET <span style="color:#f92672">&amp;&amp;</span> type <span style="color:#f92672">==</span> SOCK_PACKET) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">pr_info_once</span>(<span style="color:#e6db74">&#34;%s uses obsolete (PF_INET,SOCK_PACKET)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>			     current<span style="color:#f92672">-&gt;</span>comm);
</span></span><span style="display:flex;"><span>		family <span style="color:#f92672">=</span> PF_PACKET;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 用来适配LSM(linux security module):LSM是一种安全框架，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 将钩子安插在内核的关键函数上, 通过钩子上存储函数指针链表调用安全检查函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 用以在不修改内核代码的前提下, 为内核安装安全模块。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 理论上讲不同的安全模块可以被同时安装到内核中, 钩子函数会依次执行对应的安全检查函数。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	err <span style="color:#f92672">=</span> <span style="color:#a6e22e">security_socket_create</span>(family, type, protocol, kern);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (err)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> err;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *	Allocate the socket and allow the family to set things up. if
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *	the protocol is 0, the family is instructed to select an appropriate
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *	default.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建socket, 详细见1.1.1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	sock <span style="color:#f92672">=</span> <span style="color:#a6e22e">sock_alloc</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>sock) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">net_warn_ratelimited</span>(<span style="color:#e6db74">&#34;socket: no more sockets</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENFILE;	<span style="color:#75715e">/* Not exactly a match, but its the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">				   closest posix thing */</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 为socket-&gt;type填充socket类型信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	sock<span style="color:#f92672">-&gt;</span>type <span style="color:#f92672">=</span> type;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_MODULES
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">/* Attempt to load a protocol module if the find failed.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * 12/09/1996 Marcin: But! this makes REALLY only sense, if the user
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * requested real, full-featured networking support upon configuration.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Otherwise module support will break!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果协议族内容不存在, 则试图加载驱动(内核执行用户指令modprobe加载驱动)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">rcu_access_pointer</span>(net_families[family]) <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">request_module</span>(<span style="color:#e6db74">&#34;net-pf-%d&#34;</span>, family);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 进入rcu_read区域, 有关rcu的扩展可以看这篇文章 [RCU简介](https://zhuanlan.zhihu.com/p/113999842)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">rcu_read_lock</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 获得协议族信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	pf <span style="color:#f92672">=</span> <span style="color:#a6e22e">rcu_dereference</span>(net_families[family]);
</span></span><span style="display:flex;"><span>	err <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EAFNOSUPPORT;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>pf)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> out_release;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * We will call the -&gt;create function, that possibly is in a loadable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * module, so we have to bump that loadable module refcnt first.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 检查协议族对应的模块是否被加载&amp;增加模块的引用数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">try_module_get</span>(pf<span style="color:#f92672">-&gt;</span>owner))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> out_release;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Now protected by module ref count */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">rcu_read_unlock</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 在udp中调用inet_create创建sock, 详细见1.1.2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	err <span style="color:#f92672">=</span> pf<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">create</span>(net, sock, protocol, kern);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (err <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> out_module_put;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Now to bump the refcnt of the [loadable] module that owns this
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * socket at sock_release time we decrement its refcnt.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 用户需要使用sock-&gt;ops, 所以他对应的模块必须在内存中加载
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">try_module_get</span>(sock<span style="color:#f92672">-&gt;</span>ops<span style="color:#f92672">-&gt;</span>owner))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> out_module_busy;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Now that we&#39;re done with the -&gt;create function, the [loadable]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * module can have its refcnt decremented
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// pf-&gt;create函数调用完毕, 协议族对应的可加载模板引用数-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">module_put</span>(pf<span style="color:#f92672">-&gt;</span>owner);
</span></span><span style="display:flex;"><span>	err <span style="color:#f92672">=</span> <span style="color:#a6e22e">security_socket_post_create</span>(sock, family, type, protocol, kern);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (err)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> out_sock_release;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>res <span style="color:#f92672">=</span> sock;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>out_module_busy:
</span></span><span style="display:flex;"><span>	err <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EAFNOSUPPORT;
</span></span><span style="display:flex;"><span>out_module_put:
</span></span><span style="display:flex;"><span>	sock<span style="color:#f92672">-&gt;</span>ops <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">module_put</span>(pf<span style="color:#f92672">-&gt;</span>owner);
</span></span><span style="display:flex;"><span>out_sock_release:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sock_release</span>(sock);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> err;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>out_release:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">rcu_read_unlock</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">goto</span> out_sock_release;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="111-sock_alloc">1.1.1 sock_alloc</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> socket <span style="color:#f92672">*</span><span style="color:#a6e22e">sock_alloc</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> inode <span style="color:#f92672">*</span>inode;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> socket <span style="color:#f92672">*</span>sock;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 创建inode文件索引结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// alloc inode时, 会分配sizeof(struct socket_alloc) 大小空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	inode <span style="color:#f92672">=</span> <span style="color:#a6e22e">new_inode_pseudo</span>(sock_mnt<span style="color:#f92672">-&gt;</span>mnt_sb);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>inode)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 依据vfs_inode在struct socket_alloc中的偏移定位socket_alloc地址, 然后定位socket 成员位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	struct socket_alloc {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		struct socket socket;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		struct inode vfs_inode;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	};
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	static inline struct socket *SOCKET_I(struct inode *inode)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		return &amp;container_of(inode, struct socket_alloc, vfs_inode)-&gt;socket;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	*/</span>
</span></span><span style="display:flex;"><span>	sock <span style="color:#f92672">=</span> <span style="color:#a6e22e">SOCKET_I</span>(inode);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 填充inode属性, 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	inode<span style="color:#f92672">-&gt;</span>i_ino <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_next_ino</span>();
</span></span><span style="display:flex;"><span>	inode<span style="color:#f92672">-&gt;</span>i_mode <span style="color:#f92672">=</span> S_IFSOCK <span style="color:#f92672">|</span> S_IRWXUGO;
</span></span><span style="display:flex;"><span>	inode<span style="color:#f92672">-&gt;</span>i_uid <span style="color:#f92672">=</span> <span style="color:#a6e22e">current_fsuid</span>();
</span></span><span style="display:flex;"><span>	inode<span style="color:#f92672">-&gt;</span>i_gid <span style="color:#f92672">=</span> <span style="color:#a6e22e">current_fsgid</span>();
</span></span><span style="display:flex;"><span>	inode<span style="color:#f92672">-&gt;</span>i_op <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>sockfs_inode_ops;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> sock;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="112-inet_create">1.1.2 inet_create</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">inet_create</span>(<span style="color:#66d9ef">struct</span> net <span style="color:#f92672">*</span>net, <span style="color:#66d9ef">struct</span> socket <span style="color:#f92672">*</span>sock, <span style="color:#66d9ef">int</span> protocol,
</span></span><span style="display:flex;"><span>		       <span style="color:#66d9ef">int</span> kern)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sock <span style="color:#f92672">*</span>sk;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> inet_protosw <span style="color:#f92672">*</span>answer;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> inet_sock <span style="color:#f92672">*</span>inet;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> proto <span style="color:#f92672">*</span>answer_prot;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> answer_flags;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> try_loading_module <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> err;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 检查协议是否超出范围
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (protocol <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> protocol <span style="color:#f92672">&gt;=</span> IPPROTO_MAX)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 设置socket为无连接状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	sock<span style="color:#f92672">-&gt;</span>state <span style="color:#f92672">=</span> SS_UNCONNECTED;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Look for the requested type/protocol pair. */</span>
</span></span><span style="display:flex;"><span>lookup_protocol:
</span></span><span style="display:flex;"><span>	err <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>ESOCKTNOSUPPORT;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">rcu_read_lock</span>();
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 此宏定义使用了RCU机制, 大致功能为遍历 &amp;inetsw[sock-&gt;type] 链表, 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 同时返回链表的next指针, 认为该指针是struct inet_protosw中的list成员, 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 根据相对偏移, 定位此链表指针对应的结构体首地址, 赋值给answer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 遍历对应sock-&gt;type的inetsw链表, 查找协议族中与socket类型相对应的网络层协议信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// IPPROTO_IP表示用户不指定协议, 使用默认协议
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">list_for_each_entry_rcu</span>(answer, <span style="color:#f92672">&amp;</span>inetsw[sock<span style="color:#f92672">-&gt;</span>type], list) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		err <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* Check the non-wild match. */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果遍历获得与用户指定协议相同的网络协议(IPPROTO_IP除外), 成功退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (protocol <span style="color:#f92672">==</span> answer<span style="color:#f92672">-&gt;</span>protocol) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (protocol <span style="color:#f92672">!=</span> IPPROTO_IP)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">/* Check for the two wild cases. */</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 用户指定IPPROTO_IP后, 使用默认协议
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (IPPROTO_IP <span style="color:#f92672">==</span> protocol) {
</span></span><span style="display:flex;"><span>				protocol <span style="color:#f92672">=</span> answer<span style="color:#f92672">-&gt;</span>protocol;
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 遍历获得的协议必须非IPPROTO_IP(即必须指定确定协议)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (IPPROTO_IP <span style="color:#f92672">==</span> answer<span style="color:#f92672">-&gt;</span>protocol)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		err <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EPROTONOSUPPORT;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 为了解决上诉错误, 此处决定尝试加载驱动(最多尝试两次)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(err)) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (try_loading_module <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">rcu_read_unlock</span>();
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 * Be more specific, e.g. net-pf-2-proto-132-type-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 * (net-pf-PF_INET-proto-IPPROTO_SCTP-type-SOCK_STREAM)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 */</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">++</span>try_loading_module <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">request_module</span>(<span style="color:#e6db74">&#34;net-pf-%d-proto-%d-type-%d&#34;</span>,
</span></span><span style="display:flex;"><span>					       PF_INET, protocol, sock<span style="color:#f92672">-&gt;</span>type);
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 * Fall back to generic, e.g. net-pf-2-proto-132
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 * (net-pf-PF_INET-proto-IPPROTO_SCTP)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 */</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">request_module</span>(<span style="color:#e6db74">&#34;net-pf-%d-proto-%d&#34;</span>,
</span></span><span style="display:flex;"><span>					       PF_INET, protocol);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> lookup_protocol;
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> out_rcu_unlock;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	err <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EPERM;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 调用SOCK_RAW, 需要验证权限
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (sock<span style="color:#f92672">-&gt;</span>type <span style="color:#f92672">==</span> SOCK_RAW <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>kern <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#f92672">!</span><span style="color:#a6e22e">ns_capable</span>(net<span style="color:#f92672">-&gt;</span>user_ns, CAP_NET_RAW))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> out_rcu_unlock;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	sock<span style="color:#f92672">-&gt;</span>ops <span style="color:#f92672">=</span> answer<span style="color:#f92672">-&gt;</span>ops;
</span></span><span style="display:flex;"><span>	answer_prot <span style="color:#f92672">=</span> answer<span style="color:#f92672">-&gt;</span>prot;
</span></span><span style="display:flex;"><span>	answer_flags <span style="color:#f92672">=</span> answer<span style="color:#f92672">-&gt;</span>flags;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">rcu_read_unlock</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">WARN_ON</span>(<span style="color:#f92672">!</span>answer_prot<span style="color:#f92672">-&gt;</span>slab);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	err <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>ENOBUFS;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// sk_alloc 创建sock(真实大小: sizeof(struct xxx_sock). 比如udp对应udp_sock), 详细见1.1.2.1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	sk <span style="color:#f92672">=</span> <span style="color:#a6e22e">sk_alloc</span>(net, PF_INET, GFP_KERNEL, answer_prot, kern);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>sk)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> out;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	err <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (INET_PROTOSW_REUSE <span style="color:#f92672">&amp;</span> answer_flags)
</span></span><span style="display:flex;"><span>		sk<span style="color:#f92672">-&gt;</span>sk_reuse <span style="color:#f92672">=</span> SK_CAN_REUSE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 将sock转化为inet_sock(包含sock成员)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	inet <span style="color:#f92672">=</span> <span style="color:#a6e22e">inet_sk</span>(sk);
</span></span><span style="display:flex;"><span>	inet<span style="color:#f92672">-&gt;</span>is_icsk <span style="color:#f92672">=</span> (INET_PROTOSW_ICSK <span style="color:#f92672">&amp;</span> answer_flags) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	inet<span style="color:#f92672">-&gt;</span>nodefrag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 检查配置确定是否开启动态mtu探测
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (net<span style="color:#f92672">-&gt;</span>ipv4.sysctl_ip_no_pmtu_disc)
</span></span><span style="display:flex;"><span>		inet<span style="color:#f92672">-&gt;</span>pmtudisc <span style="color:#f92672">=</span> IP_PMTUDISC_DONT;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		inet<span style="color:#f92672">-&gt;</span>pmtudisc <span style="color:#f92672">=</span> IP_PMTUDISC_WANT;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	inet<span style="color:#f92672">-&gt;</span>inet_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// socket与sock相互绑定
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sock_init_data</span>(sock, sk);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 初始化sock与inet属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	sk<span style="color:#f92672">-&gt;</span>sk_destruct	   <span style="color:#f92672">=</span> inet_sock_destruct;
</span></span><span style="display:flex;"><span>	sk<span style="color:#f92672">-&gt;</span>sk_protocol	   <span style="color:#f92672">=</span> protocol;
</span></span><span style="display:flex;"><span>	sk<span style="color:#f92672">-&gt;</span>sk_backlog_rcv <span style="color:#f92672">=</span> sk<span style="color:#f92672">-&gt;</span>sk_prot<span style="color:#f92672">-&gt;</span>backlog_rcv;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	inet<span style="color:#f92672">-&gt;</span>uc_ttl	<span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	inet<span style="color:#f92672">-&gt;</span>mc_loop	<span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	inet<span style="color:#f92672">-&gt;</span>mc_ttl	<span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	inet<span style="color:#f92672">-&gt;</span>mc_all	<span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	inet<span style="color:#f92672">-&gt;</span>mc_index	<span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	inet<span style="color:#f92672">-&gt;</span>mc_list	<span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	inet<span style="color:#f92672">-&gt;</span>rcv_tos	<span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>out:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> err;
</span></span><span style="display:flex;"><span>out_rcu_unlock:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">rcu_read_unlock</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">goto</span> out;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="1121-sk_alloc">1.1.2.1 sk_alloc</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> sock <span style="color:#f92672">*</span><span style="color:#a6e22e">sk_alloc</span>(<span style="color:#66d9ef">struct</span> net <span style="color:#f92672">*</span>net, <span style="color:#66d9ef">int</span> family, <span style="color:#66d9ef">gfp_t</span> priority,
</span></span><span style="display:flex;"><span>		      <span style="color:#66d9ef">struct</span> proto <span style="color:#f92672">*</span>prot, <span style="color:#66d9ef">int</span> kern)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sock <span style="color:#f92672">*</span>sk;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果协议族存在slab则使用kmem_cache_alloc(slab, priority &amp; ~__GFP_ZERO); 分配内存(不使用内核通用的slab, 可预防内存攻击)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果协议族slab为空, 使用kmalloc分配内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	sk <span style="color:#f92672">=</span> <span style="color:#a6e22e">sk_prot_alloc</span>(prot, priority <span style="color:#f92672">|</span> __GFP_ZERO, family);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (sk) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 指定sock协议族
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		sk<span style="color:#f92672">-&gt;</span>sk_family <span style="color:#f92672">=</span> family;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * See comment in struct sock definition to understand
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * why we need sk_prot_creator -acme
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 */</span>
</span></span><span style="display:flex;"><span>		sk<span style="color:#f92672">-&gt;</span>sk_prot <span style="color:#f92672">=</span> sk<span style="color:#f92672">-&gt;</span>sk_prot_creator <span style="color:#f92672">=</span> prot;
</span></span><span style="display:flex;"><span>		sk<span style="color:#f92672">-&gt;</span>sk_kern_sock <span style="color:#f92672">=</span> kern;
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">sock_lock_init</span>(sk);
</span></span><span style="display:flex;"><span>		sk<span style="color:#f92672">-&gt;</span>sk_net_refcnt <span style="color:#f92672">=</span> kern <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(sk<span style="color:#f92672">-&gt;</span>sk_net_refcnt)) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">get_net</span>(net);
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">sock_inuse_add</span>(net, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 将sock与net相互绑定
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">sock_net_set</span>(sk, net);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">refcount_set</span>(<span style="color:#f92672">&amp;</span>sk<span style="color:#f92672">-&gt;</span>sk_wmem_alloc, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> sk;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="12-sock_map_fd">1.2 sock_map_fd</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sock_map_fd</span>(<span style="color:#66d9ef">struct</span> socket <span style="color:#f92672">*</span>sock, <span style="color:#66d9ef">int</span> flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>newfile;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 获得空闲fd
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> fd <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_unused_fd_flags</span>(flags);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(fd <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 失败后释放socket
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">sock_release</span>(sock);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> fd;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 创建file对象 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 调用alloc_file_pseudo, 以socket对应的inode为基础创建file对象,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// socket文件功能函数替换原生功能函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	file与socket相互绑定
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	sock-&gt;file = file;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	file-&gt;private_data = sock;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	*/</span>
</span></span><span style="display:flex;"><span>	newfile <span style="color:#f92672">=</span> <span style="color:#a6e22e">sock_alloc_file</span>(sock, flags, NULL);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">IS_ERR</span>(newfile)) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// fd与file相互绑定
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">fd_install</span>(fd, newfile);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> fd;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">put_unused_fd</span>(fd);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">PTR_ERR</span>(newfile);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="2-send运输层">2. send(运输层)</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">__sys_sendto</span>(<span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>buff, <span style="color:#66d9ef">size_t</span> len, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> flags,
</span></span><span style="display:flex;"><span>		 <span style="color:#66d9ef">struct</span> sockaddr __user <span style="color:#f92672">*</span>addr,  <span style="color:#66d9ef">int</span> addr_len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> socket <span style="color:#f92672">*</span>sock;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sockaddr_storage address;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> err;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> msghdr msg;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> iovec iov;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> fput_needed;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 将待传输数据地址(判断该地址是否为用户态地址)和长度填充进入iov结构体, 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 使用uaccess_kernel()判断当前系统调用可访问空间是否为全部空间(KERNEL_DS), 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 由此决定使用 msg.msg_iter-&gt;kvec/msg.msg_iter-&gt;iov保存用户数据信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 详细见2.1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	err <span style="color:#f92672">=</span> <span style="color:#a6e22e">import_single_range</span>(WRITE, buff, len, <span style="color:#f92672">&amp;</span>iov, <span style="color:#f92672">&amp;</span>msg.msg_iter);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(err))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> err;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 通过fd获得struct fd, struct fd间接引用file, 然后通过file-&gt;private_data获得socket
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 详细见2.2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	sock <span style="color:#f92672">=</span> <span style="color:#a6e22e">sockfd_lookup_light</span>(fd, <span style="color:#f92672">&amp;</span>err, <span style="color:#f92672">&amp;</span>fput_needed);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>sock)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> out;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	msg.msg_name <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	msg.msg_control <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	msg.msg_controllen <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	msg.msg_namelen <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (addr) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 使用copy_from_user将用户空间存储的目标地址复制到内核,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 期间会判断目标地址长度是否大于 sizeof(struct sockaddr_storage)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		err <span style="color:#f92672">=</span> <span style="color:#a6e22e">move_addr_to_kernel</span>(addr, addr_len, <span style="color:#f92672">&amp;</span>address);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (err <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> out_put;
</span></span><span style="display:flex;"><span>		msg.msg_name <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> sockaddr <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>address;
</span></span><span style="display:flex;"><span>		msg.msg_namelen <span style="color:#f92672">=</span> addr_len;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 设置非阻塞IO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (sock<span style="color:#f92672">-&gt;</span>file<span style="color:#f92672">-&gt;</span>f_flags <span style="color:#f92672">&amp;</span> O_NONBLOCK)
</span></span><span style="display:flex;"><span>		flags <span style="color:#f92672">|=</span> MSG_DONTWAIT;
</span></span><span style="display:flex;"><span>	msg.msg_flags <span style="color:#f92672">=</span> flags;
</span></span><span style="display:flex;"><span>	err <span style="color:#f92672">=</span> <span style="color:#a6e22e">sock_sendmsg</span>(sock, <span style="color:#f92672">&amp;</span>msg);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>out_put:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fput_light</span>(sock<span style="color:#f92672">-&gt;</span>file, fput_needed);
</span></span><span style="display:flex;"><span>out:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> err;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="21-import_single_range">2.1 import_single_range</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">import_single_range</span>(<span style="color:#66d9ef">int</span> rw, <span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">size_t</span> len,
</span></span><span style="display:flex;"><span>		 <span style="color:#66d9ef">struct</span> iovec <span style="color:#f92672">*</span>iov, <span style="color:#66d9ef">struct</span> iov_iter <span style="color:#f92672">*</span>i)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (len <span style="color:#f92672">&gt;</span> MAX_RW_COUNT)
</span></span><span style="display:flex;"><span>		len <span style="color:#f92672">=</span> MAX_RW_COUNT;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 检查 buf:buf+len 是否指向用户区域
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">access_ok</span>(buf, len)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EFAULT;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 记录用户数据地址与长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	iov<span style="color:#f92672">-&gt;</span>iov_base <span style="color:#f92672">=</span> buf;
</span></span><span style="display:flex;"><span>	iov<span style="color:#f92672">-&gt;</span>iov_len <span style="color:#f92672">=</span> len;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// i-&gt;count = count; 将数据长度记录进入msg.msg_iter-&gt;count
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">iov_iter_init</span>(i, rw, iov, <span style="color:#ae81ff">1</span>, len);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>iov_iter_init</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">iov_iter_init</span>(<span style="color:#66d9ef">struct</span> iov_iter <span style="color:#f92672">*</span>i, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> direction,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> iovec <span style="color:#f92672">*</span>iov, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> nr_segs,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">size_t</span> count)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 不能存在读写之外的标志位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">WARN_ON</span>(direction <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>(READ <span style="color:#f92672">|</span> WRITE));
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 忽略传入标志位, 直接赋予READ | WRITE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	direction <span style="color:#f92672">&amp;=</span> READ <span style="color:#f92672">|</span> WRITE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// uaccess_kernel()判断当前系统调用可访问空间是否为全部空间(KERNEL_DS),
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 由此决定使用ITER_KVEC / ITER_IOVEC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// msg.msg_iter-&gt;kvec/iov为union类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">uaccess_kernel</span>()) {
</span></span><span style="display:flex;"><span>		i<span style="color:#f92672">-&gt;</span>type <span style="color:#f92672">=</span> ITER_KVEC <span style="color:#f92672">|</span> direction;
</span></span><span style="display:flex;"><span>		i<span style="color:#f92672">-&gt;</span>kvec <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> kvec <span style="color:#f92672">*</span>)iov;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		i<span style="color:#f92672">-&gt;</span>type <span style="color:#f92672">=</span> ITER_IOVEC <span style="color:#f92672">|</span> direction;
</span></span><span style="display:flex;"><span>		i<span style="color:#f92672">-&gt;</span>iov <span style="color:#f92672">=</span> iov;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	i<span style="color:#f92672">-&gt;</span>nr_segs <span style="color:#f92672">=</span> nr_segs;
</span></span><span style="display:flex;"><span>	i<span style="color:#f92672">-&gt;</span>iov_offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	i<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">=</span> count;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="22-sockfd_lookup_light">2.2 sockfd_lookup_light</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> socket <span style="color:#f92672">*</span><span style="color:#a6e22e">sockfd_lookup_light</span>(<span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>err, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>fput_needed)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 通过fd获得struct fd
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> fd f <span style="color:#f92672">=</span> <span style="color:#a6e22e">fdget</span>(fd);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> socket <span style="color:#f92672">*</span>sock;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>err <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EBADF;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 查看struct fd是否与file绑定
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (f.file) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/*	判断file文件操作结构体成员是否与socket文件操作结构体相同, 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			相同则说明struct fd内绑定的确实是socket文件, 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			返回file-&gt;private_data即socket
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			if (file-&gt;f_op == &amp;socket_file_ops)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">				return file-&gt;private_data;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		*/</span>
</span></span><span style="display:flex;"><span>		sock <span style="color:#f92672">=</span> <span style="color:#a6e22e">sock_from_file</span>(f.file, err);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(sock)) {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 表示可解除对该文件描述符的引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#f92672">*</span>fput_needed <span style="color:#f92672">=</span> f.flags <span style="color:#f92672">&amp;</span> FDPUT_FPUT;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> sock;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fdput</span>(f);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="23-sock_sendmsg">2.3 sock_sendmsg</h3>
<blockquote>
<p>sock_sendmsg -&gt; sock_sendmsg_nosec -&gt; inet_sendmsg -&gt; udp_sendmsg (层层封装)</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sock_sendmsg</span>(<span style="color:#66d9ef">struct</span> socket <span style="color:#f92672">*</span>sock, <span style="color:#66d9ef">struct</span> msghdr <span style="color:#f92672">*</span>msg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// LSM hook
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> err <span style="color:#f92672">=</span> <span style="color:#a6e22e">security_socket_sendmsg</span>(sock, msg,
</span></span><span style="display:flex;"><span>					  <span style="color:#a6e22e">msg_data_left</span>(msg));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> err <span style="color:#f92672">?:</span> <span style="color:#a6e22e">sock_sendmsg_nosec</span>(sock, msg);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>(假设family=AF_INET, protocol=UDP)调用sock-&gt;ops-&gt;sendmsg, 调用协议族自带的sendmsg功能函数(inet_sendmsg)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// msg_data_left(msg) 获得用户数据大小(msg.msg_iter-&gt;count)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sock_sendmsg_nosec</span>(<span style="color:#66d9ef">struct</span> socket <span style="color:#f92672">*</span>sock, <span style="color:#66d9ef">struct</span> msghdr <span style="color:#f92672">*</span>msg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">INDIRECT_CALL_INET</span>(sock<span style="color:#f92672">-&gt;</span>ops<span style="color:#f92672">-&gt;</span>sendmsg, inet6_sendmsg,
</span></span><span style="display:flex;"><span>				     inet_sendmsg, sock, msg,
</span></span><span style="display:flex;"><span>				     <span style="color:#a6e22e">msg_data_left</span>(msg));
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">BUG_ON</span>(ret <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>EIOCBQUEUED);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>根据socket获得sock, 由protocol决定调用功能函数(udp_sendmsg)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">inet_sendmsg</span>(<span style="color:#66d9ef">struct</span> socket <span style="color:#f92672">*</span>sock, <span style="color:#66d9ef">struct</span> msghdr <span style="color:#f92672">*</span>msg, <span style="color:#66d9ef">size_t</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sock <span style="color:#f92672">*</span>sk <span style="color:#f92672">=</span> sock<span style="color:#f92672">-&gt;</span>sk;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果没有绑定端口, 这里自动绑定端口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">inet_send_prepare</span>(sk)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EAGAIN;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">INDIRECT_CALL_2</span>(sk<span style="color:#f92672">-&gt;</span>sk_prot<span style="color:#f92672">-&gt;</span>sendmsg, tcp_sendmsg, udp_sendmsg,
</span></span><span style="display:flex;"><span>			       sk, msg, size);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>栈回溯</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>gef<span style="color:#960050;background-color:#1e0010">➤</span>  bt
</span></span><span style="display:flex;"><span><span style="color:#75715e">#0  udp_sendmsg (sk=0xffff888005c7d680, msg=0xffffc900001b7e10, len=0x800) at net/ipv4/udp.c:969
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#1  0xffffffff819f4135 in inet_sendmsg (sock=&lt;optimized out&gt;, msg=0xffffc900001b7e10, size=0x800) at net/ipv4/af_inet.c:807
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#2  0xffffffff8190ba9e in sock_sendmsg_nosec (msg=&lt;optimized out&gt;, sock=&lt;optimized out&gt;) at ./include</span><span style="color:#75715e">/linux/uio.h:235</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#3  sock_sendmsg (sock=0xffff888006817a80, msg=0xffffc900001b7e10) at net/socket.c:657
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#4  0xffffffff8190de13 in __sys_sendto (fd=&lt;optimized out&gt;, buff=&lt;optimized out&gt;, len=&lt;optimized out&gt;, flags=0x0, addr=0x7ffde0c0cf10, addr_len=0x10) at net/socket.c:1952
</span></span></span></code></pre></div><h3 id="24-udp_sendmsg">2.4 udp_sendmsg</h3>
<ul>
<li>
<p>前置知识</p>
<ul>
<li>
<p>宏定义展开</p>
<ul>
<li>DECLARE_SOCKADDR</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// struct sockaddr_in * sin= ({__sockaddr_check_size(sizeof(*sin)); (struct sockaddr_in *) msg-&gt;msg_name;})
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">DECLARE_SOCKADDR</span>(<span style="color:#66d9ef">struct</span> sockaddr_in <span style="color:#f92672">*</span>, usin, msg<span style="color:#f92672">-&gt;</span>msg_name);
</span></span></code></pre></div><ul>
<li>IS_UDPLITE: 传统的 UDP 通信对整个报文进行校验, UDP-LITE 通信则可以设置校验的长度, 适用于可以接受轻微的报文内容出错的应用场景</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// int err, is_udplite = (sk) (sk-&gt;sk_protocol == IPPROTO_UDPLITE)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> err, is_udplite <span style="color:#f92672">=</span> <span style="color:#a6e22e">IS_UDPLITE</span>(sk);
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>根据socket获得inet_sock, udp_sock</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> inet_sock <span style="color:#f92672">*</span>inet <span style="color:#f92672">=</span> <span style="color:#a6e22e">inet_sk</span>(sk);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> udp_sock <span style="color:#f92672">*</span>up <span style="color:#f92672">=</span> <span style="color:#a6e22e">udp_sk</span>(sk);
</span></span></code></pre></div><ul>
<li>udp_sock的corkflag标志或msg中的MSG_MORE标志存在则开启软木塞机制</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> corkreq <span style="color:#f92672">=</span> up<span style="color:#f92672">-&gt;</span>corkflag <span style="color:#f92672">||</span> msg<span style="color:#f92672">-&gt;</span>msg_flags<span style="color:#f92672">&amp;</span>MSG_MORE;
</span></span></code></pre></div><ul>
<li>udp 不能处理带外数据请求</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (msg<span style="color:#f92672">-&gt;</span>msg_flags <span style="color:#f92672">&amp;</span> MSG_OOB) <span style="color:#75715e">/* Mirror BSD error message compatibility */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EOPNOTSUPP;
</span></span></code></pre></div><ul>
<li>尝试追加数据(由udp_sock-&gt;pending决定), 进入do_append_data, 阻塞追加</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (up<span style="color:#f92672">-&gt;</span>pending) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * There are pending frames.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * The socket lock must be held while it&#39;s corked.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">lock_sock</span>(sk);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(up<span style="color:#f92672">-&gt;</span>pending)) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(up<span style="color:#f92672">-&gt;</span>pending <span style="color:#f92672">!=</span> AF_INET)) {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">release_sock</span>(sk);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> do_append_data;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">release_sock</span>(sk);
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><ul>
<li>ulen 表示udp报文大小(带udphdr)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>ulen <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> udphdr);
</span></span></code></pre></div><ul>
<li>usin包含目标ip, 端口, 协议族信息. 在udp协议中, usin应使用AF_INET或AF_UNSPEC(支持同时返回IPv4&amp;IPv6 信息). 同时如果当前状态为TCP_ESTABLISHED, 表示udp连接已经被建立(connected), usin可为空, 接下来需要继承上次通信对应的ip与端口信息.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (usin) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果udp_send 存在目标位置, 则检查协议族, 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (msg<span style="color:#f92672">-&gt;</span>msg_namelen <span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>usin))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (usin<span style="color:#f92672">-&gt;</span>sin_family <span style="color:#f92672">!=</span> AF_INET) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (usin<span style="color:#f92672">-&gt;</span>sin_family <span style="color:#f92672">!=</span> AF_UNSPEC)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EAFNOSUPPORT;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 填充目标ip与端口信息(端口必须存在)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    daddr <span style="color:#f92672">=</span> usin<span style="color:#f92672">-&gt;</span>sin_addr.s_addr;
</span></span><span style="display:flex;"><span>    dport <span style="color:#f92672">=</span> usin<span style="color:#f92672">-&gt;</span>sin_port;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (dport <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// TCP_ESTABLISHED表示udp连接已经被建立, 所以可以不需要目标位置信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (sk<span style="color:#f92672">-&gt;</span>sk_state <span style="color:#f92672">!=</span> TCP_ESTABLISHED)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EDESTADDRREQ;
</span></span><span style="display:flex;"><span>    daddr <span style="color:#f92672">=</span> inet<span style="color:#f92672">-&gt;</span>inet_daddr;
</span></span><span style="display:flex;"><span>    dport <span style="color:#f92672">=</span> inet<span style="color:#f92672">-&gt;</span>inet_dport;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Open fast path for connected socket.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        Route will not be used, if at least one option is set.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        */</span>
</span></span><span style="display:flex;"><span>    connected <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>处理udp协议控制信息</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// ipc用来记录控制信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">ipcm_init_sk</span>(<span style="color:#f92672">&amp;</span>ipc, inet);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// udp分片长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ipc.gso_size <span style="color:#f92672">=</span> up<span style="color:#f92672">-&gt;</span>gso_size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 开始解析控制信息, 填充至ipc, 详细见2.4.1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (msg<span style="color:#f92672">-&gt;</span>msg_controllen) {
</span></span><span style="display:flex;"><span>	err <span style="color:#f92672">=</span> <span style="color:#a6e22e">udp_cmsg_send</span>(sk, msg, <span style="color:#f92672">&amp;</span>ipc.gso_size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// cmsg-&gt;cmsg_level中存在SOL_UDP(need_ip = true), 进入ip_cmsg_send, 详细见4.1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (err <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		err <span style="color:#f92672">=</span> <span style="color:#a6e22e">ip_cmsg_send</span>(sk, msg, <span style="color:#f92672">&amp;</span>ipc,
</span></span><span style="display:flex;"><span>					sk<span style="color:#f92672">-&gt;</span>sk_family <span style="color:#f92672">==</span> AF_INET6);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(err <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">kfree</span>(ipc.opt);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> err;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ipc.opt)
</span></span><span style="display:flex;"><span>		free <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	connected <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>为ipc.opt 填充ip 选项信息(如果cmsg中存在ip选项信息, 则提前填充, 掠过此处). 即如果用户没有自定义ip 选项信息, 则使用inet默认的ip 选项信息</li>
</ul>
<pre tabindex="0"><code>// ip 选项描述结构体
/** struct ip_options - IP Options
 *
 * @faddr - Saved first hop address
 * @nexthop - Saved nexthop address in LSRR and SSRR
 * @is_strictroute - Strict source route
 * @srr_is_hit - Packet destination addr was our one
 * @is_changed - IP checksum more not valid
 * @rr_needaddr - Need to record addr of outgoing dev
 * @ts_needtime - Need to record timestamp
 * @ts_needaddr - Need to record addr of outgoing dev
 */
struct ip_options {
	__be32		faddr;
	__be32		nexthop;
	unsigned char	optlen;
	unsigned char	srr;
	unsigned char	rr;
	unsigned char	ts;
	unsigned char	is_strictroute:1,
			srr_is_hit:1,
			is_changed:1,
			rr_needaddr:1,
			ts_needtime:1,
			ts_needaddr:1;
	unsigned char	router_alert;
	unsigned char	cipso;
	unsigned char	__pad2;
	unsigned char	__data[0];
}; 
</code></pre><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ipc.opt) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> ip_options_rcu <span style="color:#f92672">*</span>inet_opt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">rcu_read_lock</span>();
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		inet_opt <span style="color:#f92672">=</span> <span style="color:#a6e22e">rcu_dereference</span>(inet<span style="color:#f92672">-&gt;</span>inet_opt);
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 将inet-&gt;inet_opt-&gt;opt拷贝给opt_copy
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (inet_opt) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">memcpy</span>(<span style="color:#f92672">&amp;</span>opt_copy, inet_opt,
</span></span><span style="display:flex;"><span>			       <span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>inet_opt) <span style="color:#f92672">+</span> inet_opt<span style="color:#f92672">-&gt;</span>opt.optlen);
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 填充ipc.opt
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			ipc.opt <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>opt_copy.opt;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">rcu_read_unlock</span>();
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><ul>
<li>检查是否设置了源记录路由(source record route, SRR) IP 选项. SRR 有两种类型: 宽松源记录路由/严格源记录路由. 如果设置SRR, 则会记录第一跳地址并保存到faddr, 然后将socket 标记为unconnected</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (ipc.opt <span style="color:#f92672">&amp;&amp;</span> ipc.opt<span style="color:#f92672">-&gt;</span>opt.srr) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>daddr) {
</span></span><span style="display:flex;"><span>        err <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> out_free;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    faddr <span style="color:#f92672">=</span> ipc.opt<span style="color:#f92672">-&gt;</span>opt.faddr;
</span></span><span style="display:flex;"><span>    connected <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>获得tos标志(优先从控制信息ipc中获取, 没有自定义则从inet默认获取tos), tos详细见2.4.2</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>tos <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_rttos</span>(<span style="color:#f92672">&amp;</span>ipc, inet);
</span></span></code></pre></div><ul>
<li>禁止路由设置可以由三种方式控制</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">sock_flag</span>(sk, SOCK_LOCALROUTE) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>	    (msg<span style="color:#f92672">-&gt;</span>msg_flags <span style="color:#f92672">&amp;</span> MSG_DONTROUTE) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>	    (ipc.opt <span style="color:#f92672">&amp;&amp;</span> ipc.opt<span style="color:#f92672">-&gt;</span>opt.is_strictroute)) {
</span></span><span style="display:flex;"><span>		tos <span style="color:#f92672">|=</span> RTO_ONLINK;
</span></span><span style="display:flex;"><span>		connected <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><ul>
<li>选择网卡设备, 多播见2.4.3</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 通过判断目的地址是否位于224.0.0.0/4 网段, 确定是否为多播
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">ipv4_is_multicast</span>(daddr)) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 设置设备索引为多播设备
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ipc.oif <span style="color:#f92672">||</span> <span style="color:#a6e22e">netif_index_is_l3_master</span>(<span style="color:#a6e22e">sock_net</span>(sk), ipc.oif))
</span></span><span style="display:flex;"><span>        ipc.oif <span style="color:#f92672">=</span> inet<span style="color:#f92672">-&gt;</span>mc_index;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果没有设置源地址, 则设置源地址为多播地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>saddr)
</span></span><span style="display:flex;"><span>        saddr <span style="color:#f92672">=</span> inet<span style="color:#f92672">-&gt;</span>mc_addr;
</span></span><span style="display:flex;"><span>    connected <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ipc.oif) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 协议控制信息没有设置设备索引且非多播则设置设备索引为单播设备索引
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ipc.oif <span style="color:#f92672">=</span> inet<span style="color:#f92672">-&gt;</span>uc_index;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">ipv4_is_lbcast</span>(daddr) <span style="color:#f92672">&amp;&amp;</span> inet<span style="color:#f92672">-&gt;</span>uc_index) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* oif is set, packet is to local broadcast and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        * and uc_index is set. oif is most likely set
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        * by sk_bound_dev_if. If uc_index != oif check if the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        * oif is an L3 master and uc_index is an L3 slave.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        * If so, we want to allow the send using the uc_index.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 协议控制信息已设置设备索引&amp;消息本地广播&amp;inet存在单播设备&amp;ipc未与inet单播设备绑定
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 如果ipc绑定inet网卡设备的l3主设备(虚拟网卡), 更改绑定设备为inet网卡(本地广播不需要l3mdev辅助实现VRF)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 关于VRF建议阅读: https://blog.csdn.net/dog250/article/details/78069964
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (ipc.oif <span style="color:#f92672">!=</span> inet<span style="color:#f92672">-&gt;</span>uc_index <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        ipc.oif <span style="color:#f92672">==</span> <span style="color:#a6e22e">l3mdev_master_ifindex_by_index</span>(<span style="color:#a6e22e">sock_net</span>(sk),
</span></span><span style="display:flex;"><span>                                inet<span style="color:#f92672">-&gt;</span>uc_index)) {
</span></span><span style="display:flex;"><span>        ipc.oif <span style="color:#f92672">=</span> inet<span style="color:#f92672">-&gt;</span>uc_index;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>获得路由信息</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (connected)
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果正在连接, 检查路由是否过期, 详细见2.4.4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		rt <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> rtable <span style="color:#f92672">*</span>)<span style="color:#a6e22e">sk_dst_check</span>(sk, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>rt) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> net <span style="color:#f92672">*</span>net <span style="color:#f92672">=</span> <span style="color:#a6e22e">sock_net</span>(sk);
</span></span><span style="display:flex;"><span>		__u8 flow_flags <span style="color:#f92672">=</span> <span style="color:#a6e22e">inet_sk_flowi_flags</span>(sk);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		fl4 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>fl4_stack;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// flowi4_init_output初始化flow, 描述udp数据流信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">flowi4_init_output</span>(fl4, ipc.oif, ipc.sockc.mark, tos,
</span></span><span style="display:flex;"><span>				   RT_SCOPE_UNIVERSE, sk<span style="color:#f92672">-&gt;</span>sk_protocol,
</span></span><span style="display:flex;"><span>				   flow_flags,
</span></span><span style="display:flex;"><span>				   faddr, saddr, dport, inet<span style="color:#f92672">-&gt;</span>inet_sport,
</span></span><span style="display:flex;"><span>				   sk<span style="color:#f92672">-&gt;</span>sk_uid);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// LSM
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">security_sk_classify_flow</span>(sk, <span style="color:#a6e22e">flowi4_to_flowi</span>(fl4));
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 获得路由表项
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		rt <span style="color:#f92672">=</span> <span style="color:#a6e22e">ip_route_output_flow</span>(net, fl4, sk);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">IS_ERR</span>(rt)) {
</span></span><span style="display:flex;"><span>			err <span style="color:#f92672">=</span> <span style="color:#a6e22e">PTR_ERR</span>(rt);
</span></span><span style="display:flex;"><span>			rt <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (err <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>ENETUNREACH)
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">IP_INC_STATS</span>(net, IPSTATS_MIB_OUTNOROUTES);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> out;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		err <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EACCES;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 广播路由必须由具有配置SOCK_BROADCAST 标志的sock接收
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> ((rt<span style="color:#f92672">-&gt;</span>rt_flags <span style="color:#f92672">&amp;</span> RTCF_BROADCAST) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>		    <span style="color:#f92672">!</span><span style="color:#a6e22e">sock_flag</span>(sk, SOCK_BROADCAST))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> out;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (connected)
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 如果当前sock 处于connected状态, 则将路由保存至sk-&gt;sk_dst_cache
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">sk_dst_set</span>(sk, <span style="color:#a6e22e">dst_clone</span>(<span style="color:#f92672">&amp;</span>rt<span style="color:#f92672">-&gt;</span>dst));
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><ul>
<li>对于用于探测的数据包, 如果配置了MSG_CONFIRM标志, 则更新邻居结点ARP缓存时间戳, 防止ARP缓存过期</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (msg<span style="color:#f92672">-&gt;</span>msg_flags<span style="color:#f92672">&amp;</span>MSG_CONFIRM)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> do_confirm;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>do_confirm:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (msg<span style="color:#f92672">-&gt;</span>msg_flags <span style="color:#f92672">&amp;</span> MSG_PROBE)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">dst_confirm_neigh</span>(<span style="color:#f92672">&amp;</span>rt<span style="color:#f92672">-&gt;</span>dst, <span style="color:#f92672">&amp;</span>fl4<span style="color:#f92672">-&gt;</span>daddr);
</span></span></code></pre></div><ul>
<li>非阻塞情况下</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>corkreq) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> inet_cork cork;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 构建 skb, 详细见4.2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		skb <span style="color:#f92672">=</span> <span style="color:#a6e22e">ip_make_skb</span>(sk, fl4, getfrag, msg, ulen,
</span></span><span style="display:flex;"><span>				  <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> udphdr), <span style="color:#f92672">&amp;</span>ipc, <span style="color:#f92672">&amp;</span>rt,
</span></span><span style="display:flex;"><span>				  <span style="color:#f92672">&amp;</span>cork, msg<span style="color:#f92672">-&gt;</span>msg_flags);
</span></span><span style="display:flex;"><span>		err <span style="color:#f92672">=</span> <span style="color:#a6e22e">PTR_ERR</span>(skb);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">IS_ERR_OR_NULL</span>(skb))
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 传输skb 至网络层, 详细见1.4.5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			err <span style="color:#f92672">=</span> <span style="color:#a6e22e">udp_send_skb</span>(skb, fl4, <span style="color:#f92672">&amp;</span>cork);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> out;
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><ul>
<li>阻塞情况下</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *	Now cork the socket to pend data.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	fl4 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>inet<span style="color:#f92672">-&gt;</span>cork.fl.u.ip4;
</span></span><span style="display:flex;"><span>	fl4<span style="color:#f92672">-&gt;</span>daddr <span style="color:#f92672">=</span> daddr;
</span></span><span style="display:flex;"><span>	fl4<span style="color:#f92672">-&gt;</span>saddr <span style="color:#f92672">=</span> saddr;
</span></span><span style="display:flex;"><span>	fl4<span style="color:#f92672">-&gt;</span>fl4_dport <span style="color:#f92672">=</span> dport;
</span></span><span style="display:flex;"><span>	fl4<span style="color:#f92672">-&gt;</span>fl4_sport <span style="color:#f92672">=</span> inet<span style="color:#f92672">-&gt;</span>inet_sport;
</span></span><span style="display:flex;"><span>	up<span style="color:#f92672">-&gt;</span>pending <span style="color:#f92672">=</span> AF_INET;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>do_append_data:
</span></span><span style="display:flex;"><span>	up<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">+=</span> ulen;
</span></span><span style="display:flex;"><span>	err <span style="color:#f92672">=</span> <span style="color:#a6e22e">ip_append_data</span>(sk, fl4, getfrag, msg, ulen,
</span></span><span style="display:flex;"><span>			     <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> udphdr), <span style="color:#f92672">&amp;</span>ipc, <span style="color:#f92672">&amp;</span>rt,
</span></span><span style="display:flex;"><span>			     corkreq <span style="color:#f92672">?</span> msg<span style="color:#f92672">-&gt;</span>msg_flags<span style="color:#f92672">|</span>MSG_MORE : msg<span style="color:#f92672">-&gt;</span>msg_flags);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (err)
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 链接skb过程中发生错误, 丢弃skb
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">udp_flush_pending_frames</span>(sk);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (<span style="color:#f92672">!</span>corkreq)
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 组织链接skb后调用udp_send_skb, 填充udp头部并将skb传输给ip层, 详细见2.4.6
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		err <span style="color:#f92672">=</span> <span style="color:#a6e22e">udp_push_pending_frames</span>(sk);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">skb_queue_empty</span>(<span style="color:#f92672">&amp;</span>sk<span style="color:#f92672">-&gt;</span>sk_write_queue)))
</span></span><span style="display:flex;"><span>		up<span style="color:#f92672">-&gt;</span>pending <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">release_sock</span>(sk);
</span></span></code></pre></div><h3 id="241-udp_cmsg_send">2.4.1 udp_cmsg_send</h3>
<ul>
<li>通过相关patch进行分析得出以下结论. <a href="https://www.spinics.net/lists/netdev/msg496109.html">patch1</a>  <a href="https://patchwork.ozlabs.org/project/netdev/cover/20180426174225.246388-1-willemdebruijn.kernel@gmail.com/#1901515">patch2</a>: 添加GSO机制, 用户可以在一次系统调用中, 向同一目的ip发送多个报文</li>
</ul>
<blockquote>
<p>udp_cmsg_send</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 遍历被切割成多个cmsg的msg-&gt;control
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">udp_cmsg_send</span>(<span style="color:#66d9ef">struct</span> sock <span style="color:#f92672">*</span>sk, <span style="color:#66d9ef">struct</span> msghdr <span style="color:#f92672">*</span>msg, u16 <span style="color:#f92672">*</span>gso_size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> cmsghdr <span style="color:#f92672">*</span>cmsg;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> need_ip <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> err;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">for_each_cmsghdr</span>(cmsg, msg) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">CMSG_OK</span>(msg, cmsg))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 存在非UDP层控制信息, 下一步会进入ip_cmsg_send解析
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (cmsg<span style="color:#f92672">-&gt;</span>cmsg_level <span style="color:#f92672">!=</span> SOL_UDP) {
</span></span><span style="display:flex;"><span>			need_ip <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		err <span style="color:#f92672">=</span> <span style="color:#a6e22e">__udp_cmsg_send</span>(cmsg, gso_size);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (err)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> err;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> need_ip;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>udp_cmsg_send-&gt;for_each_cmsghdr(cmsg, msg)</p>
</blockquote>
<ul>
<li>
<p>将msg-&gt;control切割成多个cmsg, 具体逻辑:</p>
<ul>
<li>
<p>获得第一个cmsg: cmsg = msg-&gt;control(msg-&gt;controllen &gt;= sizeof(struct cmsghdr)), cmsghdr结构体包含__cmsg_data __flexarr 成员, 该成员为可变字符数组, 用来存储cmsg, 也就是说msg-&gt;control中的数据按照cmsghdr结构储存管理, 且cmsghdr结构可变</p>
</li>
<li>
<p>获得next_cmsg: next_cmsg = cmsg + (align)cmsg-&gt;cmsg_len(cmsg+cmsg-&gt;cmsg_len+1-msg-&gt;control &gt; msg-&gt;msg_controllen)</p>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define for_each_cmsghdr(cmsg, msg) \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	for (cmsg = CMSG_FIRSTHDR(msg); \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	     cmsg; \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	     cmsg = CMSG_NXTHDR(msg, cmsg))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* CMSG_FIRSTHDR:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define CMSG_FIRSTHDR(msg)	__CMSG_FIRSTHDR((msg)-&gt;msg_control, (msg)-&gt;msg_controllen)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define __CMSG_FIRSTHDR(ctl,len) ((len) &gt;= sizeof(struct cmsghdr) ? \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">				  (struct cmsghdr *)(ctl) : \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">				  (struct cmsghdr *)NULL)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* CMSG_NXTHDR:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define CMSG_NXTHDR(mhdr, cmsg) cmsg_nxthdr((mhdr), (cmsg))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">static inline struct cmsghdr * cmsg_nxthdr (struct msghdr *__msg, struct cmsghdr *__cmsg)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	return __cmsg_nxthdr(__msg-&gt;msg_control, __msg-&gt;msg_controllen, __cmsg);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">static inline struct cmsghdr * __cmsg_nxthdr(void *__ctl, __kernel_size_t __size,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">					       struct cmsghdr *__cmsg)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	struct cmsghdr * __ptr;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	__ptr = (struct cmsghdr*)(((unsigned char *) __cmsg) +  CMSG_ALIGN(__cmsg-&gt;cmsg_len));
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	if ((unsigned long)((char*)(__ptr+1) - (char *) __ctl) &gt; __size)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		return (struct cmsghdr *)0;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	return __ptr;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">}
</span></span></span></code></pre></div><blockquote>
<p>udp_cmsg_send-&gt;__udp_cmsg_send</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">__udp_cmsg_send</span>(<span style="color:#66d9ef">struct</span> cmsghdr <span style="color:#f92672">*</span>cmsg, u16 <span style="color:#f92672">*</span>gso_size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> (cmsg<span style="color:#f92672">-&gt;</span>cmsg_type) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> UDP_SEGMENT:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (cmsg<span style="color:#f92672">-&gt;</span>cmsg_len <span style="color:#f92672">!=</span> <span style="color:#a6e22e">CMSG_LEN</span>(<span style="color:#66d9ef">sizeof</span>(__u16)))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 指定GSO报文大小, UDP_SEGMENT类型控制信息, 会在cmsg-&gt;__cmsg_data前两字节处指定gso_size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#f92672">*</span>gso_size <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(__u16 <span style="color:#f92672">*</span>)<span style="color:#a6e22e">CMSG_DATA</span>(cmsg);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="242-tos">2.4.2 TOS</h3>
<blockquote>
<p>TOS(8bits) 通过填充flag标志位, 用以表示网络设备提供的服务类型(网络设备必须能够支持, 否则没有任何意义).</p>
</blockquote>
<ul>
<li>
<p>前3bits: 废弃, 无意义, 默认000</p>
</li>
<li>
<p>4bits:</p>
<ul>
<li>1000 &ndash; minimize delay 最小延迟</li>
<li>0100 &ndash; maximize throughput 最大吞吐量</li>
<li>0010 &ndash; maximize reliability 最高可靠性</li>
<li>0001 &ndash; minimize monetary cost 最小费用</li>
<li>0000 &ndash; normal service 一般服务</li>
</ul>
</li>
<li>
<p>末尾1bit: 无意义, 保留</p>
</li>
</ul>
<h3 id="243-多播本地广播">2.4.3 多播/本地广播</h3>
<ul>
<li>
<p>设置多播/本地广播</p>
<ul>
<li>
<p>多播可以参考这篇文章(多播技术)[https://www.huaweicloud.com/articles/6369165847f916e2f8a8638a480fb1f8.html], 总结概括如下:</p>
<ul>
<li>
<p>多播用来实现一点对多点的传播, 适用于流媒体, 视频会议等场景</p>
</li>
<li>
<p>多播类似于广播, 使用特殊ip地址作为目的地址(224.0.0.0/4), 多播数据报文会被路由器抄写为多份, 发送至多个目标. 与广播不同的是, 多播只会向存在多播接收请求的子网转发信息.</p>
</li>
<li>
<p>对于接收者来说, 如果接收者希望接收某一多播信息, 会使用IGMP协议向本地服务器发送请求申请加入某多播组, 本地路由器会将该接收者加入多播组, 并将该组信息共享至相邻路由节点.</p>
</li>
</ul>
</li>
<li>
<p>本地广播此处不再赘述</p>
</li>
</ul>
</li>
</ul>
<h3 id="244-检查sock中路由信息是否过期">2.4.4 检查sock中路由信息是否过期</h3>
<blockquote>
<p>sk_dst_check</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> dst_entry <span style="color:#f92672">*</span><span style="color:#a6e22e">sk_dst_check</span>(<span style="color:#66d9ef">struct</span> sock <span style="color:#f92672">*</span>sk, u32 cookie)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> dst_entry <span style="color:#f92672">*</span>dst <span style="color:#f92672">=</span> <span style="color:#a6e22e">sk_dst_get</span>(sk);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (dst <span style="color:#f92672">&amp;&amp;</span> dst<span style="color:#f92672">-&gt;</span>obsolete <span style="color:#f92672">&amp;&amp;</span> dst<span style="color:#f92672">-&gt;</span>ops<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">check</span>(dst, cookie) <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">sk_dst_reset</span>(sk);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">dst_release</span>(dst);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> dst;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>sk_dst_check-&gt;sk_dst_get(获得路由信息)</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">sk_dst_get</span>(<span style="color:#66d9ef">struct</span> sock <span style="color:#f92672">*</span>sk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> dst_entry <span style="color:#f92672">*</span>dst;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">rcu_read_lock</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 从sk-&gt;sk_dst_cache去路由信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	dst <span style="color:#f92672">=</span> <span style="color:#a6e22e">rcu_dereference</span>(sk<span style="color:#f92672">-&gt;</span>sk_dst_cache);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 引用数 +1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (dst <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">atomic_inc_not_zero</span>(<span style="color:#f92672">&amp;</span>dst<span style="color:#f92672">-&gt;</span>__refcnt))
</span></span><span style="display:flex;"><span>		dst <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">rcu_read_unlock</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> dst;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>sk_dst_check-&gt;dst-&gt;ops-&gt;check(ipv4下调用ipv4_dst_check, 检查是否过期)</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> dst_entry <span style="color:#f92672">*</span><span style="color:#a6e22e">ipv4_dst_check</span>(<span style="color:#66d9ef">struct</span> dst_entry <span style="color:#f92672">*</span>dst, u32 cookie)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rtable <span style="color:#f92672">*</span>rt <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> rtable <span style="color:#f92672">*</span>) dst;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* All IPV4 dsts are created with -&gt;obsolete set to the value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * DST_OBSOLETE_FORCE_CHK which forces validation calls down
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * into this function always.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * When a PMTU/redirect information update invalidates a route,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * this is indicated by setting obsolete to DST_OBSOLETE_KILL or
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * DST_OBSOLETE_DEAD.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// dst-&gt;obsolete 不等于DST_OBSOLETE_FORCE_CHK表示路由信息过期
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (dst<span style="color:#f92672">-&gt;</span>obsolete <span style="color:#f92672">!=</span> DST_OBSOLETE_FORCE_CHK <span style="color:#f92672">||</span> <span style="color:#a6e22e">rt_is_expired</span>(rt))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> dst;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="245-udp_send_skb">2.4.5 udp_send_skb</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">udp_send_skb</span>(<span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb, <span style="color:#66d9ef">struct</span> flowi4 <span style="color:#f92672">*</span>fl4,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">struct</span> inet_cork <span style="color:#f92672">*</span>cork)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sock <span style="color:#f92672">*</span>sk <span style="color:#f92672">=</span> skb<span style="color:#f92672">-&gt;</span>sk;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> inet_sock <span style="color:#f92672">*</span>inet <span style="color:#f92672">=</span> <span style="color:#a6e22e">inet_sk</span>(sk);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> udphdr <span style="color:#f92672">*</span>uh;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> err <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> is_udplite <span style="color:#f92672">=</span> <span style="color:#a6e22e">IS_UDPLITE</span>(sk);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> offset <span style="color:#f92672">=</span> <span style="color:#a6e22e">skb_transport_offset</span>(skb);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> skb<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">-</span> offset;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> datalen <span style="color:#f92672">=</span> len <span style="color:#f92672">-</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>uh);
</span></span><span style="display:flex;"><span>	__wsum csum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Create a UDP header
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 填充udp头
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	uh <span style="color:#f92672">=</span> <span style="color:#a6e22e">udp_hdr</span>(skb);
</span></span><span style="display:flex;"><span>	uh<span style="color:#f92672">-&gt;</span>source <span style="color:#f92672">=</span> inet<span style="color:#f92672">-&gt;</span>inet_sport;
</span></span><span style="display:flex;"><span>	uh<span style="color:#f92672">-&gt;</span>dest <span style="color:#f92672">=</span> fl4<span style="color:#f92672">-&gt;</span>fl4_dport;
</span></span><span style="display:flex;"><span>	uh<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">=</span> <span style="color:#a6e22e">htons</span>(len);
</span></span><span style="display:flex;"><span>	uh<span style="color:#f92672">-&gt;</span>check <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 检查是否满足GSO机制, 直接进入硬件校验
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (cork<span style="color:#f92672">-&gt;</span>gso_size) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> hlen <span style="color:#f92672">=</span> <span style="color:#a6e22e">skb_network_header_len</span>(skb) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>				 <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> udphdr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (hlen <span style="color:#f92672">+</span> cork<span style="color:#f92672">-&gt;</span>gso_size <span style="color:#f92672">&gt;</span> cork<span style="color:#f92672">-&gt;</span>fragsize) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">kfree_skb</span>(skb);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (skb<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">&gt;</span> cork<span style="color:#f92672">-&gt;</span>gso_size <span style="color:#f92672">*</span> UDP_MAX_SEGMENTS) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">kfree_skb</span>(skb);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (sk<span style="color:#f92672">-&gt;</span>sk_no_check_tx) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">kfree_skb</span>(skb);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (skb<span style="color:#f92672">-&gt;</span>ip_summed <span style="color:#f92672">!=</span> CHECKSUM_PARTIAL <span style="color:#f92672">||</span> is_udplite <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>		    <span style="color:#a6e22e">dst_xfrm</span>(<span style="color:#a6e22e">skb_dst</span>(skb))) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">kfree_skb</span>(skb);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EIO;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (datalen <span style="color:#f92672">&gt;</span> cork<span style="color:#f92672">-&gt;</span>gso_size) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">skb_shinfo</span>(skb)<span style="color:#f92672">-&gt;</span>gso_size <span style="color:#f92672">=</span> cork<span style="color:#f92672">-&gt;</span>gso_size;
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">skb_shinfo</span>(skb)<span style="color:#f92672">-&gt;</span>gso_type <span style="color:#f92672">=</span> SKB_GSO_UDP_L4;
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">skb_shinfo</span>(skb)<span style="color:#f92672">-&gt;</span>gso_segs <span style="color:#f92672">=</span> <span style="color:#a6e22e">DIV_ROUND_UP</span>(datalen,
</span></span><span style="display:flex;"><span>								 cork<span style="color:#f92672">-&gt;</span>gso_size);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> csum_partial;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 进入UDP-LITE 校验和计算, 可通过指定校验长度容忍报文出错现象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (is_udplite)  				 <span style="color:#75715e">/*     UDP-Lite      */</span>
</span></span><span style="display:flex;"><span>		csum <span style="color:#f92672">=</span> <span style="color:#a6e22e">udplite_csum</span>(skb);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 不进行校验
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (sk<span style="color:#f92672">-&gt;</span>sk_no_check_tx) {			 <span style="color:#75715e">/* UDP csum off */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// CHECKSUM_NONE指不需要校验
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		skb<span style="color:#f92672">-&gt;</span>ip_summed <span style="color:#f92672">=</span> CHECKSUM_NONE;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> send;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (skb<span style="color:#f92672">-&gt;</span>ip_summed <span style="color:#f92672">==</span> CHECKSUM_PARTIAL) { <span style="color:#75715e">/* UDP hardware csum */</span>
</span></span><span style="display:flex;"><span>csum_partial:
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// CHECKSUM_PARTIAL表示硬件实现部分校验和计算(udp数据校验)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">udp4_hwcsum</span>(skb, fl4<span style="color:#f92672">-&gt;</span>saddr, fl4<span style="color:#f92672">-&gt;</span>daddr);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> send;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 软件实现校验和计算(udp数据校验)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		csum <span style="color:#f92672">=</span> <span style="color:#a6e22e">udp_csum</span>(skb);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* add protocol-dependent pseudo-header */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 设置伪ip头, 计算udp报文校验和与伪ip头的校验和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	uh<span style="color:#f92672">-&gt;</span>check <span style="color:#f92672">=</span> <span style="color:#a6e22e">csum_tcpudp_magic</span>(fl4<span style="color:#f92672">-&gt;</span>saddr, fl4<span style="color:#f92672">-&gt;</span>daddr, len,
</span></span><span style="display:flex;"><span>				      sk<span style="color:#f92672">-&gt;</span>sk_protocol, csum);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (uh<span style="color:#f92672">-&gt;</span>check <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		uh<span style="color:#f92672">-&gt;</span>check <span style="color:#f92672">=</span> CSUM_MANGLED_0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>send:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 将skb传递至网络层(IP层), 详细见4.4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	err <span style="color:#f92672">=</span> <span style="color:#a6e22e">ip_send_skb</span>(<span style="color:#a6e22e">sock_net</span>(sk), skb);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (err) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (err <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>ENOBUFS <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>inet<span style="color:#f92672">-&gt;</span>recverr) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">UDP_INC_STATS</span>(<span style="color:#a6e22e">sock_net</span>(sk),
</span></span><span style="display:flex;"><span>				      UDP_MIB_SNDBUFERRORS, is_udplite);
</span></span><span style="display:flex;"><span>			err <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">UDP_INC_STATS</span>(<span style="color:#a6e22e">sock_net</span>(sk),
</span></span><span style="display:flex;"><span>			      UDP_MIB_OUTDATAGRAMS, is_udplite);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> err;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="246-udp_push_pending_frames">2.4.6 udp_push_pending_frames</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">udp_push_pending_frames</span>(<span style="color:#66d9ef">struct</span> sock <span style="color:#f92672">*</span>sk)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> udp_sock  <span style="color:#f92672">*</span>up <span style="color:#f92672">=</span> <span style="color:#a6e22e">udp_sk</span>(sk);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> inet_sock <span style="color:#f92672">*</span>inet <span style="color:#f92672">=</span> <span style="color:#a6e22e">inet_sk</span>(sk);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> flowi4 <span style="color:#f92672">*</span>fl4 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>inet<span style="color:#f92672">-&gt;</span>cork.fl.u.ip4;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> err <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	skb <span style="color:#f92672">=</span> <span style="color:#a6e22e">ip_finish_skb</span>(sk, fl4);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>skb)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> out;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	err <span style="color:#f92672">=</span> <span style="color:#a6e22e">udp_send_skb</span>(skb, fl4, <span style="color:#f92672">&amp;</span>inet<span style="color:#f92672">-&gt;</span>cork.base);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>out:
</span></span><span style="display:flex;"><span>	up<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	up<span style="color:#f92672">-&gt;</span>pending <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> err;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="3-recv运输层">3. recv(运输层)</h2>
<blockquote>
<p>大多数api在send中已经提及, 不再次讲解</p>
</blockquote>
<blockquote>
<p>__sys_recvfrom -&gt; sock_recvmsg -&gt; sock_recvmsg_nosec -&gt; inet_recvmsg -&gt; udp_recvmsg (层层封装)</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">__sys_recvfrom</span>(<span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>ubuf, <span style="color:#66d9ef">size_t</span> size, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> flags,
</span></span><span style="display:flex;"><span>		   <span style="color:#66d9ef">struct</span> sockaddr __user <span style="color:#f92672">*</span>addr, <span style="color:#66d9ef">int</span> __user <span style="color:#f92672">*</span>addr_len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	err <span style="color:#f92672">=</span> <span style="color:#a6e22e">sock_recvmsg</span>(sock, <span style="color:#f92672">&amp;</span>msg, flags);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (err <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> addr <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 将客户端地址返回给用户态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		err2 <span style="color:#f92672">=</span> <span style="color:#a6e22e">move_addr_to_user</span>(<span style="color:#f92672">&amp;</span>address,
</span></span><span style="display:flex;"><span>					 msg.msg_namelen, addr, addr_len);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (err2 <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			err <span style="color:#f92672">=</span> err2;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span></code></pre></div><h3 id="21-udp_recvmsg">2.1 udp_recvmsg</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">udp_recvmsg</span>(<span style="color:#66d9ef">struct</span> sock <span style="color:#f92672">*</span>sk, <span style="color:#66d9ef">struct</span> msghdr <span style="color:#f92672">*</span>msg, <span style="color:#66d9ef">size_t</span> len, <span style="color:#66d9ef">int</span> noblock,
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> flags, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>addr_len)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> inet_sock <span style="color:#f92672">*</span>inet <span style="color:#f92672">=</span> <span style="color:#a6e22e">inet_sk</span>(sk);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">DECLARE_SOCKADDR</span>(<span style="color:#66d9ef">struct</span> sockaddr_in <span style="color:#f92672">*</span>, sin, msg<span style="color:#f92672">-&gt;</span>msg_name);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> ulen, copied;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> off, err, peeking <span style="color:#f92672">=</span> flags <span style="color:#f92672">&amp;</span> MSG_PEEK;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> is_udplite <span style="color:#f92672">=</span> <span style="color:#a6e22e">IS_UDPLITE</span>(sk);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> checksum_valid <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 从socket错误队列接收错误信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (flags <span style="color:#f92672">&amp;</span> MSG_ERRQUEUE)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ip_recv_error</span>(sk, msg, len, addr_len);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>try_again:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// MSG_PEEK表示预读, 此处获得预读长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	off <span style="color:#f92672">=</span> <span style="color:#a6e22e">sk_peek_offset</span>(sk, flags);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 从缓存队列中获得skb, 详细见2.1.1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	skb <span style="color:#f92672">=</span> <span style="color:#a6e22e">__skb_recv_udp</span>(sk, flags, noblock, <span style="color:#f92672">&amp;</span>off, <span style="color:#f92672">&amp;</span>err);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>skb)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> err;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 获得skb内数据长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ulen <span style="color:#f92672">=</span> <span style="color:#a6e22e">udp_skb_len</span>(skb);
</span></span><span style="display:flex;"><span>	copied <span style="color:#f92672">=</span> len;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果待接收数据大于skb缓存数据, 截断输入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (copied <span style="color:#f92672">&gt;</span> ulen <span style="color:#f92672">-</span> off)
</span></span><span style="display:flex;"><span>		copied <span style="color:#f92672">=</span> ulen <span style="color:#f92672">-</span> off;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (copied <span style="color:#f92672">&lt;</span> ulen)
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 接收skb中所有数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		msg<span style="color:#f92672">-&gt;</span>msg_flags <span style="color:#f92672">|=</span> MSG_TRUNC;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * If checksum is needed at all, try to do it while copying the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * data.  If the data is truncated, or if we only want a partial
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * coverage checksum (UDP-Lite), do it before the copy.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// CHECKSUM_UNNECESSARY表示硬件已完成数据校验, 无需再次校验
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 待接收数据小于缓冲区数据&amp;开启预读机制&amp;开启udplite机制情况下如果skb需要进行校验则调用__udp_lib_checksum_complete进行校验
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (copied <span style="color:#f92672">&lt;</span> ulen <span style="color:#f92672">||</span> peeking <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>	    (is_udplite <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">UDP_SKB_CB</span>(skb)<span style="color:#f92672">-&gt;</span>partial_cov)) {
</span></span><span style="display:flex;"><span>		checksum_valid <span style="color:#f92672">=</span> <span style="color:#a6e22e">udp_skb_csum_unnecessary</span>(skb) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>				<span style="color:#f92672">!</span><span style="color:#a6e22e">__udp_lib_checksum_complete</span>(skb);
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 校验未通过丢弃数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>checksum_valid)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> csum_copy_err;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果校验成功或未开启校验则直接复制数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (checksum_valid <span style="color:#f92672">||</span> <span style="color:#a6e22e">udp_skb_csum_unnecessary</span>(skb)) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果skb中数据都存在线性区域直接调用copy_linear_skb, 否则使用skb_copy_datagram_msg
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">udp_skb_is_linear</span>(skb))
</span></span><span style="display:flex;"><span>			err <span style="color:#f92672">=</span> <span style="color:#a6e22e">copy_linear_skb</span>(skb, copied, off, <span style="color:#f92672">&amp;</span>msg<span style="color:#f92672">-&gt;</span>msg_iter);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			err <span style="color:#f92672">=</span> <span style="color:#a6e22e">skb_copy_datagram_msg</span>(skb, off, msg, copied);
</span></span><span style="display:flex;"><span>	} 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 此处代码对全部数据做校验
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 在复制数据时做完整性校验
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		err <span style="color:#f92672">=</span> <span style="color:#a6e22e">skb_copy_and_csum_datagram_msg</span>(skb, off, msg);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (err <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>EINVAL)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> csum_copy_err;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 发生错误释放skb, 直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(err)) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>peeking) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">atomic_inc</span>(<span style="color:#f92672">&amp;</span>sk<span style="color:#f92672">-&gt;</span>sk_drops);
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">UDP_INC_STATS</span>(<span style="color:#a6e22e">sock_net</span>(sk),
</span></span><span style="display:flex;"><span>				      UDP_MIB_INERRORS, is_udplite);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">kfree_skb</span>(skb);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> err;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>peeking)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">UDP_INC_STATS</span>(<span style="color:#a6e22e">sock_net</span>(sk),
</span></span><span style="display:flex;"><span>			      UDP_MIB_INDATAGRAMS, is_udplite);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sock_recv_ts_and_drops</span>(msg, sk, skb);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 根据skb填充客户端数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">/* Copy the address. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (sin) {
</span></span><span style="display:flex;"><span>		sin<span style="color:#f92672">-&gt;</span>sin_family <span style="color:#f92672">=</span> AF_INET;
</span></span><span style="display:flex;"><span>		sin<span style="color:#f92672">-&gt;</span>sin_port <span style="color:#f92672">=</span> <span style="color:#a6e22e">udp_hdr</span>(skb)<span style="color:#f92672">-&gt;</span>source;
</span></span><span style="display:flex;"><span>		sin<span style="color:#f92672">-&gt;</span>sin_addr.s_addr <span style="color:#f92672">=</span> <span style="color:#a6e22e">ip_hdr</span>(skb)<span style="color:#f92672">-&gt;</span>saddr;
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">memset</span>(sin<span style="color:#f92672">-&gt;</span>sin_zero, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(sin<span style="color:#f92672">-&gt;</span>sin_zero));
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>addr_len <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>sin);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 涉及bpf
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (cgroup_bpf_enabled)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">BPF_CGROUP_RUN_PROG_UDP4_RECVMSG_LOCK</span>(sk,
</span></span><span style="display:flex;"><span>							(<span style="color:#66d9ef">struct</span> sockaddr <span style="color:#f92672">*</span>)sin);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 解析控制信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">udp_sk</span>(sk)<span style="color:#f92672">-&gt;</span>gro_enabled)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">udp_cmsg_recv</span>(msg, sk, skb);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (inet<span style="color:#f92672">-&gt;</span>cmsg_flags)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ip_cmsg_recv_offset</span>(msg, sk, skb, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> udphdr), off);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	err <span style="color:#f92672">=</span> copied;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (flags <span style="color:#f92672">&amp;</span> MSG_TRUNC)
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果开启MSG_TRUNC, 会接收skb中全部数据（在用户缓冲区最大处截断）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		err <span style="color:#f92672">=</span> ulen;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">skb_consume_udp</span>(sk, skb, peeking <span style="color:#f92672">?</span> <span style="color:#f92672">-</span>err : err);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> err;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>csum_copy_err:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">__sk_queue_drop_skb</span>(sk, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">udp_sk</span>(sk)<span style="color:#f92672">-&gt;</span>reader_queue, skb, flags,
</span></span><span style="display:flex;"><span>				 udp_skb_destructor)) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">UDP_INC_STATS</span>(<span style="color:#a6e22e">sock_net</span>(sk), UDP_MIB_CSUMERRORS, is_udplite);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">UDP_INC_STATS</span>(<span style="color:#a6e22e">sock_net</span>(sk), UDP_MIB_INERRORS, is_udplite);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">kfree_skb</span>(skb);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* starting over for a new packet, but check if we need to yield */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cond_resched</span>();
</span></span><span style="display:flex;"><span>	msg<span style="color:#f92672">-&gt;</span>msg_flags <span style="color:#f92672">&amp;=</span> <span style="color:#f92672">~</span>MSG_TRUNC;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">goto</span> try_again;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="211-__skb_recv_udp">2.1.1 __skb_recv_udp</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span><span style="color:#a6e22e">__skb_recv_udp</span>(<span style="color:#66d9ef">struct</span> sock <span style="color:#f92672">*</span>sk, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> flags,
</span></span><span style="display:flex;"><span>			       <span style="color:#66d9ef">int</span> noblock, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>off, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>err)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sk_buff_head <span style="color:#f92672">*</span>sk_queue <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>sk<span style="color:#f92672">-&gt;</span>sk_receive_queue;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sk_buff_head <span style="color:#f92672">*</span>queue;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>last;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">long</span> timeo;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> error;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 获得缓存队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	queue <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">udp_sk</span>(sk)<span style="color:#f92672">-&gt;</span>reader_queue;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 确定是否为非阻塞IO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	flags <span style="color:#f92672">|=</span> noblock <span style="color:#f92672">?</span> MSG_DONTWAIT : <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 返回阻塞IO时间戳
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	timeo <span style="color:#f92672">=</span> <span style="color:#a6e22e">sock_rcvtimeo</span>(sk, flags <span style="color:#f92672">&amp;</span> MSG_DONTWAIT);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 清空错误报告
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		error <span style="color:#f92672">=</span> <span style="color:#a6e22e">sock_error</span>(sk);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (error)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		error <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EAGAIN;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 禁止CPU软中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">spin_lock_bh</span>(<span style="color:#f92672">&amp;</span>queue<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 尝试获得skb, 详细见2.1.1.1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			skb <span style="color:#f92672">=</span> <span style="color:#a6e22e">__skb_try_recv_from_queue</span>(sk, queue, flags,
</span></span><span style="display:flex;"><span>							udp_skb_destructor,
</span></span><span style="display:flex;"><span>							off, err, <span style="color:#f92672">&amp;</span>last);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (skb) {
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// 获得skb后开启软中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#a6e22e">spin_unlock_bh</span>(<span style="color:#f92672">&amp;</span>queue<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> skb;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 获取skb失败后, 无锁判断sock接收队列是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">skb_queue_empty_lockless</span>(sk_queue)) {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">spin_unlock_bh</span>(<span style="color:#f92672">&amp;</span>queue<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">goto</span> busy_check;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">/* refill the reader queue and walk it again
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 * keep both queues locked to avoid re-acquiring
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 * the sk_receive_queue lock if fwd memory scheduling
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 * is needed.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 */</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">spin_lock</span>(<span style="color:#f92672">&amp;</span>sk_queue<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 链接sk_queue进入queue
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">skb_queue_splice_tail_init</span>(sk_queue, queue);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 再次尝试获取skb
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			skb <span style="color:#f92672">=</span> <span style="color:#a6e22e">__skb_try_recv_from_queue</span>(sk, queue, flags,
</span></span><span style="display:flex;"><span>							udp_skb_dtor_locked,
</span></span><span style="display:flex;"><span>							off, err, <span style="color:#f92672">&amp;</span>last);
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">spin_unlock</span>(<span style="color:#f92672">&amp;</span>sk_queue<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">spin_unlock_bh</span>(<span style="color:#f92672">&amp;</span>queue<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (skb)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> skb;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>busy_check:
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">sk_can_busy_loop</span>(sk))
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">sk_busy_loop</span>(sk, flags <span style="color:#f92672">&amp;</span> MSG_DONTWAIT);
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">skb_queue_empty_lockless</span>(sk_queue));
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 直到sk_queue为空, 跳出循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* sk_queue is empty, reader_queue may contain peeked packets */</span>
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">while</span> (timeo <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>		 <span style="color:#f92672">!</span><span style="color:#a6e22e">__skb_wait_for_more_packets</span>(sk, <span style="color:#f92672">&amp;</span>error, <span style="color:#f92672">&amp;</span>timeo,
</span></span><span style="display:flex;"><span>					      (<span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>)sk_queue));
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果sock接收队列sk_queue为空, 且需要等待, 在此处等待
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>err <span style="color:#f92672">=</span> error;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="2111-__skb_try_recv_from_queue">2.1.1.1 __skb_try_recv_from_queue</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span><span style="color:#a6e22e">__skb_try_recv_from_queue</span>(<span style="color:#66d9ef">struct</span> sock <span style="color:#f92672">*</span>sk,
</span></span><span style="display:flex;"><span>					  <span style="color:#66d9ef">struct</span> sk_buff_head <span style="color:#f92672">*</span>queue,
</span></span><span style="display:flex;"><span>					  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> flags,
</span></span><span style="display:flex;"><span>					  <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>destructor)(<span style="color:#66d9ef">struct</span> sock <span style="color:#f92672">*</span>sk,
</span></span><span style="display:flex;"><span>							   <span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb),
</span></span><span style="display:flex;"><span>					  <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>off, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>err,
</span></span><span style="display:flex;"><span>					  <span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">**</span>last)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> peek_at_off <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> _off <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(flags <span style="color:#f92672">&amp;</span> MSG_PEEK <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">*</span>off <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>)) {
</span></span><span style="display:flex;"><span>		peek_at_off <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>		_off <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>off;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>last <span style="color:#f92672">=</span> queue<span style="color:#f92672">-&gt;</span>prev;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 遍历队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">skb_queue_walk</span>(queue, skb) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (flags <span style="color:#f92672">&amp;</span> MSG_PEEK) {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 如果预读的字节数大于skb数据长度, 则更新待预读字节数且更换skb
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (peek_at_off <span style="color:#f92672">&amp;&amp;</span> _off <span style="color:#f92672">&gt;=</span> skb<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>			    (_off <span style="color:#f92672">||</span> skb<span style="color:#f92672">-&gt;</span>peeked)) {
</span></span><span style="display:flex;"><span>				_off <span style="color:#f92672">-=</span> skb<span style="color:#f92672">-&gt;</span>len;
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// skb非空, 设置为预读模式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>skb<span style="color:#f92672">-&gt;</span>len) {
</span></span><span style="display:flex;"><span>				skb <span style="color:#f92672">=</span> <span style="color:#a6e22e">skb_set_peeked</span>(skb);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">IS_ERR</span>(skb)) {
</span></span><span style="display:flex;"><span>					<span style="color:#f92672">*</span>err <span style="color:#f92672">=</span> <span style="color:#a6e22e">PTR_ERR</span>(skb);
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">refcount_inc</span>(<span style="color:#f92672">&amp;</span>skb<span style="color:#f92672">-&gt;</span>users);
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 将skb从队列中取出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">__skb_unlink</span>(skb, queue);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 如果定义了销毁函数则调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (destructor)
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">destructor</span>(sk, skb);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>off <span style="color:#f92672">=</span> _off;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> skb;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="4-ip网络层">4. IP(网络层)</h2>
<h3 id="41-ip_cmsg_send">4.1 ip_cmsg_send</h3>
<ul>
<li>将cmsg中的控制信息, 保存至ipc(可以根据控制信息, 自定义socket和ip层面配置)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ip_cmsg_send</span>(<span style="color:#66d9ef">struct</span> sock <span style="color:#f92672">*</span>sk, <span style="color:#66d9ef">struct</span> msghdr <span style="color:#f92672">*</span>msg, <span style="color:#66d9ef">struct</span> ipcm_cookie <span style="color:#f92672">*</span>ipc,
</span></span><span style="display:flex;"><span>		 <span style="color:#66d9ef">bool</span> allow_ipv6)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> err, val;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> cmsghdr <span style="color:#f92672">*</span>cmsg;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> net <span style="color:#f92672">*</span>net <span style="color:#f92672">=</span> <span style="color:#a6e22e">sock_net</span>(sk);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">for_each_cmsghdr</span>(cmsg, msg) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">CMSG_OK</span>(msg, cmsg))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (cmsg<span style="color:#f92672">-&gt;</span>cmsg_level <span style="color:#f92672">==</span> SOL_SOCKET) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 修改socket层面的配置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			err <span style="color:#f92672">=</span> <span style="color:#a6e22e">__sock_cmsg_send</span>(sk, msg, cmsg, <span style="color:#f92672">&amp;</span>ipc<span style="color:#f92672">-&gt;</span>sockc);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (err)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> err;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (cmsg<span style="color:#f92672">-&gt;</span>cmsg_level <span style="color:#f92672">!=</span> SOL_IP)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">switch</span> (cmsg<span style="color:#f92672">-&gt;</span>cmsg_type) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> IP_RETOPTS:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 获得ip选项
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			err <span style="color:#f92672">=</span> cmsg<span style="color:#f92672">-&gt;</span>cmsg_len <span style="color:#f92672">-</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> cmsghdr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">/* Our caller is responsible for freeing ipc-&gt;opt */</span>
</span></span><span style="display:flex;"><span>			err <span style="color:#f92672">=</span> <span style="color:#a6e22e">ip_options_get</span>(net, <span style="color:#f92672">&amp;</span>ipc<span style="color:#f92672">-&gt;</span>opt, <span style="color:#a6e22e">CMSG_DATA</span>(cmsg),
</span></span><span style="display:flex;"><span>					     err <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">40</span> <span style="color:#f92672">?</span> err : <span style="color:#ae81ff">40</span>);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (err)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> err;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> IP_PKTINFO:
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 通过控制信息修改源ip
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">struct</span> in_pktinfo <span style="color:#f92672">*</span>info;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (cmsg<span style="color:#f92672">-&gt;</span>cmsg_len <span style="color:#f92672">!=</span> <span style="color:#a6e22e">CMSG_LEN</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> in_pktinfo)))
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>			info <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> in_pktinfo <span style="color:#f92672">*</span>)<span style="color:#a6e22e">CMSG_DATA</span>(cmsg);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (info<span style="color:#f92672">-&gt;</span>ipi_ifindex)
</span></span><span style="display:flex;"><span>				ipc<span style="color:#f92672">-&gt;</span>oif <span style="color:#f92672">=</span> info<span style="color:#f92672">-&gt;</span>ipi_ifindex;
</span></span><span style="display:flex;"><span>			ipc<span style="color:#f92672">-&gt;</span>addr <span style="color:#f92672">=</span> info<span style="color:#f92672">-&gt;</span>ipi_spec_dst.s_addr;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> IP_TTL:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 自定义TTL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (cmsg<span style="color:#f92672">-&gt;</span>cmsg_len <span style="color:#f92672">!=</span> <span style="color:#a6e22e">CMSG_LEN</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>)))
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>			val <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)<span style="color:#a6e22e">CMSG_DATA</span>(cmsg);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (val <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> val <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">255</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>			ipc<span style="color:#f92672">-&gt;</span>ttl <span style="color:#f92672">=</span> val;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> IP_TOS:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 自定义TOS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (cmsg<span style="color:#f92672">-&gt;</span>cmsg_len <span style="color:#f92672">==</span> <span style="color:#a6e22e">CMSG_LEN</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>)))
</span></span><span style="display:flex;"><span>				val <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)<span style="color:#a6e22e">CMSG_DATA</span>(cmsg);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (cmsg<span style="color:#f92672">-&gt;</span>cmsg_len <span style="color:#f92672">==</span> <span style="color:#a6e22e">CMSG_LEN</span>(<span style="color:#66d9ef">sizeof</span>(u8)))
</span></span><span style="display:flex;"><span>				val <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(u8 <span style="color:#f92672">*</span>)<span style="color:#a6e22e">CMSG_DATA</span>(cmsg);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (val <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> val <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">255</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>			ipc<span style="color:#f92672">-&gt;</span>tos <span style="color:#f92672">=</span> val;
</span></span><span style="display:flex;"><span>			ipc<span style="color:#f92672">-&gt;</span>priority <span style="color:#f92672">=</span> <span style="color:#a6e22e">rt_tos2priority</span>(ipc<span style="color:#f92672">-&gt;</span>tos);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="42-ip_make_skb">4.2 ip_make_skb</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>truct sk_buff <span style="color:#f92672">*</span><span style="color:#a6e22e">ip_make_skb</span>(<span style="color:#66d9ef">struct</span> sock <span style="color:#f92672">*</span>sk,
</span></span><span style="display:flex;"><span>			    <span style="color:#66d9ef">struct</span> flowi4 <span style="color:#f92672">*</span>fl4,
</span></span><span style="display:flex;"><span>			    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getfrag</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>from, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>to, <span style="color:#66d9ef">int</span> offset,
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">int</span> len, <span style="color:#66d9ef">int</span> odd, <span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb),
</span></span><span style="display:flex;"><span>			    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>from, <span style="color:#66d9ef">int</span> length, <span style="color:#66d9ef">int</span> transhdrlen,
</span></span><span style="display:flex;"><span>			    <span style="color:#66d9ef">struct</span> ipcm_cookie <span style="color:#f92672">*</span>ipc, <span style="color:#66d9ef">struct</span> rtable <span style="color:#f92672">**</span>rtp,
</span></span><span style="display:flex;"><span>			    <span style="color:#66d9ef">struct</span> inet_cork <span style="color:#f92672">*</span>cork, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	struct sk_buff_head {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		/* These two members must be first. */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> sk_buff	<span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> sk_buff	<span style="color:#f92672">*</span>prev;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		__u32		qlen;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">spinlock_t</span>	lock;
</span></span><span style="display:flex;"><span>	};	
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sk_buff_head queue;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> err;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 路径探测数据包不传输数据, 直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (flags <span style="color:#f92672">&amp;</span> MSG_PROBE)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 创建空闲队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">__skb_queue_head_init</span>(<span style="color:#f92672">&amp;</span>queue);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 伪造cork
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cork<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	cork<span style="color:#f92672">-&gt;</span>addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	cork<span style="color:#f92672">-&gt;</span>opt <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 初始化cork, 见4.2.1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	err <span style="color:#f92672">=</span> <span style="color:#a6e22e">ip_setup_cork</span>(sk, cork, ipc, rtp);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (err)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ERR_PTR</span>(err);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 使用队列保存skb, skb组织待传输数据, 详细见4.3.1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	err <span style="color:#f92672">=</span> <span style="color:#a6e22e">__ip_append_data</span>(sk, fl4, <span style="color:#f92672">&amp;</span>queue, cork,
</span></span><span style="display:flex;"><span>			       <span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>task_frag, getfrag,
</span></span><span style="display:flex;"><span>			       from, length, transhdrlen, flags);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (err) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">__ip_flush_pending_frames</span>(sk, <span style="color:#f92672">&amp;</span>queue, cork);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ERR_PTR</span>(err);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 取出队列中的skb, 设置ip选项, 并链接, 返回一个skb, 详细见4.2.2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">__ip_make_skb</span>(sk, fl4, <span style="color:#f92672">&amp;</span>queue, cork);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="421-ip_setup_cork">4.2.1 ip_setup_cork</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ip_setup_cork</span>(<span style="color:#66d9ef">struct</span> sock <span style="color:#f92672">*</span>sk, <span style="color:#66d9ef">struct</span> inet_cork <span style="color:#f92672">*</span>cork,
</span></span><span style="display:flex;"><span>			 <span style="color:#66d9ef">struct</span> ipcm_cookie <span style="color:#f92672">*</span>ipc, <span style="color:#66d9ef">struct</span> rtable <span style="color:#f92672">**</span>rtp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> ip_options_rcu <span style="color:#f92672">*</span>opt;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rtable <span style="color:#f92672">*</span>rt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	rt <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>rtp;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span>rt))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EFAULT;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * setup for corking.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	opt <span style="color:#f92672">=</span> ipc<span style="color:#f92672">-&gt;</span>opt;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (opt) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>cork<span style="color:#f92672">-&gt;</span>opt) {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 为cork-&gt;opt分配空间, 最大容纳sizeof(struct ip_options) + 40 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			cork<span style="color:#f92672">-&gt;</span>opt <span style="color:#f92672">=</span> <span style="color:#a6e22e">kmalloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> ip_options) <span style="color:#f92672">+</span> <span style="color:#ae81ff">40</span>,
</span></span><span style="display:flex;"><span>					    sk<span style="color:#f92672">-&gt;</span>sk_allocation);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span>cork<span style="color:#f92672">-&gt;</span>opt))
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOBUFS;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 缓存opt至cork-&gt;opt
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">memcpy</span>(cork<span style="color:#f92672">-&gt;</span>opt, <span style="color:#f92672">&amp;</span>opt<span style="color:#f92672">-&gt;</span>opt, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> ip_options) <span style="color:#f92672">+</span> opt<span style="color:#f92672">-&gt;</span>opt.optlen);
</span></span><span style="display:flex;"><span>		cork<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">|=</span> IPCORK_OPT;
</span></span><span style="display:flex;"><span>		cork<span style="color:#f92672">-&gt;</span>addr <span style="color:#f92672">=</span> ipc<span style="color:#f92672">-&gt;</span>addr;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 设置报文分段长度, 开启pmtu探测时调用dst-&gt;ops-&gt;mtu(dst)获得mtu, 否则从网络设备获得mtu
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cork<span style="color:#f92672">-&gt;</span>fragsize <span style="color:#f92672">=</span> <span style="color:#a6e22e">ip_sk_use_pmtu</span>(sk) <span style="color:#f92672">?</span>
</span></span><span style="display:flex;"><span>			 <span style="color:#a6e22e">dst_mtu</span>(<span style="color:#f92672">&amp;</span>rt<span style="color:#f92672">-&gt;</span>dst) <span style="color:#f92672">:</span> <span style="color:#a6e22e">READ_ONCE</span>(rt<span style="color:#f92672">-&gt;</span>dst.dev<span style="color:#f92672">-&gt;</span>mtu);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// mtu &gt;= IPV4_MIN_MTU
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">inetdev_valid_mtu</span>(cork<span style="color:#f92672">-&gt;</span>fragsize))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENETUNREACH;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	cork<span style="color:#f92672">-&gt;</span>gso_size <span style="color:#f92672">=</span> ipc<span style="color:#f92672">-&gt;</span>gso_size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 设置路由
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cork<span style="color:#f92672">-&gt;</span>dst <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>rt<span style="color:#f92672">-&gt;</span>dst;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* We stole this route, caller should not release it. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>rtp <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 基础配置, cork最终会拿到所有ip配置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// cork-&gt;length表示skb已包含数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cork<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	cork<span style="color:#f92672">-&gt;</span>ttl <span style="color:#f92672">=</span> ipc<span style="color:#f92672">-&gt;</span>ttl;
</span></span><span style="display:flex;"><span>	cork<span style="color:#f92672">-&gt;</span>tos <span style="color:#f92672">=</span> ipc<span style="color:#f92672">-&gt;</span>tos;
</span></span><span style="display:flex;"><span>	cork<span style="color:#f92672">-&gt;</span>mark <span style="color:#f92672">=</span> ipc<span style="color:#f92672">-&gt;</span>sockc.mark;
</span></span><span style="display:flex;"><span>	cork<span style="color:#f92672">-&gt;</span>priority <span style="color:#f92672">=</span> ipc<span style="color:#f92672">-&gt;</span>priority;
</span></span><span style="display:flex;"><span>	cork<span style="color:#f92672">-&gt;</span>transmit_time <span style="color:#f92672">=</span> ipc<span style="color:#f92672">-&gt;</span>sockc.transmit_time;
</span></span><span style="display:flex;"><span>	cork<span style="color:#f92672">-&gt;</span>tx_flags <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sock_tx_timestamp</span>(sk, ipc<span style="color:#f92672">-&gt;</span>sockc.tsflags, <span style="color:#f92672">&amp;</span>cork<span style="color:#f92672">-&gt;</span>tx_flags);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="422-__ip_make_skb">4.2.2 __ip_make_skb</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span><span style="color:#a6e22e">__ip_make_skb</span>(<span style="color:#66d9ef">struct</span> sock <span style="color:#f92672">*</span>sk,
</span></span><span style="display:flex;"><span>			      <span style="color:#66d9ef">struct</span> flowi4 <span style="color:#f92672">*</span>fl4,
</span></span><span style="display:flex;"><span>			      <span style="color:#66d9ef">struct</span> sk_buff_head <span style="color:#f92672">*</span>queue,
</span></span><span style="display:flex;"><span>			      <span style="color:#66d9ef">struct</span> inet_cork <span style="color:#f92672">*</span>cork)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb, <span style="color:#f92672">*</span>tmp_skb;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">**</span>tail_skb;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> inet_sock <span style="color:#f92672">*</span>inet <span style="color:#f92672">=</span> <span style="color:#a6e22e">inet_sk</span>(sk);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> net <span style="color:#f92672">*</span>net <span style="color:#f92672">=</span> <span style="color:#a6e22e">sock_net</span>(sk);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> ip_options <span style="color:#f92672">*</span>opt <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rtable <span style="color:#f92672">*</span>rt <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> rtable <span style="color:#f92672">*</span>)cork<span style="color:#f92672">-&gt;</span>dst;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> iphdr <span style="color:#f92672">*</span>iph;
</span></span><span style="display:flex;"><span>	__be16 df <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	__u8 ttl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 取出第一个skb
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	skb <span style="color:#f92672">=</span> <span style="color:#a6e22e">__skb_dequeue</span>(queue);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>skb)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> out;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 定位skb非线性区域
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	tail_skb <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>(<span style="color:#a6e22e">skb_shinfo</span>(skb)<span style="color:#f92672">-&gt;</span>frag_list);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* move skb-&gt;data to ip header from ext header */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 更新skb-&gt;data指向ip头
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (skb<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">skb_network_header</span>(skb))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">__skb_pull</span>(skb, <span style="color:#a6e22e">skb_network_offset</span>(skb));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 依次取出skb, 使用skb_shinfo(skb)-&gt;frag_list作为指针将所有skb链接起来, 同时由链表头skb统计数据长度信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> ((tmp_skb <span style="color:#f92672">=</span> <span style="color:#a6e22e">__skb_dequeue</span>(queue)) <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">__skb_pull</span>(tmp_skb, <span style="color:#a6e22e">skb_network_header_len</span>(skb));
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>tail_skb <span style="color:#f92672">=</span> tmp_skb;
</span></span><span style="display:flex;"><span>		tail_skb <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>(tmp_skb<span style="color:#f92672">-&gt;</span>next);
</span></span><span style="display:flex;"><span>		skb<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">+=</span> tmp_skb<span style="color:#f92672">-&gt;</span>len;
</span></span><span style="display:flex;"><span>		skb<span style="color:#f92672">-&gt;</span>data_len <span style="color:#f92672">+=</span> tmp_skb<span style="color:#f92672">-&gt;</span>len;
</span></span><span style="display:flex;"><span>		skb<span style="color:#f92672">-&gt;</span>truesize <span style="color:#f92672">+=</span> tmp_skb<span style="color:#f92672">-&gt;</span>truesize;
</span></span><span style="display:flex;"><span>		tmp_skb<span style="color:#f92672">-&gt;</span>destructor <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>		tmp_skb<span style="color:#f92672">-&gt;</span>sk <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Unless user demanded real pmtu discovery (IP_PMTUDISC_DO), we allow
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * to fragment the frame generated here. No matter, what transforms
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * how transforms change size of the packet, it will come out.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 设置是否开启动态mtu探测
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	skb<span style="color:#f92672">-&gt;</span>ignore_df <span style="color:#f92672">=</span> <span style="color:#a6e22e">ip_sk_ignore_df</span>(sk);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* DF bit is set when we want to see DF on outgoing frames.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * If ignore_df is set too, we still allow to fragment this frame
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * locally. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (inet<span style="color:#f92672">-&gt;</span>pmtudisc <span style="color:#f92672">==</span> IP_PMTUDISC_DO <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>	    inet<span style="color:#f92672">-&gt;</span>pmtudisc <span style="color:#f92672">==</span> IP_PMTUDISC_PROBE <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>	    (skb<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">dst_mtu</span>(<span style="color:#f92672">&amp;</span>rt<span style="color:#f92672">-&gt;</span>dst) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>	     <span style="color:#a6e22e">ip_dont_fragment</span>(sk, <span style="color:#f92672">&amp;</span>rt<span style="color:#f92672">-&gt;</span>dst)))
</span></span><span style="display:flex;"><span>		df <span style="color:#f92672">=</span> <span style="color:#a6e22e">htons</span>(IP_DF);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (cork<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> IPCORK_OPT)
</span></span><span style="display:flex;"><span>		opt <span style="color:#f92672">=</span> cork<span style="color:#f92672">-&gt;</span>opt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (cork<span style="color:#f92672">-&gt;</span>ttl <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		ttl <span style="color:#f92672">=</span> cork<span style="color:#f92672">-&gt;</span>ttl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (rt<span style="color:#f92672">-&gt;</span>rt_type <span style="color:#f92672">==</span> RTN_MULTICAST)
</span></span><span style="display:flex;"><span>		ttl <span style="color:#f92672">=</span> inet<span style="color:#f92672">-&gt;</span>mc_ttl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		ttl <span style="color:#f92672">=</span> <span style="color:#a6e22e">ip_select_ttl</span>(inet, <span style="color:#f92672">&amp;</span>rt<span style="color:#f92672">-&gt;</span>dst);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 填充skb线性区域的ip头信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	iph <span style="color:#f92672">=</span> <span style="color:#a6e22e">ip_hdr</span>(skb);
</span></span><span style="display:flex;"><span>	iph<span style="color:#f92672">-&gt;</span>version <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>	iph<span style="color:#f92672">-&gt;</span>ihl <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>	iph<span style="color:#f92672">-&gt;</span>tos <span style="color:#f92672">=</span> (cork<span style="color:#f92672">-&gt;</span>tos <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">?</span> cork<span style="color:#f92672">-&gt;</span>tos : inet<span style="color:#f92672">-&gt;</span>tos;
</span></span><span style="display:flex;"><span>	iph<span style="color:#f92672">-&gt;</span>frag_off <span style="color:#f92672">=</span> df;
</span></span><span style="display:flex;"><span>	iph<span style="color:#f92672">-&gt;</span>ttl <span style="color:#f92672">=</span> ttl;
</span></span><span style="display:flex;"><span>	iph<span style="color:#f92672">-&gt;</span>protocol <span style="color:#f92672">=</span> sk<span style="color:#f92672">-&gt;</span>sk_protocol;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ip_copy_addrs</span>(iph, fl4);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ip_select_ident</span>(net, skb, sk);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (opt) {
</span></span><span style="display:flex;"><span>		iph<span style="color:#f92672">-&gt;</span>ihl <span style="color:#f92672">+=</span> opt<span style="color:#f92672">-&gt;</span>optlen<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ip_options_build</span>(skb, opt, cork<span style="color:#f92672">-&gt;</span>addr, rt, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	skb<span style="color:#f92672">-&gt;</span>priority <span style="color:#f92672">=</span> (cork<span style="color:#f92672">-&gt;</span>tos <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">?</span> cork<span style="color:#f92672">-&gt;</span>priority: sk<span style="color:#f92672">-&gt;</span>sk_priority;
</span></span><span style="display:flex;"><span>	skb<span style="color:#f92672">-&gt;</span>mark <span style="color:#f92672">=</span> cork<span style="color:#f92672">-&gt;</span>mark;
</span></span><span style="display:flex;"><span>	skb<span style="color:#f92672">-&gt;</span>tstamp <span style="color:#f92672">=</span> cork<span style="color:#f92672">-&gt;</span>transmit_time;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Steal rt from cork.dst to avoid a pair of atomic_inc/atomic_dec
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * on dst refcount
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	cork<span style="color:#f92672">-&gt;</span>dst <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">skb_dst_set</span>(skb, <span style="color:#f92672">&amp;</span>rt<span style="color:#f92672">-&gt;</span>dst);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (iph<span style="color:#f92672">-&gt;</span>protocol <span style="color:#f92672">==</span> IPPROTO_ICMP)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">icmp_out_count</span>(net, ((<span style="color:#66d9ef">struct</span> icmphdr <span style="color:#f92672">*</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">skb_transport_header</span>(skb))<span style="color:#f92672">-&gt;</span>type);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ip_cork_release</span>(cork);
</span></span><span style="display:flex;"><span>out:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> skb;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="43-ip_append_data">4.3 ip_append_data</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ip_append_data</span>(<span style="color:#66d9ef">struct</span> sock <span style="color:#f92672">*</span>sk, <span style="color:#66d9ef">struct</span> flowi4 <span style="color:#f92672">*</span>fl4,
</span></span><span style="display:flex;"><span>		   <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getfrag</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>from, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>to, <span style="color:#66d9ef">int</span> offset, <span style="color:#66d9ef">int</span> len,
</span></span><span style="display:flex;"><span>			       <span style="color:#66d9ef">int</span> odd, <span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb),
</span></span><span style="display:flex;"><span>		   <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>from, <span style="color:#66d9ef">int</span> length, <span style="color:#66d9ef">int</span> transhdrlen,
</span></span><span style="display:flex;"><span>		   <span style="color:#66d9ef">struct</span> ipcm_cookie <span style="color:#f92672">*</span>ipc, <span style="color:#66d9ef">struct</span> rtable <span style="color:#f92672">**</span>rtp,
</span></span><span style="display:flex;"><span>		   <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> inet_sock <span style="color:#f92672">*</span>inet <span style="color:#f92672">=</span> <span style="color:#a6e22e">inet_sk</span>(sk);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> err;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 忽略探测包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (flags<span style="color:#f92672">&amp;</span>MSG_PROBE)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 队列为空时, 初始化cork
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">skb_queue_empty</span>(<span style="color:#f92672">&amp;</span>sk<span style="color:#f92672">-&gt;</span>sk_write_queue)) {
</span></span><span style="display:flex;"><span>		err <span style="color:#f92672">=</span> <span style="color:#a6e22e">ip_setup_cork</span>(sk, <span style="color:#f92672">&amp;</span>inet<span style="color:#f92672">-&gt;</span>cork.base, ipc, rtp);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (err)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> err;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		transhdrlen <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">__ip_append_data</span>(sk, fl4, <span style="color:#f92672">&amp;</span>sk<span style="color:#f92672">-&gt;</span>sk_write_queue, <span style="color:#f92672">&amp;</span>inet<span style="color:#f92672">-&gt;</span>cork.base,
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">sk_page_frag</span>(sk), getfrag,
</span></span><span style="display:flex;"><span>				from, length, transhdrlen, flags);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="431-__ip_append_data">4.3.1 __ip_append_data</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">__ip_append_data</span>(<span style="color:#66d9ef">struct</span> sock <span style="color:#f92672">*</span>sk,
</span></span><span style="display:flex;"><span>			    <span style="color:#66d9ef">struct</span> flowi4 <span style="color:#f92672">*</span>fl4,
</span></span><span style="display:flex;"><span>			    <span style="color:#66d9ef">struct</span> sk_buff_head <span style="color:#f92672">*</span>queue,
</span></span><span style="display:flex;"><span>			    <span style="color:#66d9ef">struct</span> inet_cork <span style="color:#f92672">*</span>cork,
</span></span><span style="display:flex;"><span>			    <span style="color:#66d9ef">struct</span> page_frag <span style="color:#f92672">*</span>pfrag,
</span></span><span style="display:flex;"><span>			    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getfrag</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>from, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>to, <span style="color:#66d9ef">int</span> offset,
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">int</span> len, <span style="color:#66d9ef">int</span> odd, <span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb),
</span></span><span style="display:flex;"><span>			    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>from, <span style="color:#66d9ef">int</span> length, <span style="color:#66d9ef">int</span> transhdrlen,
</span></span><span style="display:flex;"><span>			    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> inet_sock <span style="color:#f92672">*</span>inet <span style="color:#f92672">=</span> <span style="color:#a6e22e">inet_sk</span>(sk);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> ubuf_info <span style="color:#f92672">*</span>uarg <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> ip_options <span style="color:#f92672">*</span>opt <span style="color:#f92672">=</span> cork<span style="color:#f92672">-&gt;</span>opt;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> hh_len;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> exthdrlen;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> mtu;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> copy;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> err;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> maxfraglen, fragheaderlen, maxnonfragsize;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> csummode <span style="color:#f92672">=</span> CHECKSUM_NONE;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rtable <span style="color:#f92672">*</span>rt <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> rtable <span style="color:#f92672">*</span>)cork<span style="color:#f92672">-&gt;</span>dst;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> wmem_alloc_delta <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> paged, extra_uref <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>	u32 tskey <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 取出队列尾部的skb(这个skb有可能存在部分空闲缓冲区, 可以继续保存数据)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	skb <span style="color:#f92672">=</span> <span style="color:#a6e22e">skb_peek_tail</span>(queue);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// skb为空(第一个skb), rt-&gt;dst.header_len为拓展头长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	exthdrlen <span style="color:#f92672">=</span> <span style="color:#f92672">!</span>skb <span style="color:#f92672">?</span> rt<span style="color:#f92672">-&gt;</span>dst.header_len : <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果开启GSO机制, mtu可直接取最大值, 否则取最大报文分段长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	mtu <span style="color:#f92672">=</span> cork<span style="color:#f92672">-&gt;</span>gso_size <span style="color:#f92672">?</span> IP_MAX_MTU : cork<span style="color:#f92672">-&gt;</span>fragsize;
</span></span><span style="display:flex;"><span>	paged <span style="color:#f92672">=</span> <span style="color:#f92672">!!</span>cork<span style="color:#f92672">-&gt;</span>gso_size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (cork<span style="color:#f92672">-&gt;</span>tx_flags <span style="color:#f92672">&amp;</span> SKBTX_ANY_SW_TSTAMP <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>	    sk<span style="color:#f92672">-&gt;</span>sk_tsflags <span style="color:#f92672">&amp;</span> SOF_TIMESTAMPING_OPT_ID)
</span></span><span style="display:flex;"><span>		tskey <span style="color:#f92672">=</span> sk<span style="color:#f92672">-&gt;</span>sk_tskey<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 为L2层保留首部长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	hh_len <span style="color:#f92672">=</span> <span style="color:#a6e22e">LL_RESERVED_SPACE</span>(rt<span style="color:#f92672">-&gt;</span>dst.dev);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// udp头部 + ip选项
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	fragheaderlen <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> iphdr) <span style="color:#f92672">+</span> (opt <span style="color:#f92672">?</span> opt<span style="color:#f92672">-&gt;</span>optlen : <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// payload部分需要8字节对齐
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	maxfraglen <span style="color:#f92672">=</span> ((mtu <span style="color:#f92672">-</span> fragheaderlen) <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span><span style="color:#ae81ff">7</span>) <span style="color:#f92672">+</span> fragheaderlen;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 检查是否设置DF标志(动态mtu探测), 没有开启mtu探测可直接传输最大0xffff字节数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	maxnonfragsize <span style="color:#f92672">=</span> <span style="color:#a6e22e">ip_sk_ignore_df</span>(sk) <span style="color:#f92672">?</span> <span style="color:#ae81ff">0xFFFF</span> <span style="color:#f92672">:</span> mtu;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果传输数据超过maxnonfragsize, 则报错退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (cork<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">+</span> length <span style="color:#f92672">&gt;</span> maxnonfragsize <span style="color:#f92672">-</span> fragheaderlen) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ip_local_error</span>(sk, EMSGSIZE, fl4<span style="color:#f92672">-&gt;</span>daddr, inet<span style="color:#f92672">-&gt;</span>inet_dport,
</span></span><span style="display:flex;"><span>			       mtu <span style="color:#f92672">-</span> (opt <span style="color:#f92672">?</span> opt<span style="color:#f92672">-&gt;</span>optlen : <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EMSGSIZE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * transhdrlen &gt; 0 means that this is the first fragment and we wish
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * it won&#39;t be fragmented in the future.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 发送第一个报文&amp;报文长度小于mtu&amp;存在硬件校验(支持全部包校验or校验ipv4协议中的tcp/udp)&amp;非阻塞IO or开启GSO&amp;没有拓展头部or支持ESP硬件分片, 开启硬件校验
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (transhdrlen <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>	    length <span style="color:#f92672">+</span> fragheaderlen <span style="color:#f92672">&lt;=</span> mtu <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>	    rt<span style="color:#f92672">-&gt;</span>dst.dev<span style="color:#f92672">-&gt;</span>features <span style="color:#f92672">&amp;</span> (NETIF_F_HW_CSUM <span style="color:#f92672">|</span> NETIF_F_IP_CSUM) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>	    (<span style="color:#f92672">!</span>(flags <span style="color:#f92672">&amp;</span> MSG_MORE) <span style="color:#f92672">||</span> cork<span style="color:#f92672">-&gt;</span>gso_size) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>	    (<span style="color:#f92672">!</span>exthdrlen <span style="color:#f92672">||</span> (rt<span style="color:#f92672">-&gt;</span>dst.dev<span style="color:#f92672">-&gt;</span>features <span style="color:#f92672">&amp;</span> NETIF_F_HW_ESP_TX_CSUM)))
</span></span><span style="display:flex;"><span>		csummode <span style="color:#f92672">=</span> CHECKSUM_PARTIAL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 零拷贝机制, 可以提升大块数据收发速度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (flags <span style="color:#f92672">&amp;</span> MSG_ZEROCOPY <span style="color:#f92672">&amp;&amp;</span> length <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">sock_flag</span>(sk, SOCK_ZEROCOPY)) {
</span></span><span style="display:flex;"><span>		uarg <span style="color:#f92672">=</span> <span style="color:#a6e22e">sock_zerocopy_realloc</span>(sk, length, <span style="color:#a6e22e">skb_zcopy</span>(skb));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>uarg)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOBUFS;
</span></span><span style="display:flex;"><span>		extra_uref <span style="color:#f92672">=</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">skb_zcopy</span>(skb);	<span style="color:#75715e">/* only ref on new uarg */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (rt<span style="color:#f92672">-&gt;</span>dst.dev<span style="color:#f92672">-&gt;</span>features <span style="color:#f92672">&amp;</span> NETIF_F_SG <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>		    csummode <span style="color:#f92672">==</span> CHECKSUM_PARTIAL) {
</span></span><span style="display:flex;"><span>			paged <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			uarg<span style="color:#f92672">-&gt;</span>zerocopy <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">skb_zcopy_set</span>(skb, uarg, <span style="color:#f92672">&amp;</span>extra_uref);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 更新cork-&gt;length长度, 对于阻塞通信, cork-&gt;length会表示所有已存储数据长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cork<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">+=</span> length;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* So, what&#39;s going on in the loop below?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * We use calculated fragment length to generate chained skb,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * each of segments is IP fragment ready for sending to network after
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * adding appropriate IP header.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// skb为空则新建skb
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>skb)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> alloc_new_skb;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (length <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* Check if the remaining data fits into current packet. */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// skb-&gt;len表示当前skb已存储数据, copy表示本次循环待处理数据长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		copy <span style="color:#f92672">=</span> mtu <span style="color:#f92672">-</span> skb<span style="color:#f92672">-&gt;</span>len;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 当前skb不能容纳剩余的所有数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (copy <span style="color:#f92672">&lt;</span> length)
</span></span><span style="display:flex;"><span>			copy <span style="color:#f92672">=</span> maxfraglen <span style="color:#f92672">-</span> skb<span style="color:#f92672">-&gt;</span>len;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 当前skb已满, 需要分配新的skb
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (copy <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>data;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> datalen;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> fraglen;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> fraggap;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> alloclen;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> pagedlen;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb_prev;
</span></span><span style="display:flex;"><span>alloc_new_skb:
</span></span><span style="display:flex;"><span>			skb_prev <span style="color:#f92672">=</span> skb;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 如果上一个skb存在, 则说明上一个块已经被填满(skb_prev-&gt;len与maxfraglen差值在[0:8)内)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// 否则说明当前skb为第一个skb, 无需考虑上一个skb剩余数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (skb_prev)
</span></span><span style="display:flex;"><span>				fraggap <span style="color:#f92672">=</span> skb_prev<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">-</span> maxfraglen;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>				fraggap <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 * If remaining data exceeds the mtu,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 * we know we need more fragment(s).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 */</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// datalen记录当前skb需要存储的数据大小, 如果数据超出mtu, 按照最大mtu计算(第一个报文片段需要考虑报文头长度)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			datalen <span style="color:#f92672">=</span> length <span style="color:#f92672">+</span> fraggap;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (datalen <span style="color:#f92672">&gt;</span> mtu <span style="color:#f92672">-</span> fragheaderlen)
</span></span><span style="display:flex;"><span>				datalen <span style="color:#f92672">=</span> maxfraglen <span style="color:#f92672">-</span> fragheaderlen;
</span></span><span style="display:flex;"><span>			fraglen <span style="color:#f92672">=</span> datalen <span style="color:#f92672">+</span> fragheaderlen;
</span></span><span style="display:flex;"><span>			pagedlen <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 如果接下来会有数据传入且硬件不支持分散/聚合IO, 则直接分配mtu大小空间, 否则按需分析
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> ((flags <span style="color:#f92672">&amp;</span> MSG_MORE) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>			    <span style="color:#f92672">!</span>(rt<span style="color:#f92672">-&gt;</span>dst.dev<span style="color:#f92672">-&gt;</span>features<span style="color:#f92672">&amp;</span>NETIF_F_SG))
</span></span><span style="display:flex;"><span>				alloclen <span style="color:#f92672">=</span> mtu;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>paged)
</span></span><span style="display:flex;"><span>				alloclen <span style="color:#f92672">=</span> fraglen;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>				alloclen <span style="color:#f92672">=</span> <span style="color:#66d9ef">min_t</span>(<span style="color:#66d9ef">int</span>, fraglen, MAX_HEADER);
</span></span><span style="display:flex;"><span>				pagedlen <span style="color:#f92672">=</span> fraglen <span style="color:#f92672">-</span> alloclen;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 添加拓展头空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			alloclen <span style="color:#f92672">+=</span> exthdrlen;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">/* The last fragment gets additional space at tail.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 * Note, with MSG_MORE we overallocate on fragments,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 * because we have no idea what fragment will be
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 * the last.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 */</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (datalen <span style="color:#f92672">==</span> length <span style="color:#f92672">+</span> fraggap)
</span></span><span style="display:flex;"><span>				alloclen <span style="color:#f92672">+=</span> rt<span style="color:#f92672">-&gt;</span>dst.trailer_len;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 第一次发送报文片段需要考虑运输层(udp)头部, 与其他片段存在差异, 使用sock_alloc_send_skb分配空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (transhdrlen) {
</span></span><span style="display:flex;"><span>				skb <span style="color:#f92672">=</span> <span style="color:#a6e22e">sock_alloc_send_skb</span>(sk,
</span></span><span style="display:flex;"><span>						alloclen <span style="color:#f92672">+</span> hh_len <span style="color:#f92672">+</span> <span style="color:#ae81ff">15</span>,
</span></span><span style="display:flex;"><span>						(flags <span style="color:#f92672">&amp;</span> MSG_DONTWAIT), <span style="color:#f92672">&amp;</span>err);
</span></span><span style="display:flex;"><span>			} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>				skb <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// 如果当前套接字已分配的写缓冲区总长 &gt; 2*sk-&gt;sk_sndbuf则发生错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">refcount_read</span>(<span style="color:#f92672">&amp;</span>sk<span style="color:#f92672">-&gt;</span>sk_wmem_alloc) <span style="color:#f92672">+</span> wmem_alloc_delta <span style="color:#f92672">&lt;=</span>
</span></span><span style="display:flex;"><span>				    <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> sk<span style="color:#f92672">-&gt;</span>sk_sndbuf)
</span></span><span style="display:flex;"><span>					<span style="color:#75715e">// alloc_skb 为skb分配空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>					skb <span style="color:#f92672">=</span> <span style="color:#a6e22e">alloc_skb</span>(alloclen <span style="color:#f92672">+</span> hh_len <span style="color:#f92672">+</span> <span style="color:#ae81ff">15</span>,
</span></span><span style="display:flex;"><span>							sk<span style="color:#f92672">-&gt;</span>sk_allocation);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span>skb))
</span></span><span style="display:flex;"><span>					err <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>ENOBUFS;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>skb)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">goto</span> error;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 *	Fill in the control structures
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 */</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 选择校验方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			skb<span style="color:#f92672">-&gt;</span>ip_summed <span style="color:#f92672">=</span> csummode;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 伪造一个校验和, 防止后面计算校验和时出现套娃
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			skb<span style="color:#f92672">-&gt;</span>csum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 在skb线性区域为L2保留空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// skb-&gt;data&amp;skb-&gt;head向下移动
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">skb_reserve</span>(skb, hh_len);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 *	Find where to start putting bytes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 */</span>
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// skb-&gt;tail增加, 开辟线性写入空间(skb-&gt;head: skb-&gt;tail)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			data <span style="color:#f92672">=</span> <span style="color:#a6e22e">skb_put</span>(skb, fraglen <span style="color:#f92672">+</span> exthdrlen <span style="color:#f92672">-</span> pagedlen);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 设置网络层头
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">skb_set_network_header</span>(skb, exthdrlen);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 设置传输层头
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			skb<span style="color:#f92672">-&gt;</span>transport_header <span style="color:#f92672">=</span> (skb<span style="color:#f92672">-&gt;</span>network_header <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>						 fragheaderlen);
</span></span><span style="display:flex;"><span>			data <span style="color:#f92672">+=</span> fragheaderlen <span style="color:#f92672">+</span> exthdrlen;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (fraggap) {
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// 将pre_skb末尾字节复制到skb, 拷贝时校验
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				skb<span style="color:#f92672">-&gt;</span>csum <span style="color:#f92672">=</span> <span style="color:#a6e22e">skb_copy_and_csum_bits</span>(
</span></span><span style="display:flex;"><span>					skb_prev, maxfraglen,
</span></span><span style="display:flex;"><span>					data <span style="color:#f92672">+</span> transhdrlen, fraggap, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>				skb_prev<span style="color:#f92672">-&gt;</span>csum <span style="color:#f92672">=</span> <span style="color:#a6e22e">csum_sub</span>(skb_prev<span style="color:#f92672">-&gt;</span>csum,
</span></span><span style="display:flex;"><span>							  skb<span style="color:#f92672">-&gt;</span>csum);
</span></span><span style="display:flex;"><span>				data <span style="color:#f92672">+=</span> fraggap;
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">pskb_trim_unique</span>(skb_prev, maxfraglen);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 调用getfrag(), 复制copy字节数据至skb, getfrag由上层协议指定(本例为udp)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			copy <span style="color:#f92672">=</span> datalen <span style="color:#f92672">-</span> transhdrlen <span style="color:#f92672">-</span> fraggap <span style="color:#f92672">-</span> pagedlen;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (copy <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">getfrag</span>(from, data <span style="color:#f92672">+</span> transhdrlen, offset, copy, fraggap, skb) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>				err <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EFAULT;
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">kfree_skb</span>(skb);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">goto</span> error;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 更新偏移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			offset <span style="color:#f92672">+=</span> copy;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 递减length(待传输字节数)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			length <span style="color:#f92672">-=</span> copy <span style="color:#f92672">+</span> transhdrlen;
</span></span><span style="display:flex;"><span>			transhdrlen <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			exthdrlen <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			csummode <span style="color:#f92672">=</span> CHECKSUM_NONE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">/* only the initial fragment is time stamped */</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 设置时间戳
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">skb_shinfo</span>(skb)<span style="color:#f92672">-&gt;</span>tx_flags <span style="color:#f92672">=</span> cork<span style="color:#f92672">-&gt;</span>tx_flags;
</span></span><span style="display:flex;"><span>			cork<span style="color:#f92672">-&gt;</span>tx_flags <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">skb_shinfo</span>(skb)<span style="color:#f92672">-&gt;</span>tskey <span style="color:#f92672">=</span> tskey;
</span></span><span style="display:flex;"><span>			tskey <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">skb_zcopy_set</span>(skb, uarg, <span style="color:#f92672">&amp;</span>extra_uref);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> ((flags <span style="color:#f92672">&amp;</span> MSG_CONFIRM) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>skb_prev)
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">skb_set_dst_pending_confirm</span>(skb, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 * Put the packet on the pending queue.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			 */</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>skb<span style="color:#f92672">-&gt;</span>destructor) {
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// 销毁skb后, 恢复相应的wmem_alloc_delta数据容量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				skb<span style="color:#f92672">-&gt;</span>destructor <span style="color:#f92672">=</span> sock_wfree;
</span></span><span style="display:flex;"><span>				skb<span style="color:#f92672">-&gt;</span>sk <span style="color:#f92672">=</span> sk;
</span></span><span style="display:flex;"><span>				wmem_alloc_delta <span style="color:#f92672">+=</span> skb<span style="color:#f92672">-&gt;</span>truesize;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 添加skb至队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">__skb_queue_tail</span>(queue, skb);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// skb剩余空间足够存储剩余数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (copy <span style="color:#f92672">&gt;</span> length)
</span></span><span style="display:flex;"><span>			copy <span style="color:#f92672">=</span> length;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果硬件不支持分散/聚合IO, 使用线性区域存储数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(rt<span style="color:#f92672">-&gt;</span>dst.dev<span style="color:#f92672">-&gt;</span>features<span style="color:#f92672">&amp;</span>NETIF_F_SG) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>		    <span style="color:#a6e22e">skb_tailroom</span>(skb) <span style="color:#f92672">&gt;=</span> copy) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> off;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			off <span style="color:#f92672">=</span> skb<span style="color:#f92672">-&gt;</span>len;
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 硬件不支持分散/聚合IO, 使用getfrag复制数据至线性区域(更新skb-&gt;tail), 更新偏移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">getfrag</span>(from, <span style="color:#a6e22e">skb_put</span>(skb, copy),
</span></span><span style="display:flex;"><span>					offset, copy, off, skb) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">__skb_trim</span>(skb, off);
</span></span><span style="display:flex;"><span>				err <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EFAULT;
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">goto</span> error;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>uarg <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>uarg<span style="color:#f92672">-&gt;</span>zerocopy) {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 填充至非线性区域, skb的frags数组中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#a6e22e">skb_shinfo</span>(skb)<span style="color:#f92672">-&gt;</span>nr_frags;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			err <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">sk_page_frag_refill</span>(sk, pfrag))
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">goto</span> error;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">skb_can_coalesce</span>(skb, i, pfrag<span style="color:#f92672">-&gt;</span>page,
</span></span><span style="display:flex;"><span>					      pfrag<span style="color:#f92672">-&gt;</span>offset)) {
</span></span><span style="display:flex;"><span>				err <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EMSGSIZE;
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> MAX_SKB_FRAGS)
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">goto</span> error;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">__skb_fill_page_desc</span>(skb, i, pfrag<span style="color:#f92672">-&gt;</span>page,
</span></span><span style="display:flex;"><span>						     pfrag<span style="color:#f92672">-&gt;</span>offset, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">skb_shinfo</span>(skb)<span style="color:#f92672">-&gt;</span>nr_frags <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>i;
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">get_page</span>(pfrag<span style="color:#f92672">-&gt;</span>page);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			copy <span style="color:#f92672">=</span> <span style="color:#66d9ef">min_t</span>(<span style="color:#66d9ef">int</span>, copy, pfrag<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">-</span> pfrag<span style="color:#f92672">-&gt;</span>offset);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">getfrag</span>(from,
</span></span><span style="display:flex;"><span>				    <span style="color:#a6e22e">page_address</span>(pfrag<span style="color:#f92672">-&gt;</span>page) <span style="color:#f92672">+</span> pfrag<span style="color:#f92672">-&gt;</span>offset,
</span></span><span style="display:flex;"><span>				    offset, copy, skb<span style="color:#f92672">-&gt;</span>len, skb) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">goto</span> error_efault;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			pfrag<span style="color:#f92672">-&gt;</span>offset <span style="color:#f92672">+=</span> copy;
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">skb_frag_size_add</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">skb_shinfo</span>(skb)<span style="color:#f92672">-&gt;</span>frags[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>], copy);
</span></span><span style="display:flex;"><span>			skb<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">+=</span> copy;
</span></span><span style="display:flex;"><span>			skb<span style="color:#f92672">-&gt;</span>data_len <span style="color:#f92672">+=</span> copy;
</span></span><span style="display:flex;"><span>			skb<span style="color:#f92672">-&gt;</span>truesize <span style="color:#f92672">+=</span> copy;
</span></span><span style="display:flex;"><span>			wmem_alloc_delta <span style="color:#f92672">+=</span> copy;
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 使用零拷贝技术填充skb
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			err <span style="color:#f92672">=</span> <span style="color:#a6e22e">skb_zerocopy_iter_dgram</span>(skb, from, copy);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (err <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">goto</span> error;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 更新偏移与长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		offset <span style="color:#f92672">+=</span> copy;
</span></span><span style="display:flex;"><span>		length <span style="color:#f92672">-=</span> copy;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (wmem_alloc_delta)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">refcount_add</span>(wmem_alloc_delta, <span style="color:#f92672">&amp;</span>sk<span style="color:#f92672">-&gt;</span>sk_wmem_alloc);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>error_efault:
</span></span><span style="display:flex;"><span>	err <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EFAULT;
</span></span><span style="display:flex;"><span>error:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (uarg)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">sock_zerocopy_put_abort</span>(uarg, extra_uref);
</span></span><span style="display:flex;"><span>	cork<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">-=</span> length;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">IP_INC_STATS</span>(<span style="color:#a6e22e">sock_net</span>(sk), IPSTATS_MIB_OUTDISCARDS);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">refcount_add</span>(wmem_alloc_delta, <span style="color:#f92672">&amp;</span>sk<span style="color:#f92672">-&gt;</span>sk_wmem_alloc);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> err;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="44-ip_send_skb">4.4 ip_send_skb</h3>
<blockquote>
<p>ip_send_skb-&gt;ip_local_out</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ip_send_skb</span>(<span style="color:#66d9ef">struct</span> net <span style="color:#f92672">*</span>net, <span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> err;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	err <span style="color:#f92672">=</span> <span style="color:#a6e22e">ip_local_out</span>(net, skb<span style="color:#f92672">-&gt;</span>sk, skb);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (err) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (err <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 传递底层错误信息至上层协议
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			err <span style="color:#f92672">=</span> <span style="color:#a6e22e">net_xmit_errno</span>(err);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (err)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">IP_INC_STATS</span>(net, IPSTATS_MIB_OUTDISCARDS);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> err;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ip_local_out</span>(<span style="color:#66d9ef">struct</span> net <span style="color:#f92672">*</span>net, <span style="color:#66d9ef">struct</span> sock <span style="color:#f92672">*</span>sk, <span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> err;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 填充ip头部, 判断数据包是否允许通过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	err <span style="color:#f92672">=</span> <span style="color:#a6e22e">__ip_local_out</span>(net, sk, skb);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(err <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 发送数据包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		err <span style="color:#f92672">=</span> <span style="color:#a6e22e">dst_output</span>(net, sk, skb);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> err;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="441-__ip_local_out">4.4.1 __ip_local_out</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">__ip_local_out</span>(<span style="color:#66d9ef">struct</span> net <span style="color:#f92672">*</span>net, <span style="color:#66d9ef">struct</span> sock <span style="color:#f92672">*</span>sk, <span style="color:#66d9ef">struct</span> sk_buff <span style="color:#f92672">*</span>skb)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> iphdr <span style="color:#f92672">*</span>iph <span style="color:#f92672">=</span> <span style="color:#a6e22e">ip_hdr</span>(skb);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 填充ip报文长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	iph<span style="color:#f92672">-&gt;</span>tot_len <span style="color:#f92672">=</span> <span style="color:#a6e22e">htons</span>(skb<span style="color:#f92672">-&gt;</span>len);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 计算ip校验和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ip_send_check</span>(iph);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* if egress device is enslaved to an L3 master device pass the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * skb to its handler for processing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 设置出口设备为l3主设备(虚拟网卡)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	skb <span style="color:#f92672">=</span> <span style="color:#a6e22e">l3mdev_ip_out</span>(sk, skb);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span>skb))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	skb<span style="color:#f92672">-&gt;</span>protocol <span style="color:#f92672">=</span> <span style="color:#a6e22e">htons</span>(ETH_P_IP);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 检查此处是否存在网络数据包过滤器, 如果存在则执行过滤操作, 并将dst_output作为回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">nf_hook</span>(NFPROTO_IPV4, NF_INET_LOCAL_OUT,
</span></span><span style="display:flex;"><span>		       net, sk, skb, NULL, <span style="color:#a6e22e">skb_dst</span>(skb)<span style="color:#f92672">-&gt;</span>dev,
</span></span><span style="display:flex;"><span>		       dst_output);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></section>

  
  

  
  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    <a
      class="flex w-1/2 items-center rounded-l-md p-6 pr-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]"
      href="https://povcfe.github.io/post/nginx-ldap-auth/"
      ><span class="mr-1.5">←</span><span>nginx-ldap-auth之user注入漏洞</span></a
    >
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]"
      href="https://povcfe.github.io/post/kernel_kasan/"
      ><span>linux内核(5.4.81)---KASAN</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  
  

  
  

  
  

  


  
</article>


    </main>

    <footer
  class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"
>
  <div class="mr-auto">
    &copy; 2024
    <a class="link" href="https://povcfe.github.io/">povcfe&#39;s site</a>
  </div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank"
    >Powered by Hugo️️</a
  >️
  <a
    class="link"
    href="https://github.com/nanxiaobei/hugo-paper"
    rel="noopener"
    target="_blank"
    >✎ Paper</a
  >
</footer>

  </body>
</html>
