<!doctype html>









































<html
  class="not-ready lg:text-base"
  style="--bg: #faf8f1"
  lang="en-us"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>linux内核(5.4.81)---内存管理模块源码分析 - povcfe&#39;s site</title>

  
  <meta name="theme-color" />

  
  
  
  
  <meta name="description" content="已投稿于安全客
页表 1.1. 页表查询&ndash;以x86_64下的4级页表举例(硬件) 1.1.1. TLB转换 1.1.2. 页表转换 1.1.3. 页表结构cache转换 1.2. 拓展 1.2.1. 普通页表cache 1.2.2. Huge_Page 1.2.3. 页表标志位 伙伴算法(buddy) alloc_pages源码分析 3.1. alloc_pages_current 3.2. __alloc_pages_nodemask 3.2.1. get_page_from_freelist 3.2.2. _alloc_pages_slowpath _free_pages源码分析 4.1. free_unref_page 4.1.1. free_pcppages_bulk 4.2. __free_pages_ok 4.2.1. __free_one_page slub算法 5.1. 结构体解析 kmem_cache_alloc源码分析 6.1. __slab_alloc 6.1.1. get_freelist kmem_cache_free源码分析 7.1. cache_from_obj 7.2. slab_free_freelist_hook 7.3. do_slab_free 7.3.1. __slab_free 进程vma 8.1. vm_area_struct 结构体 8.2. find_vma(vma查找) 8.2.1. vmacache_find 8.3. insert_vm_struct(vma插入) 8.3.1. find_vma_links 8.3.2. 红黑树规则 缺页中断 9.1. __do_page_fault源码分析 9." />
  <meta name="author" content="povcfe" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://www.povcfe.site/main.min.css" />

  
  
  
  
  
  <link rel="preload" as="image" href="https://www.povcfe.site/theme.png" />

  
  
  
  
  <link rel="preload" as="image" href="https://www.povcfe.site/avatar.jpg" />
  
  

  
  
  <link rel="preload" as="image" href="https://www.povcfe.site/twitter.svg" />
  
  <link rel="preload" as="image" href="https://www.povcfe.site/github.svg" />
  
  <link rel="preload" as="image" href="https://www.povcfe.site/rss.svg" />
  
  

  
  
  <script
    defer
    src="https://www.povcfe.site/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
  
  

  
  <link rel="icon" href="https://www.povcfe.site/favicon.ico" />
  <link rel="apple-touch-icon" href="https://www.povcfe.site/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.111.3">

  
  
  
  
  
  <meta itemprop="name" content="linux内核(5.4.81)---内存管理模块源码分析">
<meta itemprop="description" content="已投稿于安全客
页表 1.1. 页表查询&ndash;以x86_64下的4级页表举例(硬件) 1.1.1. TLB转换 1.1.2. 页表转换 1.1.3. 页表结构cache转换 1.2. 拓展 1.2.1. 普通页表cache 1.2.2. Huge_Page 1.2.3. 页表标志位 伙伴算法(buddy) alloc_pages源码分析 3.1. alloc_pages_current 3.2. __alloc_pages_nodemask 3.2.1. get_page_from_freelist 3.2.2. _alloc_pages_slowpath _free_pages源码分析 4.1. free_unref_page 4.1.1. free_pcppages_bulk 4.2. __free_pages_ok 4.2.1. __free_one_page slub算法 5.1. 结构体解析 kmem_cache_alloc源码分析 6.1. __slab_alloc 6.1.1. get_freelist kmem_cache_free源码分析 7.1. cache_from_obj 7.2. slab_free_freelist_hook 7.3. do_slab_free 7.3.1. __slab_free 进程vma 8.1. vm_area_struct 结构体 8.2. find_vma(vma查找) 8.2.1. vmacache_find 8.3. insert_vm_struct(vma插入) 8.3.1. find_vma_links 8.3.2. 红黑树规则 缺页中断 9.1. __do_page_fault源码分析 9."><meta itemprop="datePublished" content="2021-01-12T00:00:00-04:00" />
<meta itemprop="dateModified" content="2021-01-12T00:00:00-04:00" />
<meta itemprop="wordCount" content="6614">
<meta itemprop="keywords" content="" />
  
  <meta property="og:title" content="linux内核(5.4.81)---内存管理模块源码分析" />
<meta property="og:description" content="已投稿于安全客
页表 1.1. 页表查询&ndash;以x86_64下的4级页表举例(硬件) 1.1.1. TLB转换 1.1.2. 页表转换 1.1.3. 页表结构cache转换 1.2. 拓展 1.2.1. 普通页表cache 1.2.2. Huge_Page 1.2.3. 页表标志位 伙伴算法(buddy) alloc_pages源码分析 3.1. alloc_pages_current 3.2. __alloc_pages_nodemask 3.2.1. get_page_from_freelist 3.2.2. _alloc_pages_slowpath _free_pages源码分析 4.1. free_unref_page 4.1.1. free_pcppages_bulk 4.2. __free_pages_ok 4.2.1. __free_one_page slub算法 5.1. 结构体解析 kmem_cache_alloc源码分析 6.1. __slab_alloc 6.1.1. get_freelist kmem_cache_free源码分析 7.1. cache_from_obj 7.2. slab_free_freelist_hook 7.3. do_slab_free 7.3.1. __slab_free 进程vma 8.1. vm_area_struct 结构体 8.2. find_vma(vma查找) 8.2.1. vmacache_find 8.3. insert_vm_struct(vma插入) 8.3.1. find_vma_links 8.3.2. 红黑树规则 缺页中断 9.1. __do_page_fault源码分析 9." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.povcfe.site/post/kernel_mm/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-01-12T00:00:00-04:00" />
<meta property="article:modified_time" content="2021-01-12T00:00:00-04:00" />

  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="linux内核(5.4.81)---内存管理模块源码分析"/>
<meta name="twitter:description" content="已投稿于安全客
页表 1.1. 页表查询&ndash;以x86_64下的4级页表举例(硬件) 1.1.1. TLB转换 1.1.2. 页表转换 1.1.3. 页表结构cache转换 1.2. 拓展 1.2.1. 普通页表cache 1.2.2. Huge_Page 1.2.3. 页表标志位 伙伴算法(buddy) alloc_pages源码分析 3.1. alloc_pages_current 3.2. __alloc_pages_nodemask 3.2.1. get_page_from_freelist 3.2.2. _alloc_pages_slowpath _free_pages源码分析 4.1. free_unref_page 4.1.1. free_pcppages_bulk 4.2. __free_pages_ok 4.2.1. __free_one_page slub算法 5.1. 结构体解析 kmem_cache_alloc源码分析 6.1. __slab_alloc 6.1.1. get_freelist kmem_cache_free源码分析 7.1. cache_from_obj 7.2. slab_free_freelist_hook 7.3. do_slab_free 7.3.1. __slab_free 进程vma 8.1. vm_area_struct 结构体 8.2. find_vma(vma查找) 8.2.1. vmacache_find 8.3. insert_vm_struct(vma插入) 8.3.1. find_vma_links 8.3.2. 红黑树规则 缺页中断 9.1. __do_page_fault源码分析 9."/>

  
  
  
  <link rel="canonical" href="https://www.povcfe.site/post/kernel_mm/" />
  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center">
  <div class="relative z-50 mr-auto flex items-center">
    <a
      class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold"
      href="https://www.povcfe.site/"
      >povcfe&#39;s site</a
    >
    <div
      class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]"
      role="button"
      aria-label="Dark"
    ></div>
  </div>

  <div
    class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
    role="button"
    aria-label="Menu"
  ></div>

  

  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = '#faf8f1'.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"
    >
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./twitter.svg)"
        href="https://twitter.com/povcfe"
        target="_blank"
        rel="me"
      >
        twitter
      </a>
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href="https://github.com/povcfe"
        target="_blank"
        rel="me"
      >
        github
      </a>
      
      <a
        class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./rss.svg)"
        href="https://www.povcfe.site/index.xml"
        target="_blank"
        rel="alternate"
      >
        rss
      </a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"
    >
      

<article>
  <header class="mb-16">
    <h1 class="!my-0 pb-2.5">linux内核(5.4.81)---内存管理模块源码分析</h1>

    
    <div class="text-sm antialiased opacity-60">
      
      <time>Jan 12, 2021</time>
      
      
      
      
    </div>
    
  </header>

  <section><p><a href="https://www.anquanke.com/post/id/228651">已投稿于安全客</a></p>
<!-- raw HTML omitted -->
<ul>
<li>
<ol>
<li><a href="#">页表</a></li>
</ol>
<ul>
<li>1.1. <a href="#--x86_644">页表查询&ndash;以x86_64下的4级页表举例(硬件)</a>
<ul>
<li>1.1.1. <a href="#TLB">TLB转换</a></li>
<li>1.1.2. <a href="#-1">页表转换</a></li>
<li>1.1.3. <a href="#cache">页表结构cache转换</a></li>
</ul>
</li>
<li>1.2. <a href="#-1">拓展</a>
<ul>
<li>1.2.1. <a href="#cache-1">普通页表cache</a></li>
<li>1.2.2. <a href="#Huge_Page">Huge_Page</a></li>
<li>1.2.3. <a href="#-1">页表标志位</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="2">
<li><a href="#buddy">伙伴算法(buddy)</a></li>
</ol>
</li>
<li>
<ol start="3">
<li><a href="#alloc_pages">alloc_pages源码分析</a></li>
</ol>
<ul>
<li>3.1. <a href="#alloc_pages_current">alloc_pages_current</a></li>
<li>3.2. <a href="#alloc_pages_nodemask">__alloc_pages_nodemask</a>
<ul>
<li>3.2.1. <a href="#get_page_from_freelist">get_page_from_freelist</a></li>
<li>3.2.2. <a href="#alloc_pages_slowpath">_alloc_pages_slowpath</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="4">
<li><a href="#free_pages">_free_pages源码分析</a></li>
</ol>
<ul>
<li>4.1. <a href="#free_unref_page">free_unref_page</a>
<ul>
<li>4.1.1. <a href="#free_pcppages_bulk">free_pcppages_bulk</a></li>
</ul>
</li>
<li>4.2. <a href="#free_pages_ok">__free_pages_ok</a>
<ul>
<li>4.2.1. <a href="#free_one_page">__free_one_page</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="5">
<li><a href="#slub">slub算法</a></li>
</ol>
<ul>
<li>5.1. <a href="#-1">结构体解析</a></li>
</ul>
</li>
<li>
<ol start="6">
<li><a href="#kmem_cache_alloc">kmem_cache_alloc源码分析</a></li>
</ol>
<ul>
<li>6.1. <a href="#slab_alloc">__slab_alloc</a>
<ul>
<li>6.1.1. <a href="#get_freelist">get_freelist</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="7">
<li><a href="#kmem_cache_free">kmem_cache_free源码分析</a></li>
</ol>
<ul>
<li>7.1. <a href="#cache_from_obj">cache_from_obj</a></li>
<li>7.2. <a href="#slab_free_freelist_hook">slab_free_freelist_hook</a></li>
<li>7.3. <a href="#do_slab_free">do_slab_free</a>
<ul>
<li>7.3.1. <a href="#slab_free">__slab_free</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="8">
<li><a href="#vma">进程vma</a></li>
</ol>
<ul>
<li>8.1. <a href="#vm_area_struct">vm_area_struct 结构体</a></li>
<li>8.2. <a href="#find_vmavma">find_vma(vma查找)</a>
<ul>
<li>8.2.1. <a href="#vmacache_find">vmacache_find</a></li>
</ul>
</li>
<li>8.3. <a href="#insert_vm_structvma">insert_vm_struct(vma插入)</a>
<ul>
<li>8.3.1. <a href="#find_vma_links">find_vma_links</a></li>
<li>8.3.2. <a href="#-1">红黑树规则</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="9">
<li><a href="#-1">缺页中断</a></li>
</ol>
<ul>
<li>9.1. <a href="#do_page_fault">__do_page_fault源码分析</a></li>
<li>9.2. <a href="#fault_in_kernel_space">fault_in_kernel_space</a></li>
<li>9.3. <a href="#do_kern_addr_fault">do_kern_addr_fault</a>
<ul>
<li>9.3.1. <a href="#vmalloc_fault">vmalloc_fault</a></li>
<li>9.3.2. <a href="#spurious_kernel_fault">spurious_kernel_fault</a></li>
<li>9.3.3. <a href="#bad_area_nosemaphore">bad_area_nosemaphore</a></li>
</ul>
</li>
<li>9.4. <a href="#do_user_addr_fault">do_user_addr_fault</a>
<ul>
<li>9.4.1. <a href="#handle_mm_fault">handle_mm_fault</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="10">
<li><a href="#ptmalloc">ptmalloc</a></li>
</ol>
</li>
<li>
<ol start="11">
<li><a href="#-1">杂记</a></li>
</ol>
</li>
</ul>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>linux作为开源内核，被广泛使用。同时随着用户态安全机制的逐渐完善，攻击成本逐年升高，越来越多的黑客将目光投向linux内核，linux内核安全问题也随之被越来越多的安全研究人员关注。但作为一个规模宏大的开源项目，linux内核安全研究存在非常高的研究门槛，不管是针对特定模块的漏洞挖掘，还是cve复现，对内核的理解限制了绝大多数安全研究人员。而本文则希望通过对内核源码做详细分析来让更多的安全研究人员越过内核门槛。
这篇文章的贡献如下：</p>
<p>（1）硬件层面上分析linux内核页表</p>
<p>（2）从buddy源码分析linux内核页管理</p>
<p>（3）从slub源码分析linux内核小内存管理</p>
<p>（4）从vma源码分析linux内核对于进程内存空间的布局及管理</p>
<p>（5）分析缺页中断流程</p>
<p>（6）从ptmalloc源码分析用户态内存管理机制，以及如何通过特定api与linux内核交互</p>
<h2 id="1-a-namea页表">1. <!-- raw HTML omitted --><!-- raw HTML omitted -->页表</h2>
<h3 id="11-a-name--x86_644a页表查询--以x86_64下的4级页表举例硬件">1.1. <!-- raw HTML omitted --><!-- raw HTML omitted -->页表查询&ndash;以x86_64下的4级页表举例(硬件)</h3>
<ul>
<li>流程总览(定义虚拟地址virt_addr, 寻找对应的物理地址phy_addr)</li>
<li>顺序: TLB -&gt; 页表结构cache -&gt; 页表(MMU硬件实现)</li>
<li>MMU = TLB(Translation Lookaside Buffer) + table walk unit</li>
</ul>
<h4 id="111-a-nametlbatlb转换">1.1.1. <!-- raw HTML omitted --><!-- raw HTML omitted -->TLB转换</h4>
<ol>
<li>明确概念:</li>
</ol>
<p>VPN(virtual page number), PPN(physical page number),VPO(virtual page offset)和PPO(physical page offset)</p>
<ul>
<li>对于线性地址和物理地址而言, 都是以page为最小的管理单元, 那么也就是说如果线性地址可以映射到某物理地址, 则两者页偏移相同(默认page size = 4K, 占用低12bits), 即VPO = PPO</li>
<li>TLB可以简单理解成VPN-&gt;PPN(36bits), 实现了一个线性映射, 基本结构如下:
<pre tabindex="0"><code>___________________
|__VPN1___|__PPN1___|
|__VPN2___|__PPN2___|
|__VPN3___|__PPN3___|
...       ...
</code></pre></li>
</ul>
<ol start="2">
<li>通过VPN(virt_addr[12:48])定位表项</li>
</ol>
<ul>
<li>
<p>全相连(full associative)&ndash; VPN可以被填充在TLB中的任何位置</p>
<ul>
<li>定位VPN对应的表项需要遍历TLB中的所有表项</li>
</ul>
</li>
<li>
<p>直接匹配&ndash; VPN被映射在特定位置</p>
<ul>
<li>如果TLB存在n个表项, 那么VPN%n即为该VPN的索引</li>
<li>定位到索引后, 查看VPN是否匹配, 如果不匹配则TLB miss</li>
</ul>
</li>
<li>
<p>组相连(set-associative)&ndash; 全相连和直接匹配相结合</p>
<ul>
<li>TLB被划分为m组, 每个组存在n表项, VPN分为set(VPN[47-log2(m):48]), tag(VPN[12:48-log2(m)])</li>
<li>VPN[47-log2(m):48]%m为该VPN的set索引</li>
<li>定位到索引后, 查看set内是否存在tag, 如果不存在则TLB miss</li>
</ul>
</li>
</ul>
<h4 id="112-a-name-1a页表转换">1.1.2. <!-- raw HTML omitted --><!-- raw HTML omitted -->页表转换</h4>
<ol>
<li>明确概念:</li>
</ol>
<ul>
<li>对于四级页表: PGD(page global directory), PUD(page upper directory), PMD(page middle directory), PTE(page table entry), 每个页表占9bits, 支持48bits虚拟地址</li>
<li>对于五级页表：添加P4D表项, 支持57位虚拟地址</li>
</ul>
<ol start="2">
<li>通过virt_addr[12:48]定位page table entry</li>
</ol>
<ul>
<li>CR3寄存器存储PGD物理地址, virt_addr[39:48]为PGD_index, PGD+PGD_index=PGD_addr</li>
<li>virt_addr[30:39]为PUD_index, PGD_addr+PUD_index=PUD_addr</li>
<li>virt_addr[21:30]为PME_index, PUD_addr+PME_index=PME_addr</li>
<li>virt_addr[12:21]为PTE_index, PME_addr+PTE_index=PTE_addr</li>
</ul>
<ol start="3">
<li>PTE_addr即为page table entry是一个表项映射到PPN</li>
</ol>
<h4 id="113-a-namecachea页表结构cache转换">1.1.3. <!-- raw HTML omitted --><!-- raw HTML omitted -->页表结构cache转换</h4>
<ol>
<li>明确概念:</li>
</ol>
<ul>
<li>如果某些虚拟地址临近, 那么很有可能他们会有相同的页表项(PGD or PUD or PMD or PTE),对于这种情况如果还是依次查询页表就会浪费大量时间, 所以存在页表结构cache, 用来缓存页表</li>
</ul>
<ol start="2">
<li>cache种类:</li>
</ol>
<ul>
<li>PDE cache(virt_addr[21:48]作为tag, 映射PME entry地址)</li>
<li>PDPTE cache(virt_addr[30:48]作为tag, 映射PUD entry地址)</li>
<li>PML4 cache(virt_addr[39:48]作为tag, 映射PGD entry地址)</li>
</ul>
<h3 id="12-a-name-1a拓展">1.2. <!-- raw HTML omitted --><!-- raw HTML omitted -->拓展</h3>
<h4 id="121-a-namecache-1a普通页表cache">1.2.1. <!-- raw HTML omitted --><!-- raw HTML omitted -->普通页表cache</h4>
<ol>
<li>明确概念:</li>
</ol>
<ul>
<li>页表保存在内存中, 可以被缓存到普通cache</li>
</ul>
<ol start="2">
<li>各级页表中存在PCD(page-level cache disable)标志位, 控制下一级页表是否需要被缓存</li>
</ol>
<h4 id="122-a-namehuge_pageahuge_page">1.2.2. <!-- raw HTML omitted --><!-- raw HTML omitted -->Huge_Page</h4>
<ol>
<li>明确概念:</li>
</ol>
<ul>
<li>页表中指向下一级的地址是按页对齐的, 也就是低12bits无效, 可以用作flag标志位</li>
<li>page size flag为1时表示当前页表的下级地址对应大页地址而不是页表</li>
</ul>
<ol start="2">
<li>
<p>x86两级页表支持4MB大页(跳过PTE, 4K*2^10=4MB)</p>
</li>
<li>
<p>x86_64四级页表支持2MB大页(跳过PTE, 4K*2^9=2MB), 1GB大页(跳过PME, 2M*2^9=1GB)</p>
</li>
</ol>
<h4 id="123-a-name-1a页表标志位">1.2.3. <!-- raw HTML omitted --><!-- raw HTML omitted -->页表标志位</h4>
<ul>
<li>
<p>P(Present) - 为1表明该page存在于当前物理内存中, 为0则触发page fault。</p>
</li>
<li>
<p>G(Global)- 标记kernel对应的页, 也存在于TLB entry, 表示该页不会被flush掉。</p>
</li>
<li>
<p>A(Access) - 当page被访问(读/写)过后, 硬件置1。软件可置0, 然后对应的TLB将会被flush掉。</p>
</li>
<li>
<p>D(Dirty)- 对写回的page有作用。当page被写入后, 硬件置1, 表明该page的内容比外部disk/flash对应部分要新, 当系统内存不足, 要将该page回收的时候, 需首先将其内容flush到外部存储, 之后软件将该标志位清0。</p>
</li>
<li>
<p>R/W和U/S属于权限控制类：</p>
</li>
</ul>
<ol>
<li>
<p>R/W(Read/Write) - 置1表示该page是writable的, 置0是readonly。</p>
</li>
<li>
<p>U/S(User/Supervisor) - 置0表示只有supervisor(比如操作系统中的kernel)才可访问该page, 置1表示user也可以访问。</p>
</li>
</ol>
<ul>
<li>PCD和PWT和cache属性相关：</li>
</ul>
<ol>
<li>
<p>PCD(Page Cache Disabled)- 置1表示disable, 即该page中的内容是不可以被cache的。如果置0(enable), 还要看CR0寄存器中的CD位这个总控开关是否也是0。</p>
</li>
<li>
<p>PWT (Page Write Through)- 置1表示该page对应的cache部分采用write through的方式, 否则采用write back。</p>
</li>
</ol>
<ul>
<li>64位特有:</li>
</ul>
<ol>
<li>
<p>XD (Execute Disable)- 在bit[63]中</p>
</li>
<li>
<p>CR3支持PCID:</p>
</li>
</ol>
<ul>
<li>CR4寄存器的PCIDE位 = 1, 则CR3低12位表示PCID(覆盖PCD和PWT&ndash;CR3低12bits只有PCD和PWT标志位)</li>
</ul>
<h2 id="2-a-namebuddya伙伴算法buddy">2. <!-- raw HTML omitted --><!-- raw HTML omitted -->伙伴算法(buddy)</h2>
<ul>
<li>alloc_pages(内存分配)概略图</li>
</ul>
<p><img src="../../mm/alloc_pages.png" alt="alloc_pages"></p>
<ul>
<li>__free_pages(内存释放)缩略图</li>
</ul>
<p><img src="../../mm/__free_pages.png" alt="alloc_pages"></p>
<h2 id="3-a-namealloc_pagesaalloc_pages源码分析">3. <!-- raw HTML omitted --><!-- raw HTML omitted -->alloc_pages源码分析</h2>
<ol>
<li>pol变量保存内存分配策略(man set_mempolicy)</li>
</ol>
<p><img src="../../mm/mpol.png" alt="mpol"></p>
<ul>
<li>MPOL_DEFAULT: 默认策略, 优先从当前结点分配内存, 若当前结点无空闲内存, 则从最近的有空闲内存的结点分配</li>
<li>MPOL_BIND: 指定内存分配结点集合, 若该集合内无空闲内存, 则分配失败</li>
<li>MPOL_INTERLEAVE: 内存分配要覆盖所有结点, 且每个结点使用的内存大小相同, 常用于共享内存区域</li>
<li>MPOL_PREFERRED: 从指定结点上分配内存, 若该结点无空闲内存, 则从其他结点分配</li>
<li>MPOL_LOCAL: 同MPOL_DEFAULT</li>
</ul>
<ol start="2">
<li>water_mark</li>
</ol>
<p><img src="../../mm/water_mark.png" alt="water_mark"></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> zone_watermarks {
</span></span><span style="display:flex;"><span>        WMARK_MIN,
</span></span><span style="display:flex;"><span>        WMARK_LOW,
</span></span><span style="display:flex;"><span>        WMARK_HIGH,
</span></span><span style="display:flex;"><span>        NR_WMARK
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>WMARK_MIN: 当空闲页面的数量降到WMARK_MIN时, 唤醒 kswapd 守护进程以同步的方式进行直接内存回收, 同时只有GFP_ATOMIC可以在这种情况下分配内存</li>
<li>WMARK_LOW: 当空闲页面的数量降到WMARK_LOW时, 唤醒 kswapd 守护进程进行内存回收</li>
<li>WMARK_HIGH: kswapd进程休眠</li>
</ul>
<ol start="3">
<li>自旋锁(spin_lock)</li>
</ol>
<ul>
<li>为什么使用自旋锁:
<ul>
<li>使用常规锁会发生上下文切换,时间不可预期,对于一些简单的、极短的临界区来说是一种性能损耗</li>
<li>中断上下文是不允许睡眠的,除了自旋锁以外的其他锁都有可能导致睡眠或者进程切换,这是违背了中断的设计初衷,会发生不可预知的错误</li>
</ul>
</li>
<li>自旋锁的功能: 一直轮询等待检查临界区是否可用, 直至时间片用完</li>
<li>自旋锁使用原则:
<ul>
<li>禁止抢占: 如果A, B同时访问临界区, A进程首先获得自旋锁, B进程轮询等待, B抢占A后, B无法获得自旋锁, 造成死锁</li>
<li>禁止睡眠: 如果自旋锁锁住以后进入睡眠,而又不能进行处理器抢占,内核的调取器无法调取其他进程获得该CPU,从而导致该CPU被挂起；同时该进程也无法自唤醒且一直持有该自旋锁,进一步会导致其他使用该自旋锁的位置出现死锁</li>
</ul>
</li>
<li>自旋锁的几个实现:
<ul>
<li>spin_lock: 只禁止内核抢占, 不会关闭本地中断</li>
<li>spin_lock_irq: 禁止内核抢占, 且关闭本地中断</li>
<li>spin_lock_irqsave: 禁止内核抢占, 关闭中断, 保存中断状态寄存器的标志位</li>
</ul>
</li>
<li>spin_lock与spin_lock_irq的区别:
<ul>
<li>禁止中断与禁止抢占的原因相同</li>
</ul>
</li>
<li>spin_lock_irq与spin_lock_irqsave的区别:
<ul>
<li>假设临界区被两把spin_lock_irq(a-&gt;b)锁定, 当b解锁后(a还在加锁中), 不会保存a加锁后的中断寄存器状态(直接开中断), 也就是锁a在加锁时, 中断被打开, 导致spin_lock_irq在功能上和spin_lock相同, 也就具备了spin_lock的中断隐患</li>
</ul>
</li>
</ul>
<h3 id="31-a-namealloc_pages_currentaalloc_pages_current">3.1. <!-- raw HTML omitted --><!-- raw HTML omitted -->alloc_pages_current</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span><span style="color:#a6e22e">alloc_pages_current</span>(<span style="color:#66d9ef">gfp_t</span> gfp, <span style="color:#66d9ef">unsigned</span> order)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// pol变量保存内存分配策略(默认为default_policy)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> mempolicy <span style="color:#f92672">*</span>pol <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>default_policy;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果不在中断状态下且未指定在当前结点分配内存时, 使用get_task_policy获得当前进程内存分配策略
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">in_interrupt</span>() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>(gfp <span style="color:#f92672">&amp;</span> __GFP_THISNODE))
</span></span><span style="display:flex;"><span>		pol <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_task_policy</span>(current);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果内存分配策略为MPOL_INTERLEAVE, 则进入alloc_page_interleave
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (pol<span style="color:#f92672">-&gt;</span>mode <span style="color:#f92672">==</span> MPOL_INTERLEAVE)
</span></span><span style="display:flex;"><span>		page <span style="color:#f92672">=</span> <span style="color:#a6e22e">alloc_page_interleave</span>(gfp, order, <span style="color:#a6e22e">interleave_nodes</span>(pol));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		page <span style="color:#f92672">=</span> <span style="color:#a6e22e">__alloc_pages_nodemask</span>(gfp, order,
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">policy_node</span>(gfp, pol, <span style="color:#a6e22e">numa_node_id</span>()),
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">policy_nodemask</span>(gfp, pol));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> page;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="32-a-namealloc_pages_nodemaska__alloc_pages_nodemask">3.2. <!-- raw HTML omitted --><!-- raw HTML omitted -->__alloc_pages_nodemask</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">__alloc_pages_nodemask</span>(<span style="color:#66d9ef">gfp_t</span> gfp_mask, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> order, <span style="color:#66d9ef">int</span> preferred_nid,
</span></span><span style="display:flex;"><span>							<span style="color:#66d9ef">nodemask_t</span> <span style="color:#f92672">*</span>nodemask)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> alloc_flags <span style="color:#f92672">=</span> ALLOC_WMARK_LOW;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">gfp_t</span> alloc_mask; <span style="color:#75715e">/* The gfp_t that was actually used for allocation */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> alloc_context ac <span style="color:#f92672">=</span> { };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果order大于MAX_ORDER(11), 则内存分配失败
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(order <span style="color:#f92672">&gt;=</span> MAX_ORDER)) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">WARN_ON_ONCE</span>(<span style="color:#f92672">!</span>(gfp_mask <span style="color:#f92672">&amp;</span> __GFP_NOWARN));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 添加gfp_allowed_mask标志位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	gfp_mask <span style="color:#f92672">&amp;=</span> gfp_allowed_mask;
</span></span><span style="display:flex;"><span>	alloc_mask <span style="color:#f92672">=</span> gfp_mask;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 填充ac参数(用于内存分配), 并做一些检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">prepare_alloc_pages</span>(gfp_mask, order, preferred_nid, nodemask, <span style="color:#f92672">&amp;</span>ac, <span style="color:#f92672">&amp;</span>alloc_mask, <span style="color:#f92672">&amp;</span>alloc_flags))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 决定是否平衡各个zone中的脏页, 确定zone(相当于对prepare_alloc_pages的补充)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">finalise_ac</span>(gfp_mask, <span style="color:#f92672">&amp;</span>ac);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 给alloc_flags添加ALLOC_NOFRAGMENT标志位(不使用zone备用迁移类型), 如果遍历完本地zone后仍然无法分配内存则取消该标志位, 该方案是为了减少内存碎片
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	alloc_flags <span style="color:#f92672">|=</span> <span style="color:#a6e22e">alloc_flags_nofragment</span>(ac.preferred_zoneref<span style="color:#f92672">-&gt;</span>zone, gfp_mask);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 通过快分配分配内存页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	page <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_page_from_freelist</span>(alloc_mask, order, alloc_flags, <span style="color:#f92672">&amp;</span>ac);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(page))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> out;
</span></span><span style="display:flex;"><span>	alloc_mask <span style="color:#f92672">=</span> <span style="color:#a6e22e">current_gfp_context</span>(gfp_mask);
</span></span><span style="display:flex;"><span>	ac.spread_dirty_pages <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(ac.nodemask <span style="color:#f92672">!=</span> nodemask))
</span></span><span style="display:flex;"><span>		ac.nodemask <span style="color:#f92672">=</span> nodemask;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 通过慢分配分配内存页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	page <span style="color:#f92672">=</span> <span style="color:#a6e22e">__alloc_pages_slowpath</span>(alloc_mask, order, <span style="color:#f92672">&amp;</span>ac);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>out:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">memcg_kmem_enabled</span>() <span style="color:#f92672">&amp;&amp;</span> (gfp_mask <span style="color:#f92672">&amp;</span> __GFP_ACCOUNT) <span style="color:#f92672">&amp;&amp;</span> page <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">__memcg_kmem_charge</span>(page, gfp_mask, order) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">__free_pages</span>(page, order);
</span></span><span style="display:flex;"><span>		page <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">trace_mm_page_alloc</span>(page, order, alloc_mask, ac.migratetype);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> page;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>prepare_alloc_pages</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">prepare_alloc_pages</span>(<span style="color:#66d9ef">gfp_t</span> gfp_mask, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> order,
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> preferred_nid, <span style="color:#66d9ef">nodemask_t</span> <span style="color:#f92672">*</span>nodemask,
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> alloc_context <span style="color:#f92672">*</span>ac, <span style="color:#66d9ef">gfp_t</span> <span style="color:#f92672">*</span>alloc_mask,
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>alloc_flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ac填充从gfp_mask获取的内存分配参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 获得当前nodemask对应的zone的max_index
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ac<span style="color:#f92672">-&gt;</span>high_zoneidx <span style="color:#f92672">=</span> <span style="color:#a6e22e">gfp_zone</span>(gfp_mask);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 获得node对应的zone_list
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ac<span style="color:#f92672">-&gt;</span>zonelist <span style="color:#f92672">=</span> <span style="color:#a6e22e">node_zonelist</span>(preferred_nid, gfp_mask);
</span></span><span style="display:flex;"><span>	ac<span style="color:#f92672">-&gt;</span>nodemask <span style="color:#f92672">=</span> nodemask;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 选择迁移类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ac<span style="color:#f92672">-&gt;</span>migratetype <span style="color:#f92672">=</span> <span style="color:#a6e22e">gfpflags_to_migratetype</span>(gfp_mask);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 判断是否存在cpuset机制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">cpusets_enabled</span>()) {
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>alloc_mask <span style="color:#f92672">|=</span> __GFP_HARDWALL;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ac<span style="color:#f92672">-&gt;</span>nodemask)
</span></span><span style="display:flex;"><span>			ac<span style="color:#f92672">-&gt;</span>nodemask <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>cpuset_current_mems_allowed;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">*</span>alloc_flags <span style="color:#f92672">|=</span> ALLOC_CPUSET;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 函数未实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fs_reclaim_acquire</span>(gfp_mask);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fs_reclaim_release</span>(gfp_mask);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果内存紧张可能会休眠
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">might_sleep_if</span>(gfp_mask <span style="color:#f92672">&amp;</span> __GFP_DIRECT_RECLAIM);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 对gfp_mask, ord做检查(默认没有开启CONFIG_FAIL_PAGE_ALLOC的情况下, 直接return false)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">should_fail_alloc_page</span>(gfp_mask, order))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 匹配CMA机制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">IS_ENABLED</span>(CONFIG_CMA) <span style="color:#f92672">&amp;&amp;</span> ac<span style="color:#f92672">-&gt;</span>migratetype <span style="color:#f92672">==</span> MIGRATE_MOVABLE)
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>alloc_flags <span style="color:#f92672">|=</span> ALLOC_CMA;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>finalise_ac</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">finalise_ac</span>(<span style="color:#66d9ef">gfp_t</span> gfp_mask, <span style="color:#66d9ef">struct</span> alloc_context <span style="color:#f92672">*</span>ac)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Dirty zone balancing only done in the fast path */</span>
</span></span><span style="display:flex;"><span>	ac<span style="color:#f92672">-&gt;</span>spread_dirty_pages <span style="color:#f92672">=</span> (gfp_mask <span style="color:#f92672">&amp;</span> __GFP_WRITE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 从zone_list头部开始寻找匹配nodemask的zoneref
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ac<span style="color:#f92672">-&gt;</span>preferred_zoneref <span style="color:#f92672">=</span> <span style="color:#a6e22e">first_zones_zonelist</span>(ac<span style="color:#f92672">-&gt;</span>zonelist,
</span></span><span style="display:flex;"><span>					ac<span style="color:#f92672">-&gt;</span>high_zoneidx, ac<span style="color:#f92672">-&gt;</span>nodemask);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="321-a-nameget_page_from_freelistaget_page_from_freelist">3.2.1. <!-- raw HTML omitted --><!-- raw HTML omitted -->get_page_from_freelist</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">get_page_from_freelist</span>(<span style="color:#66d9ef">gfp_t</span> gfp_mask, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> order, <span style="color:#66d9ef">int</span> alloc_flags,
</span></span><span style="display:flex;"><span>						<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> alloc_context <span style="color:#f92672">*</span>ac)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> zoneref <span style="color:#f92672">*</span>z;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> zone <span style="color:#f92672">*</span>zone;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> pglist_data <span style="color:#f92672">*</span>last_pgdat_dirty_limit <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> no_fallback;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>retry:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Scan zonelist, looking for a zone with enough free.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ALLOC_NOFRAGMENT标志位由alloc_flags_nofragment()函数设置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// no_fallback: node-&gt;node_zonelists[]包含本node的zones以及备用zones, 设置fallback后可使用备用zones
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	no_fallback <span style="color:#f92672">=</span> alloc_flags <span style="color:#f92672">&amp;</span> ALLOC_NOFRAGMENT;
</span></span><span style="display:flex;"><span>	z <span style="color:#f92672">=</span> ac<span style="color:#f92672">-&gt;</span>preferred_zoneref;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 遍历zone
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">for_next_zone_zonelist_nodemask</span>(zone, z, ac<span style="color:#f92672">-&gt;</span>zonelist, ac<span style="color:#f92672">-&gt;</span>high_zoneidx,
</span></span><span style="display:flex;"><span>								ac<span style="color:#f92672">-&gt;</span>nodemask) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> mark;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 判断cpuset是否开启且当前CPU是否允许在内存域zone所在结点中分配内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">cpusets_enabled</span>() <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>			(alloc_flags <span style="color:#f92672">&amp;</span> ALLOC_CPUSET) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">!</span><span style="color:#a6e22e">__cpuset_zone_allowed</span>(zone, gfp_mask))
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// ac-&gt;spread_dirty_pages不为0表示gfp_mask存在__GFP_WRITE标志位, 有可能增加脏页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (ac<span style="color:#f92672">-&gt;</span>spread_dirty_pages) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (last_pgdat_dirty_limit <span style="color:#f92672">==</span> zone<span style="color:#f92672">-&gt;</span>zone_pgdat)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 如果zone对应的node脏页超标则使用last_pgdat_dirty_limit标识, 并跳过该zone
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">node_dirty_ok</span>(zone<span style="color:#f92672">-&gt;</span>zone_pgdat)) {
</span></span><span style="display:flex;"><span>				last_pgdat_dirty_limit <span style="color:#f92672">=</span> zone<span style="color:#f92672">-&gt;</span>zone_pgdat;
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果设置no_fallback且当前zone并非preferred_zone, 则索引zone-&gt;node, 如果该node并非preferred_zone-&gt;node, 则取消ALLOC_NOFRAGMENT标志位即设置fallback(因为相比于内存碎片, 内存局部性更重要)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (no_fallback <span style="color:#f92672">&amp;&amp;</span> nr_online_nodes <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>		    zone <span style="color:#f92672">!=</span> ac<span style="color:#f92672">-&gt;</span>preferred_zoneref<span style="color:#f92672">-&gt;</span>zone) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> local_nid;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			local_nid <span style="color:#f92672">=</span> <span style="color:#a6e22e">zone_to_nid</span>(ac<span style="color:#f92672">-&gt;</span>preferred_zoneref<span style="color:#f92672">-&gt;</span>zone);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">zone_to_nid</span>(zone) <span style="color:#f92672">!=</span> local_nid) {
</span></span><span style="display:flex;"><span>				alloc_flags <span style="color:#f92672">&amp;=</span> <span style="color:#f92672">~</span>ALLOC_NOFRAGMENT;
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">goto</span> retry;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 获取该zone的水准, 并检查该zone的水位是否水准之上
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		mark <span style="color:#f92672">=</span> <span style="color:#a6e22e">wmark_pages</span>(zone, alloc_flags <span style="color:#f92672">&amp;</span> ALLOC_WMARK_MASK);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">zone_watermark_fast</span>(zone, order, mark,
</span></span><span style="display:flex;"><span>				       <span style="color:#a6e22e">ac_classzone_idx</span>(ac), alloc_flags,
</span></span><span style="display:flex;"><span>				       gfp_mask)) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 如果存在ALLOC_NO_WATERMARKS标志位则忽略水位, 进入try_this_zone
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (alloc_flags <span style="color:#f92672">&amp;</span> ALLOC_NO_WATERMARKS)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">goto</span> try_this_zone;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			static bool zone_allows_reclaim(struct zone *local_zone, struct zone *zone)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">				return node_distance(zone_to_nid(local_zone), zone_to_nid(zone)) &lt;=
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">							node_reclaim_distance;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">			*/</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 如果系统不允许回收内存或者preferred-&gt;zone与当前zone的node_distance大于node_reclaim_distance(默认30), 则更换zone
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (node_reclaim_mode <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>			    <span style="color:#f92672">!</span><span style="color:#a6e22e">zone_allows_reclaim</span>(ac<span style="color:#f92672">-&gt;</span>preferred_zoneref<span style="color:#f92672">-&gt;</span>zone, zone))
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 内存回收
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">node_reclaim</span>(zone<span style="color:#f92672">-&gt;</span>zone_pgdat, gfp_mask, order);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">switch</span> (ret) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">case</span> NODE_RECLAIM_NOSCAN:
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">/* did not scan */</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">case</span> NODE_RECLAIM_FULL:
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">/* scanned but unreclaimable */</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// 内存回收后, 水位正常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">zone_watermark_ok</span>(zone, order, mark,
</span></span><span style="display:flex;"><span>						<span style="color:#a6e22e">ac_classzone_idx</span>(ac), alloc_flags))
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">goto</span> try_this_zone;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>try_this_zone:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 伙伴算法开始分配页内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		page <span style="color:#f92672">=</span> <span style="color:#a6e22e">rmqueue</span>(ac<span style="color:#f92672">-&gt;</span>preferred_zoneref<span style="color:#f92672">-&gt;</span>zone, zone, order,
</span></span><span style="display:flex;"><span>				gfp_mask, alloc_flags, ac<span style="color:#f92672">-&gt;</span>migratetype);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (page) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">prep_new_page</span>(page, order, gfp_mask, alloc_flags);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(order <span style="color:#f92672">&amp;&amp;</span> (alloc_flags <span style="color:#f92672">&amp;</span> ALLOC_HARDER)))
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">reserve_highatomic_pageblock</span>(page, zone, order);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> page;
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		}
</span></span></code></pre></div><h5 id="rmqueue">rmqueue</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span><span style="color:#a6e22e">rmqueue</span>(<span style="color:#66d9ef">struct</span> zone <span style="color:#f92672">*</span>preferred_zone,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">struct</span> zone <span style="color:#f92672">*</span>zone, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> order,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">gfp_t</span> gfp_flags, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> alloc_flags,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> migratetype)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//如果分配单页, 则进入rmqueue_pcplist
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(order <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)) {
</span></span><span style="display:flex;"><span>		page <span style="color:#f92672">=</span> <span style="color:#a6e22e">rmqueue_pcplist</span>(preferred_zone, zone, gfp_flags,
</span></span><span style="display:flex;"><span>					migratetype, alloc_flags);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> out;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 不能使用__GFP_NOFAIL, 分配order&gt;1的页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">WARN_ON_ONCE</span>((gfp_flags <span style="color:#f92672">&amp;</span> __GFP_NOFAIL) <span style="color:#f92672">&amp;&amp;</span> (order <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 使用自旋锁加锁zone资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">spin_lock_irqsave</span>(<span style="color:#f92672">&amp;</span>zone<span style="color:#f92672">-&gt;</span>lock, flags);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>		page <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// ALLOC_HARDER表示高优先级分配, 进入__rmqueue_smallest
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (alloc_flags <span style="color:#f92672">&amp;</span> ALLOC_HARDER) {
</span></span><span style="display:flex;"><span>			page <span style="color:#f92672">=</span> <span style="color:#a6e22e">__rmqueue_smallest</span>(zone, order, MIGRATE_HIGHATOMIC);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (page)
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// 用于debug的插桩设计
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#a6e22e">trace_mm_page_alloc_zone_locked</span>(page, order, migratetype);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 不满足上诉条件或page未分配成功, 进入__rmqueue
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>page)
</span></span><span style="display:flex;"><span>			page <span style="color:#f92672">=</span> <span style="color:#a6e22e">__rmqueue</span>(zone, order, migratetype, alloc_flags);
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">while</span> (page <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">check_new_pages</span>(page, order));
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// check_new_pages遍历page_block中的struct page, 检查page成员, 如果出错则打印错误原因
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">spin_unlock</span>(<span style="color:#f92672">&amp;</span>zone<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>page)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> failed;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// page_block被分配后更新zone成员信息 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">__mod_zone_freepage_state</span>(zone, <span style="color:#f92672">-</span>(<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> order),
</span></span><span style="display:flex;"><span>				  <span style="color:#a6e22e">get_pcppage_migratetype</span>(page));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">__count_zid_vm_events</span>(PGALLOC, <span style="color:#a6e22e">page_zonenum</span>(page), <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> order);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果系统是NUMA架构, 则更新NUMA hit/miss 数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">zone_statistics</span>(preferred_zone, zone);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 恢复中断信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">local_irq_restore</span>(flags);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>out:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Separate test+clear to avoid unnecessary atomics */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">test_bit</span>(ZONE_BOOSTED_WATERMARK, <span style="color:#f92672">&amp;</span>zone<span style="color:#f92672">-&gt;</span>flags)) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">clear_bit</span>(ZONE_BOOSTED_WATERMARK, <span style="color:#f92672">&amp;</span>zone<span style="color:#f92672">-&gt;</span>flags);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">wakeup_kswapd</span>(zone, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">zone_idx</span>(zone));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 编译阶段的变量类型检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">VM_BUG_ON_PAGE</span>(page <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">bad_range</span>(zone, page), page);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> page;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>failed:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">local_irq_restore</span>(flags);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h6 id="rmqueue_pcplis">rmqueue_pcplis</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span><span style="color:#a6e22e">rmqueue_pcplist</span>(<span style="color:#66d9ef">struct</span> zone <span style="color:#f92672">*</span>preferred_zone,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">struct</span> zone <span style="color:#f92672">*</span>zone, <span style="color:#66d9ef">gfp_t</span> gfp_flags,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> migratetype, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> alloc_flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> per_cpu_pages <span style="color:#f92672">*</span>pcp;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>list;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 禁用全部中断, 并将当前中断状态保存至flags
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">local_irq_save</span>(flags);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 获得当前cpu的pcp结构体(热页)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	pcp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">this_cpu_ptr</span>(zone<span style="color:#f92672">-&gt;</span>pageset)<span style="color:#f92672">-&gt;</span>pcp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 根据迁移类型选择热页链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	list <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>pcp<span style="color:#f92672">-&gt;</span>lists[migratetype];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 在list中分配内存页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	page <span style="color:#f92672">=</span> <span style="color:#a6e22e">__rmqueue_pcplist</span>(zone,  migratetype, alloc_flags, pcp, list);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (page) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">__count_zid_vm_events</span>(PGALLOC, <span style="color:#a6e22e">page_zonenum</span>(page), <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Update NUMA hit/miss statistics
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">zone_statistics</span>(preferred_zone, zone);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 恢复中断状态并开中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">local_irq_restore</span>(flags);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> page;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<ul>
<li>__rmqueue_pcplist</li>
</ul>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span><span style="color:#a6e22e">__rmqueue_pcplist</span>(<span style="color:#66d9ef">struct</span> zone <span style="color:#f92672">*</span>zone, <span style="color:#66d9ef">int</span> migratetype,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> alloc_flags,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">struct</span> per_cpu_pages <span style="color:#f92672">*</span>pcp,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>list)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果列表为空, 则使用rmqueue_bulk装载内存页进入列表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">list_empty</span>(list)) {
</span></span><span style="display:flex;"><span>			pcp<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">+=</span> <span style="color:#a6e22e">rmqueue_bulk</span>(zone, <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>					pcp<span style="color:#f92672">-&gt;</span>batch, list,
</span></span><span style="display:flex;"><span>					migratetype, alloc_flags);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">list_empty</span>(list)))
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 获得lru列表首部页结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		page <span style="color:#f92672">=</span> <span style="color:#a6e22e">list_first_entry</span>(list, <span style="color:#66d9ef">struct</span> page, lru);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 将页结点从page-&gt;lru列表删除
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">list_del</span>(<span style="color:#f92672">&amp;</span>page<span style="color:#f92672">-&gt;</span>lru);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 空闲page计数器-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		pcp<span style="color:#f92672">-&gt;</span>count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 对page做安全检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	} <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">check_new_pcp</span>(page));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> page;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<blockquote>
<ul>
<li>rmqueue_bulk</li>
</ul>
</blockquote>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">rmqueue_bulk</span>(<span style="color:#66d9ef">struct</span> zone <span style="color:#f92672">*</span>zone, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> order,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> count, <span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>list,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> migratetype, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> alloc_flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> i, alloced <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 对zone资源加锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">spin_lock</span>(<span style="color:#f92672">&amp;</span>zone<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> count; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 从zone中取出page放入pcp热页缓存列表, 直至pcp被填满
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page <span style="color:#f92672">=</span> <span style="color:#a6e22e">__rmqueue</span>(zone, order, migratetype,
</span></span><span style="display:flex;"><span>								alloc_flags);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(page <span style="color:#f92672">==</span> NULL))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// check_pcp_refill封装check_new_page
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">check_pcp_refill</span>(page)))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 添加page至list-&gt;lru
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">list_add_tail</span>(<span style="color:#f92672">&amp;</span>page<span style="color:#f92672">-&gt;</span>lru, list);
</span></span><span style="display:flex;"><span>		alloced<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果page位于cma中, 则更新NR_FREE_CMA_PAGES
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">is_migrate_cma</span>(<span style="color:#a6e22e">get_pcppage_migratetype</span>(page)))
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">__mod_zone_page_state</span>(zone, NR_FREE_CMA_PAGES,
</span></span><span style="display:flex;"><span>					      <span style="color:#f92672">-</span>(<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> order));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 从zone摘取page_block过程循环了i次, 每个page_block包含2^i个page, NR_FREE_PAGES-i &lt;&lt; order, 更新NR_FREE_PAGES
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">__mod_zone_page_state</span>(zone, NR_FREE_PAGES, <span style="color:#f92672">-</span>(i <span style="color:#f92672">&lt;&lt;</span> order));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 解锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">spin_unlock</span>(<span style="color:#f92672">&amp;</span>zone<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> alloced;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h6 id="__rmqueue_smallest">__rmqueue_smallest</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> __always_inline
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span><span style="color:#a6e22e">__rmqueue_smallest</span>(<span style="color:#66d9ef">struct</span> zone <span style="color:#f92672">*</span>zone, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> order,
</span></span><span style="display:flex;"><span>						<span style="color:#66d9ef">int</span> migratetype)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> current_order;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> free_area <span style="color:#f92672">*</span>area;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 从指定order到MAX_ORDER遍历zone-&gt;free_area[]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> (current_order <span style="color:#f92672">=</span> order; current_order <span style="color:#f92672">&lt;</span> MAX_ORDER; <span style="color:#f92672">++</span>current_order) {
</span></span><span style="display:flex;"><span>		area <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>(zone<span style="color:#f92672">-&gt;</span>free_area[current_order]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 从zone-&gt;free_area[][migratetype]-&gt;lru链表头部获得page()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		page <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_page_from_free_area</span>(area, migratetype);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>page)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 从zone-&gt;free_area[][migratetype]-&gt;lru中删除page, 更新zone成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">del_page_from_free_area</span>(page, area);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 将current_order阶的page_block拆成小块,并将小块放到对应的阶的链表中去
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">expand</span>(zone, page, order, current_order, area, migratetype);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 设置page迁移类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">set_pcppage_migratetype</span>(page, migratetype);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> page;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h6 id="__rmqueue">__rmqueue</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> __always_inline <span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">__rmqueue</span>(<span style="color:#66d9ef">struct</span> zone <span style="color:#f92672">*</span>zone, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> order, <span style="color:#66d9ef">int</span> migratetype,
</span></span><span style="display:flex;"><span>						<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> alloc_flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>retry:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 使用__rmqueue_smallest获得page
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	page <span style="color:#f92672">=</span> <span style="color:#a6e22e">__rmqueue_smallest</span>(zone, order, migratetype);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span>page)) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// page分配失败后, 如果迁移类型是MIGRATE_MOVABLE, 进入__rmqueue_cma_fallback
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (migratetype <span style="color:#f92672">==</span> MIGRATE_MOVABLE)
</span></span><span style="display:flex;"><span>			page <span style="color:#f92672">=</span> <span style="color:#a6e22e">__rmqueue_cma_fallback</span>(zone, order);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// page分配再次失败后使用判断是否可以使用备用迁移类型(如果可以则修改order, migratetype)然后跳转进入retry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>page <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">__rmqueue_fallback</span>(zone, order, migratetype,
</span></span><span style="display:flex;"><span>								alloc_flags))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> retry;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">trace_mm_page_alloc_zone_locked</span>(page, order, migratetype);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> page;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<ul>
<li>__rmqueue_fallback</li>
</ul>
</blockquote>
<ol>
<li>备用迁移类型</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> fallbacks[MIGRATE_TYPES][<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>	[MIGRATE_UNMOVABLE]   <span style="color:#f92672">=</span> { MIGRATE_RECLAIMABLE, MIGRATE_MOVABLE,   MIGRATE_TYPES },
</span></span><span style="display:flex;"><span>	[MIGRATE_MOVABLE]     <span style="color:#f92672">=</span> { MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE, MIGRATE_TYPES },
</span></span><span style="display:flex;"><span>	[MIGRATE_RECLAIMABLE] <span style="color:#f92672">=</span> { MIGRATE_UNMOVABLE,   MIGRATE_MOVABLE,   MIGRATE_TYPES },
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_CMA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_MEMORY_ISOLATION
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><ol start="2">
<li>__rmqueue_fallback</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> __always_inline <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">__rmqueue_fallback</span>(<span style="color:#66d9ef">struct</span> zone <span style="color:#f92672">*</span>zone, <span style="color:#66d9ef">int</span> order, <span style="color:#66d9ef">int</span> start_migratetype,
</span></span><span style="display:flex;"><span>						<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> alloc_flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> free_area <span style="color:#f92672">*</span>area;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> current_order;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> min_order <span style="color:#f92672">=</span> order;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> fallback_mt;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> can_steal;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果设置alloc_flags为ALLOC_NOFRAGMENT(内存碎片优化), min_order=pageblock_order(MAX_ORDER-1)---尽可能分配大页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (alloc_flags <span style="color:#f92672">&amp;</span> ALLOC_NOFRAGMENT)
</span></span><span style="display:flex;"><span>		min_order <span style="color:#f92672">=</span> pageblock_order;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 遍历zone-&gt;free_area[order](order=MAX_ORDER-1~min_order)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> (current_order <span style="color:#f92672">=</span> MAX_ORDER <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; current_order <span style="color:#f92672">&gt;=</span> min_order;
</span></span><span style="display:flex;"><span>				<span style="color:#f92672">--</span>current_order) {
</span></span><span style="display:flex;"><span>		area <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>(zone<span style="color:#f92672">-&gt;</span>free_area[current_order]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 查找可以盗取的迁移类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		fallback_mt <span style="color:#f92672">=</span> <span style="color:#a6e22e">find_suitable_fallback</span>(area, current_order,
</span></span><span style="display:flex;"><span>				start_migratetype, false, <span style="color:#f92672">&amp;</span>can_steal);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (fallback_mt <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果can_steal=0且迁移类型为MIGRATE_MOVABLE, 当前所在的order大于需求order, 跳转进入find_smallest
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 这里的can_steal=0并不表示不能盗取, 只是对于迁移类型为MIGRATE_MOVABLE的内存分配需求有更好的解决方法(窃取和拆分最小的可用页块而不是最大的可用页块)所以单独列出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>can_steal <span style="color:#f92672">&amp;&amp;</span> start_migratetype <span style="color:#f92672">==</span> MIGRATE_MOVABLE
</span></span><span style="display:flex;"><span>					<span style="color:#f92672">&amp;&amp;</span> current_order <span style="color:#f92672">&gt;</span> order)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> find_smallest;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> do_steal;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>find_smallest:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 从最小的order开始遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> (current_order <span style="color:#f92672">=</span> order; current_order <span style="color:#f92672">&lt;</span> MAX_ORDER;
</span></span><span style="display:flex;"><span>							current_order<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		area <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>(zone<span style="color:#f92672">-&gt;</span>free_area[current_order]);
</span></span><span style="display:flex;"><span>		fallback_mt <span style="color:#f92672">=</span> <span style="color:#a6e22e">find_suitable_fallback</span>(area, current_order,
</span></span><span style="display:flex;"><span>				start_migratetype, false, <span style="color:#f92672">&amp;</span>can_steal);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (fallback_mt <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">VM_BUG_ON</span>(current_order <span style="color:#f92672">==</span> MAX_ORDER);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>do_steal:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 获得备用迁移类型对应的page_block
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	page <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_page_from_free_area</span>(area, fallback_mt);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 判断直接盗取(改变page_block的迁移类型), 还是借用(分配但不改变页块迁移类型)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">steal_suitable_fallback</span>(zone, page, alloc_flags, start_migratetype,
</span></span><span style="display:flex;"><span>								can_steal);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">trace_mm_page_alloc_extfrag</span>(page, order, current_order,
</span></span><span style="display:flex;"><span>		start_migratetype, fallback_mt);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<blockquote>
<ul>
<li>find_suitable_fallback</li>
</ul>
</blockquote>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find_suitable_fallback</span>(<span style="color:#66d9ef">struct</span> free_area <span style="color:#f92672">*</span>area, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> order,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> migratetype, <span style="color:#66d9ef">bool</span> only_stealable, <span style="color:#66d9ef">bool</span> <span style="color:#f92672">*</span>can_steal)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> fallback_mt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 判断该order内存链表是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (area<span style="color:#f92672">-&gt;</span>nr_free <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>can_steal <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 遍历备用迁移类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		fallback_mt <span style="color:#f92672">=</span> fallbacks[migratetype][i];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// MIGRATE_TYPES表示不可用, 退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (fallback_mt <span style="color:#f92672">==</span> MIGRATE_TYPES)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果area-&gt;free_list[fallback_mt]为空, 遍历下一个备用迁移类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">free_area_empty</span>(area, fallback_mt))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 判断是否可盗取
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">can_steal_fallback</span>(order, migratetype))
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">*</span>can_steal <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>only_stealable)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> fallback_mt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>can_steal)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> fallback_mt;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<blockquote>
<blockquote>
<ul>
<li>can_steal_fallback</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">can_steal_fallback</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> order, <span style="color:#66d9ef">int</span> start_mt)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 判断order是否大于等于MAX_ORDER-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (order <span style="color:#f92672">&gt;=</span> pageblock_order)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果order&gt;=(MAX_ORDER-1)/2 或者 迁移类型为MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE 或者 page_group_by_mobility_disabled=1(gdb动调发现默认为0) 则表示可以盗取
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (order <span style="color:#f92672">&gt;=</span> pageblock_order <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>		start_mt <span style="color:#f92672">==</span> MIGRATE_RECLAIMABLE <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>		start_mt <span style="color:#f92672">==</span> MIGRATE_UNMOVABLE <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>		page_group_by_mobility_disabled)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="322-a-namealloc_pages_slowpatha_alloc_pages_slowpath">3.2.2. <!-- raw HTML omitted --><!-- raw HTML omitted -->_alloc_pages_slowpath</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">__alloc_pages_slowpath</span>(<span style="color:#66d9ef">gfp_t</span> gfp_mask, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> order,
</span></span><span style="display:flex;"><span>						<span style="color:#66d9ef">struct</span> alloc_context <span style="color:#f92672">*</span>ac)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> can_direct_reclaim <span style="color:#f92672">=</span> gfp_mask <span style="color:#f92672">&amp;</span> __GFP_DIRECT_RECLAIM;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// PAGE_ALLOC_COSTLY_ORDER=3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">bool</span> costly_order <span style="color:#f92672">=</span> order <span style="color:#f92672">&gt;</span> PAGE_ALLOC_COSTLY_ORDER;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> alloc_flags;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> did_some_progress;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">enum</span> compact_priority compact_priority;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">enum</span> compact_result compact_result;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> compaction_retries;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> no_progress_loops;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> cpuset_mems_cookie;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> reserve_flags;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果内存分配标志包含__GFP_ATOMIC(来自不能阻塞或延迟和失败没有回调的原子上下文的请求), __GFP_DIRECT_RECLAIM(可以直接回收, 表示有回收需要时会阻塞请求), 明显二者冲突, 此处做一个校验
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">WARN_ON_ONCE</span>((gfp_mask <span style="color:#f92672">&amp;</span> (__GFP_ATOMIC<span style="color:#f92672">|</span>__GFP_DIRECT_RECLAIM)) <span style="color:#f92672">==</span>
</span></span><span style="display:flex;"><span>				(__GFP_ATOMIC<span style="color:#f92672">|</span>__GFP_DIRECT_RECLAIM)))
</span></span><span style="display:flex;"><span>		gfp_mask <span style="color:#f92672">&amp;=</span> <span style="color:#f92672">~</span>__GFP_ATOMIC;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>retry_cpuset:
</span></span><span style="display:flex;"><span>	compaction_retries <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	no_progress_loops <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	compact_priority <span style="color:#f92672">=</span> DEF_COMPACT_PRIORITY;
</span></span><span style="display:flex;"><span>	cpuset_mems_cookie <span style="color:#f92672">=</span> <span style="color:#a6e22e">read_mems_allowed_begin</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 降低要求, 重新构建标志位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	alloc_flags <span style="color:#f92672">=</span> <span style="color:#a6e22e">gfp_to_alloc_flags</span>(gfp_mask);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ac<span style="color:#f92672">-&gt;</span>preferred_zoneref <span style="color:#f92672">=</span> <span style="color:#a6e22e">first_zones_zonelist</span>(ac<span style="color:#f92672">-&gt;</span>zonelist,
</span></span><span style="display:flex;"><span>					ac<span style="color:#f92672">-&gt;</span>high_zoneidx, ac<span style="color:#f92672">-&gt;</span>nodemask);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ac<span style="color:#f92672">-&gt;</span>preferred_zoneref<span style="color:#f92672">-&gt;</span>zone)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> nopage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果设置了ALLOC_KSWAPD, 则唤醒交换进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (alloc_flags <span style="color:#f92672">&amp;</span> ALLOC_KSWAPD)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">wake_all_kswapds</span>(order, gfp_mask, ac);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 内存调整后再次分配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	page <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_page_from_freelist</span>(gfp_mask, order, alloc_flags, ac);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (page)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> got_pg;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果满足以下条件则尝试进行内存压缩
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 1. 如果标识__GFP_DIRECT_RECLAIM&amp;ALLOC_NO_WATERMARK且order&gt;3(costly_order=1)则进入__alloc_pages_direct_compact
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 2. 如果标识__GFP_DIRECT_RECLAIM&amp;ALLOC_NO_WATERMARK且order&lt;3(costly_order=0)且迁移类型不为MIGRATE_MOVABLE则进入__alloc_pages_direct_compact
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (can_direct_reclaim <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>			(costly_order <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>			   (order <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> ac<span style="color:#f92672">-&gt;</span>migratetype <span style="color:#f92672">!=</span> MIGRATE_MOVABLE))
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">gfp_pfmemalloc_allowed</span>(gfp_mask)) {
</span></span><span style="display:flex;"><span>		page <span style="color:#f92672">=</span> <span style="color:#a6e22e">__alloc_pages_direct_compact</span>(gfp_mask, order,
</span></span><span style="display:flex;"><span>						alloc_flags, ac,
</span></span><span style="display:flex;"><span>						INIT_COMPACT_PRIORITY,
</span></span><span style="display:flex;"><span>						<span style="color:#f92672">&amp;</span>compact_result);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (page)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> got_pg;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 设置压缩参数, 后面会专门讲解这部分
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (order <span style="color:#f92672">&gt;=</span> pageblock_order <span style="color:#f92672">&amp;&amp;</span> (gfp_mask <span style="color:#f92672">&amp;</span> __GFP_IO) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>		     <span style="color:#f92672">!</span>(gfp_mask <span style="color:#f92672">&amp;</span> __GFP_RETRY_MAYFAIL)) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (compact_result <span style="color:#f92672">==</span> COMPACT_SKIPPED <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>			    compact_result <span style="color:#f92672">==</span> COMPACT_DEFERRED)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">goto</span> nopage;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (costly_order <span style="color:#f92672">&amp;&amp;</span> (gfp_mask <span style="color:#f92672">&amp;</span> __GFP_NORETRY)) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (compact_result <span style="color:#f92672">==</span> COMPACT_DEFERRED)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">goto</span> nopage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			compact_priority <span style="color:#f92672">=</span> INIT_COMPACT_PRIORITY;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>retry:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 再次唤醒交换进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (alloc_flags <span style="color:#f92672">&amp;</span> ALLOC_KSWAPD)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">wake_all_kswapds</span>(order, gfp_mask, ac);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	reserve_flags <span style="color:#f92672">=</span> <span style="color:#a6e22e">__gfp_pfmemalloc_flags</span>(gfp_mask);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (reserve_flags)
</span></span><span style="display:flex;"><span>		alloc_flags <span style="color:#f92672">=</span> reserve_flags;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果cpu不允许在zone所在node中分配内存且可以进行no_water_mark分配则通过ac-&gt;nodemask = NULL降低内存分配标准, 再次分配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(alloc_flags <span style="color:#f92672">&amp;</span> ALLOC_CPUSET) <span style="color:#f92672">||</span> reserve_flags) {
</span></span><span style="display:flex;"><span>		ac<span style="color:#f92672">-&gt;</span>nodemask <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>		ac<span style="color:#f92672">-&gt;</span>preferred_zoneref <span style="color:#f92672">=</span> <span style="color:#a6e22e">first_zones_zonelist</span>(ac<span style="color:#f92672">-&gt;</span>zonelist,
</span></span><span style="display:flex;"><span>					ac<span style="color:#f92672">-&gt;</span>high_zoneidx, ac<span style="color:#f92672">-&gt;</span>nodemask);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	page <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_page_from_freelist</span>(gfp_mask, order, alloc_flags, ac);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (page)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> got_pg;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>can_direct_reclaim)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> nopage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (current<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> PF_MEMALLOC)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> nopage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 内存回收后分配内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	page <span style="color:#f92672">=</span> <span style="color:#a6e22e">__alloc_pages_direct_reclaim</span>(gfp_mask, order, alloc_flags, ac,
</span></span><span style="display:flex;"><span>							<span style="color:#f92672">&amp;</span>did_some_progress);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (page)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> got_pg;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 内存压缩后分配内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	page <span style="color:#f92672">=</span> <span style="color:#a6e22e">__alloc_pages_direct_compact</span>(gfp_mask, order, alloc_flags, ac,
</span></span><span style="display:flex;"><span>					compact_priority, <span style="color:#f92672">&amp;</span>compact_result);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (page)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> got_pg;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (gfp_mask <span style="color:#f92672">&amp;</span> __GFP_NORETRY)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> nopage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (costly_order <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>(gfp_mask <span style="color:#f92672">&amp;</span> __GFP_RETRY_MAYFAIL))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> nopage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 分析是否应该再次内存回收
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">should_reclaim_retry</span>(gfp_mask, order, ac, alloc_flags,
</span></span><span style="display:flex;"><span>				 did_some_progress <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>no_progress_loops))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> retry;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 分析是否应该再次内存压缩
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (did_some_progress <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">should_compact_retry</span>(ac, order, alloc_flags,
</span></span><span style="display:flex;"><span>				compact_result, <span style="color:#f92672">&amp;</span>compact_priority,
</span></span><span style="display:flex;"><span>				<span style="color:#f92672">&amp;</span>compaction_retries))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> retry;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">check_retry_cpuset</span>(cpuset_mems_cookie, ac))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> retry_cpuset;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 杀死一些进程以获得内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	page <span style="color:#f92672">=</span> <span style="color:#a6e22e">__alloc_pages_may_oom</span>(gfp_mask, order, ac, <span style="color:#f92672">&amp;</span>did_some_progress);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (page)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> got_pg;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">tsk_is_oom_victim</span>(current) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>	    (alloc_flags <span style="color:#f92672">==</span> ALLOC_OOM <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>	     (gfp_mask <span style="color:#f92672">&amp;</span> __GFP_NOMEMALLOC)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> nopage;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (did_some_progress) {
</span></span><span style="display:flex;"><span>		no_progress_loops <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> retry;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>nopage:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">check_retry_cpuset</span>(cpuset_mems_cookie, ac))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> retry_cpuset;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (gfp_mask <span style="color:#f92672">&amp;</span> __GFP_NOFAIL) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">WARN_ON_ONCE</span>(<span style="color:#f92672">!</span>can_direct_reclaim))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> fail;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">WARN_ON_ONCE</span>(current<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> PF_MEMALLOC);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">WARN_ON_ONCE</span>(order <span style="color:#f92672">&gt;</span> PAGE_ALLOC_COSTLY_ORDER);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 使用ALLOC_HARDER标志进行内存分配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		page <span style="color:#f92672">=</span> <span style="color:#a6e22e">__alloc_pages_cpuset_fallback</span>(gfp_mask, order, ALLOC_HARDER, ac);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (page)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> got_pg;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">cond_resched</span>();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> retry;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>fail:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">warn_alloc</span>(gfp_mask, ac<span style="color:#f92672">-&gt;</span>nodemask,
</span></span><span style="display:flex;"><span>			<span style="color:#e6db74">&#34;page allocation failure: order:%u&#34;</span>, order);
</span></span><span style="display:flex;"><span>got_pg:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> page;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="4-a-namefree_pagesa_free_pages源码分析">4. <!-- raw HTML omitted --><!-- raw HTML omitted -->_free_pages源码分析</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__free_pages</span>(<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> order)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 检查并更新(-1)page-&gt;_refcount, 当page-&gt;_refcount=0时, return true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">put_page_testzero</span>(page))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果order=0 --&gt; free_unref_page
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 如果order&gt;0 --&gt; __free_pages_ok 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">free_the_page</span>(page, order);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="41-a-namefree_unref_pageafree_unref_page">4.1. <!-- raw HTML omitted --><!-- raw HTML omitted -->free_unref_page</h3>
<ul>
<li>free_unref_page -&gt; free_unref_page_commit</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">free_unref_page_commit</span>(<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> pfn)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> zone <span style="color:#f92672">*</span>zone <span style="color:#f92672">=</span> <span style="color:#a6e22e">page_zone</span>(page);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> per_cpu_pages <span style="color:#f92672">*</span>pcp;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> migratetype;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 获得迁移类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	migratetype <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_pcppage_migratetype</span>(page);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">__count_vm_event</span>(PGFREE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// pcp_list 只放置unmovable, reclaimable, movable类型page
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 大于等于MIGRATE_PCPTYPES的迁移类型中MIGRATE_ISOLATE不能被放入pcp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (migratetype <span style="color:#f92672">&gt;=</span> MIGRATE_PCPTYPES) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">is_migrate_isolate</span>(migratetype))) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 放入伙伴系统
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">free_one_page</span>(zone, page, pfn, <span style="color:#ae81ff">0</span>, migratetype);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		migratetype <span style="color:#f92672">=</span> MIGRATE_MOVABLE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	pcp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">this_cpu_ptr</span>(zone<span style="color:#f92672">-&gt;</span>pageset)<span style="color:#f92672">-&gt;</span>pcp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 将page放入pcp-&gt;lists[migratetype]链表表头
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">list_add</span>(<span style="color:#f92672">&amp;</span>page<span style="color:#f92672">-&gt;</span>lru, <span style="color:#f92672">&amp;</span>pcp<span style="color:#f92672">-&gt;</span>lists[migratetype]);
</span></span><span style="display:flex;"><span>	pcp<span style="color:#f92672">-&gt;</span>count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果pcp-&gt;count(pcp中页数目) &gt;= pcp-&gt;high(pcp中最大页数目), 则将多余的page放入伙伴系统
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (pcp<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">&gt;=</span> pcp<span style="color:#f92672">-&gt;</span>high) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> batch <span style="color:#f92672">=</span> <span style="color:#a6e22e">READ_ONCE</span>(pcp<span style="color:#f92672">-&gt;</span>batch);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">free_pcppages_bulk</span>(zone, batch, pcp);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="411-a-namefree_pcppages_bulkafree_pcppages_bulk">4.1.1. <!-- raw HTML omitted --><!-- raw HTML omitted -->free_pcppages_bulk</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">free_pcppages_bulk</span>(<span style="color:#66d9ef">struct</span> zone <span style="color:#f92672">*</span>zone, <span style="color:#66d9ef">int</span> count,
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">struct</span> per_cpu_pages <span style="color:#f92672">*</span>pcp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> migratetype <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> batch_free <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> prefetch_nr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> isolated_pageblocks;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page, <span style="color:#f92672">*</span>tmp;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">LIST_HEAD</span>(head);
</span></span><span style="display:flex;"><span>	count <span style="color:#f92672">=</span> <span style="color:#a6e22e">min</span>(pcp<span style="color:#f92672">-&gt;</span>count, count);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 通过循环遍历迁移类型列表, 依次递增删除页数(batch_free)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> (count) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> list_head <span style="color:#f92672">*</span>list;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>			batch_free<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 循环查询pcp-&gt;lists[migratetype]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">++</span>migratetype <span style="color:#f92672">==</span> MIGRATE_PCPTYPES)
</span></span><span style="display:flex;"><span>				migratetype <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			list <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>pcp<span style="color:#f92672">-&gt;</span>lists[migratetype];
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">list_empty</span>(list));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 只有一个迁移类型非空, 在这里释放全部count
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (batch_free <span style="color:#f92672">==</span> MIGRATE_PCPTYPES)
</span></span><span style="display:flex;"><span>			batch_free <span style="color:#f92672">=</span> count;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 从列表尾部获得page
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			page <span style="color:#f92672">=</span> <span style="color:#a6e22e">list_last_entry</span>(list, <span style="color:#66d9ef">struct</span> page, lru);
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">list_del</span>(<span style="color:#f92672">&amp;</span>page<span style="color:#f92672">-&gt;</span>lru);
</span></span><span style="display:flex;"><span>			pcp<span style="color:#f92672">-&gt;</span>count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">bulkfree_pcp_prepare</span>(page))
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 将取出的page全部放入以head为头的链表中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">list_add_tail</span>(<span style="color:#f92672">&amp;</span>page<span style="color:#f92672">-&gt;</span>lru, <span style="color:#f92672">&amp;</span>head);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 数据预取可以加快速度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (prefetch_nr<span style="color:#f92672">++</span> <span style="color:#f92672">&lt;</span> pcp<span style="color:#f92672">-&gt;</span>batch)
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">prefetch_buddy</span>(page);
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">while</span> (<span style="color:#f92672">--</span>count <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">--</span>batch_free <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">list_empty</span>(list));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">spin_lock</span>(<span style="color:#f92672">&amp;</span>zone<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>	isolated_pageblocks <span style="color:#f92672">=</span> <span style="color:#a6e22e">has_isolate_pageblock</span>(zone);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">list_for_each_entry_safe</span>(page, tmp, <span style="color:#f92672">&amp;</span>head, lru) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 获得迁移类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">int</span> mt <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_pcppage_migratetype</span>(page);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 迁移类型不能是isolated
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">VM_BUG_ON_PAGE</span>(<span style="color:#a6e22e">is_migrate_isolate</span>(mt), page);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(isolated_pageblocks))
</span></span><span style="display:flex;"><span>			mt <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_pageblock_migratetype</span>(page);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 释放page进入伙伴算法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">__free_one_page</span>(page, <span style="color:#a6e22e">page_to_pfn</span>(page), zone, <span style="color:#ae81ff">0</span>, mt);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">trace_mm_page_pcpu_drain</span>(page, <span style="color:#ae81ff">0</span>, mt);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">spin_unlock</span>(<span style="color:#f92672">&amp;</span>zone<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="42-a-namefree_pages_oka__free_pages_ok">4.2. <!-- raw HTML omitted --><!-- raw HTML omitted -->__free_pages_ok</h3>
<ul>
<li>__free_pages_ok -&gt; free_one_page</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">free_one_page</span>(<span style="color:#66d9ef">struct</span> zone <span style="color:#f92672">*</span>zone,
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> pfn,
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> order,
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">int</span> migratetype)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">spin_lock</span>(<span style="color:#f92672">&amp;</span>zone<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 判断zone是否存在isolate迁移类型, page是否是isolate迁移类型(一般没有这个配置)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">has_isolate_pageblock</span>(zone) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">is_migrate_isolate</span>(migratetype))) {
</span></span><span style="display:flex;"><span>		migratetype <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_pfnblock_migratetype</span>(page, pfn);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">__free_one_page</span>(page, pfn, zone, order, migratetype);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">spin_unlock</span>(<span style="color:#f92672">&amp;</span>zone<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="421-a-namefree_one_pagea__free_one_page">4.2.1. <!-- raw HTML omitted --><!-- raw HTML omitted -->__free_one_page</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__free_one_page</span>(<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page,
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> pfn,
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> zone <span style="color:#f92672">*</span>zone, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> order,
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> migratetype)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> combined_pfn;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">uninitialized_var</span>(buddy_pfn);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>buddy;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> max_order;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> capture_control <span style="color:#f92672">*</span>capc <span style="color:#f92672">=</span> <span style="color:#a6e22e">task_capc</span>(zone);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	max_order <span style="color:#f92672">=</span> <span style="color:#66d9ef">min_t</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>, MAX_ORDER, pageblock_order <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">VM_BUG_ON</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">zone_is_initialized</span>(zone));
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">VM_BUG_ON_PAGE</span>(page<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> PAGE_FLAGS_CHECK_AT_PREP, page);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">VM_BUG_ON</span>(migratetype <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">is_migrate_isolate</span>(migratetype)))
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 更新zone状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">__mod_zone_freepage_state</span>(zone, <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> order, migratetype);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">VM_BUG_ON_PAGE</span>(pfn <span style="color:#f92672">&amp;</span> ((<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> order) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>), page);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">VM_BUG_ON_PAGE</span>(<span style="color:#a6e22e">bad_range</span>(zone, page), page);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>continue_merging:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 循环遍历直到order = max_order - 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> (order <span style="color:#f92672">&lt;</span> max_order <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">compaction_capture</span>(capc, page, order, migratetype)) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">__mod_zone_freepage_state</span>(zone, <span style="color:#f92672">-</span>(<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> order),
</span></span><span style="display:flex;"><span>								migratetype);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// buddy_pfn = page_pfn ^ (1 &lt;&lt; order);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 定位兄弟页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		buddy_pfn <span style="color:#f92672">=</span> <span style="color:#a6e22e">__find_buddy_pfn</span>(pfn, order);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 获得兄弟页的struct page
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		buddy <span style="color:#f92672">=</span> page <span style="color:#f92672">+</span> (buddy_pfn <span style="color:#f92672">-</span> pfn);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 判断buddy_pfn是否有效
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">pfn_valid_within</span>(buddy_pfn))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> done_merging;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 1. buddy_ord == order
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 2. buddy_zone == zone
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 3. buddy-&gt;_refcount == 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 若满足以上条件则buddy可合并
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">page_is_buddy</span>(page, buddy, order))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> done_merging;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// it is CONFIG_DEBUG_PAGEALLOC guard page
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">page_is_guard</span>(buddy))
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">clear_page_guard</span>(zone, buddy, order, migratetype);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 将buddy从对应free_area[order]中删除
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">del_page_from_free_area</span>(buddy, <span style="color:#f92672">&amp;</span>zone<span style="color:#f92672">-&gt;</span>free_area[order]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 设置合并页的struct page以及pfn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		combined_pfn <span style="color:#f92672">=</span> buddy_pfn <span style="color:#f92672">&amp;</span> pfn;
</span></span><span style="display:flex;"><span>		page <span style="color:#f92672">=</span> page <span style="color:#f92672">+</span> (combined_pfn <span style="color:#f92672">-</span> pfn);
</span></span><span style="display:flex;"><span>		pfn <span style="color:#f92672">=</span> combined_pfn;
</span></span><span style="display:flex;"><span>		order<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (max_order <span style="color:#f92672">&lt;</span> MAX_ORDER) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* If we are here, it means order is &gt;= pageblock_order.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * We want to prevent merge between freepages on isolate
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * pageblock and normal pageblock. Without this, pageblock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * isolation could cause incorrect freepage or CMA accounting.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * We don&#39;t want to hit this code for the more frequent
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * low-order merging.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">has_isolate_pageblock</span>(zone))) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> buddy_mt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			buddy_pfn <span style="color:#f92672">=</span> <span style="color:#a6e22e">__find_buddy_pfn</span>(pfn, order);
</span></span><span style="display:flex;"><span>			buddy <span style="color:#f92672">=</span> page <span style="color:#f92672">+</span> (buddy_pfn <span style="color:#f92672">-</span> pfn);
</span></span><span style="display:flex;"><span>			buddy_mt <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_pageblock_migratetype</span>(buddy);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (migratetype <span style="color:#f92672">!=</span> buddy_mt
</span></span><span style="display:flex;"><span>					<span style="color:#f92672">&amp;&amp;</span> (<span style="color:#a6e22e">is_migrate_isolate</span>(migratetype) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>						<span style="color:#a6e22e">is_migrate_isolate</span>(buddy_mt)))
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">goto</span> done_merging;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		max_order<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> continue_merging;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>done_merging:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 设置page的阶数, 将page标记为伙伴系统页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">set_page_order</span>(page, order);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果page并不是最大的page, 检查伙伴页是否是free状态的, 如果是, 但是上述步骤合并失败则有可能伙伴页正在被释放, 这时候应该把page放在zone-&gt;free_area[order]尾部(延缓page被分配出去), 这样等伙伴页释放完成后就可以一起被合并成更大的page了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> ((order <span style="color:#f92672">&lt;</span> MAX_ORDER<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">pfn_valid_within</span>(buddy_pfn)
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">is_shuffle_order</span>(order)) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>higher_page, <span style="color:#f92672">*</span>higher_buddy;
</span></span><span style="display:flex;"><span>		combined_pfn <span style="color:#f92672">=</span> buddy_pfn <span style="color:#f92672">&amp;</span> pfn;
</span></span><span style="display:flex;"><span>		higher_page <span style="color:#f92672">=</span> page <span style="color:#f92672">+</span> (combined_pfn <span style="color:#f92672">-</span> pfn);
</span></span><span style="display:flex;"><span>		buddy_pfn <span style="color:#f92672">=</span> <span style="color:#a6e22e">__find_buddy_pfn</span>(combined_pfn, order <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>		higher_buddy <span style="color:#f92672">=</span> higher_page <span style="color:#f92672">+</span> (buddy_pfn <span style="color:#f92672">-</span> combined_pfn);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">pfn_valid_within</span>(buddy_pfn) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>		    <span style="color:#a6e22e">page_is_buddy</span>(higher_page, higher_buddy, order <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 把page置入zone-&gt;free_area[order]链表尾部
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">add_to_free_area_tail</span>(page, <span style="color:#f92672">&amp;</span>zone<span style="color:#f92672">-&gt;</span>free_area[order],
</span></span><span style="display:flex;"><span>					      migratetype);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">is_shuffle_order</span>(order))
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 获得随机数, 随机决定放在头还是尾???
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">add_to_free_area_random</span>(page, <span style="color:#f92672">&amp;</span>zone<span style="color:#f92672">-&gt;</span>free_area[order],
</span></span><span style="display:flex;"><span>				migratetype);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 把page置入zone-&gt;free_area[order]链表头部
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">add_to_free_area</span>(page, <span style="color:#f92672">&amp;</span>zone<span style="color:#f92672">-&gt;</span>free_area[order], migratetype);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="5-a-nameslubaslub算法">5. <!-- raw HTML omitted --><!-- raw HTML omitted -->slub算法</h2>
<ul>
<li>slab_debug 下的object:
<ul>
<li>kmem_cache缓冲区建立后, 所有内存空间用POISON_INUSE(0X5a)填充</li>
<li>object被释放后用POISON_FREE(0X6b)填充</li>
<li>read_left_pad, red_zone用特殊字节填充, 用作magic_num</li>
</ul>
</li>
</ul>
<p><img src="../../mm/obj.png" alt="obj"></p>
<ul>
<li>kmem_cache_alloc概略图</li>
</ul>
<p><img src="../../mm/kmem_cache_alloc.png" alt="kmem_cache_alloc"></p>
<ul>
<li>kmem_cache_free概略图</li>
</ul>
<p><img src="../../mm/kmem_cache_free.png" alt="kmem_cache_free"></p>
<h3 id="51-a-name-1a结构体解析">5.1. <!-- raw HTML omitted --><!-- raw HTML omitted -->结构体解析</h3>
<ul>
<li>kmem_cache结构体</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> kmem_cache {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> kmem_cache_cpu __percpu <span style="color:#f92672">*</span>cpu_slab;		<span style="color:#75715e">// per cpu变量, cpu本地内存缓存池, 存储slab
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">slab_flags_t</span> flags;								<span style="color:#75715e">// object分配掩码	
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> min_partial;						<span style="color:#75715e">// kmem_cache_node中的partial链表slab的数量上限, 超过限度多余的slab会被释放
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> size;								<span style="color:#75715e">// 被分配的object真实大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> object_size;						<span style="color:#75715e">// 用户申请的obj_size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> offset;							<span style="color:#75715e">// slub将要被分配出去的obj中存储下一个空闲obj指针(next_obj), 而存储这个空闲obj指针的地址就用obj-&gt;offset来表示
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#ifdef CONFIG_SLUB_CPU_PARTIAL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> cpu_partial;						<span style="color:#75715e">// 如果cpu_slab中存在partial链表, 那么该值将作为partial链表数量上限, 超过上限后全部slab将被转移到kmem_cache_node中的partial链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> kmem_cache_order_objects oo;				<span style="color:#75715e">// 低16位代表一个slab中所有object的数量(oo &amp; ((1 &lt;&lt; 16) - 1)), 高16位代表一个slab管理的page数量((2^(oo  16)) pages)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> kmem_cache_order_objects max;			<span style="color:#75715e">// max=oo, 表示最大分配量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> kmem_cache_order_objects min;			<span style="color:#75715e">// min功能与oo, max相同, 表示最小分配量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">gfp_t</span> allocflags;								<span style="color:#75715e">// 从伙伴系统继承的内存掩码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> refcount;									<span style="color:#75715e">// 重用计数器, 当用户请求创建的slub分配器大小与已经创建的slub分配器相似时, 计数+1, 进行slub重用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> inuse;								<span style="color:#75715e">// 元数据偏移量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> align;								<span style="color:#75715e">// 字节对齐大小			
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name;								<span style="color:#75715e">// sysfs文件系统显示使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> list_head list;							<span style="color:#75715e">// 挂载所有的slab
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> kmem_cache_node <span style="color:#f92672">*</span>node[MAX_NUMNODES];		<span style="color:#75715e">// slab节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><ul>
<li>kmem_cache_cpu结构体</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> kmem_cache_cpu {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#f92672">**</span>freelist;								<span style="color:#75715e">// 指向下一个可用空闲obj
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> tid;								<span style="color:#75715e">// 相当于cpu的标识, 用于辨别cpu是否被抢占, 用于同步
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page;								<span style="color:#75715e">// 当前正在被分配的slab
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#ifdef CONFIG_SLUB_CPU_PARTIAL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>partial;							<span style="color:#75715e">// 指向曾分配完所有的obj，但当前已回收至少一个对象的slab
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><ul>
<li>kmem_cache_node结构体</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> kmem_cache_node {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">spinlock_t</span> list_lock;							<span style="color:#75715e">// 保护node资源的自旋锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#ifdef CONFIG_SLUB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> nr_partial;						<span style="color:#75715e">// 本结点partial_slab数目
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> list_head partial;						<span style="color:#75715e">// partial_slab链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><h2 id="6-a-namekmem_cache_allocakmem_cache_alloc源码分析">6. <!-- raw HTML omitted --><!-- raw HTML omitted -->kmem_cache_alloc源码分析</h2>
<ul>
<li>kmem_cache_alloc() -&gt; slab_alloc() -&gt; slab_alloc_node()</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> __always_inline <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">slab_alloc_node</span>(<span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>s,
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">gfp_t</span> gfpflags, <span style="color:#66d9ef">int</span> node, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>object;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> kmem_cache_cpu <span style="color:#f92672">*</span>c;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> tid;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 对keme_cache做预处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	s <span style="color:#f92672">=</span> <span style="color:#a6e22e">slab_pre_alloc_hook</span>(s, gfpflags);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>s)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>redo:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// tid, c是通过两次读取cpu获得, 如果抢占模式被开启, 有可能两次获取的cpu不同, 这里每次读取tid和c之后都会比较tid是否等于c-&gt;tid, 如果不相等, 则说明两次数据读取对应的cpu不同, 则再次读取数据, 直至相同(构造的很精巧, 比关闭抢占提升了效率) 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>		tid <span style="color:#f92672">=</span> <span style="color:#a6e22e">this_cpu_read</span>(s<span style="color:#f92672">-&gt;</span>cpu_slab<span style="color:#f92672">-&gt;</span>tid);
</span></span><span style="display:flex;"><span>		c <span style="color:#f92672">=</span> <span style="color:#a6e22e">raw_cpu_ptr</span>(s<span style="color:#f92672">-&gt;</span>cpu_slab);
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">IS_ENABLED</span>(CONFIG_PREEMPT) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>		 <span style="color:#a6e22e">unlikely</span>(tid <span style="color:#f92672">!=</span> <span style="color:#a6e22e">READ_ONCE</span>(c<span style="color:#f92672">-&gt;</span>tid)));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 屏障, 保证上面和下面的代码因为优化而相互影响
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">barrier</span>();
</span></span><span style="display:flex;"><span>	object <span style="color:#f92672">=</span> c<span style="color:#f92672">-&gt;</span>freelist;
</span></span><span style="display:flex;"><span>	page <span style="color:#f92672">=</span> c<span style="color:#f92672">-&gt;</span>page;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果当前cpu的空闲列表为空或当前正在使用的页为空或page-&gt;node与node不匹配则进入__slab_alloc慢分配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span>object <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>page <span style="color:#f92672">||</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">node_match</span>(page, node))) {
</span></span><span style="display:flex;"><span>		object <span style="color:#f92672">=</span> <span style="color:#a6e22e">__slab_alloc</span>(s, gfpflags, node, addr, c);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">stat</span>(s, ALLOC_SLOWPATH);
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// freepointer_addr = (unsigned long)object + s-&gt;offset;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// probe_kernel_read(&amp;p, (void **)freepointer_addr, sizeof(p));
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// return freelist_ptr(s, p, freepointer_addr);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// get_freepointer_safe: 通过s-&gt;offset偏移获得存储下一个空闲obj的地址, 然后使用probe_kernel_read安全的将obj地址写入p中, freelist_ptr在没有定义CONFIG_SLAB_FREELIST_HARDENED时直接返回p
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>next_object <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_freepointer_safe</span>(s, object);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 判断this_cpu(s-&gt;cpu_slab-&gt;freelist)是否等于object且this_cpu(s-&gt;cpu_slab-&gt;tid)是否等于tid, 如果成立则this_cpu(s-&gt;cpu_slab-&gt;freelist)=next_object, this_cpu(s-&gt;cpu_slab-&gt;tid)=tid+1, 否则return false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// this_cpu_cmpxchg_double将上诉操作变成原子操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">this_cpu_cmpxchg_double</span>(
</span></span><span style="display:flex;"><span>				s<span style="color:#f92672">-&gt;</span>cpu_slab<span style="color:#f92672">-&gt;</span>freelist, s<span style="color:#f92672">-&gt;</span>cpu_slab<span style="color:#f92672">-&gt;</span>tid,
</span></span><span style="display:flex;"><span>				object, tid,
</span></span><span style="display:flex;"><span>				next_object, <span style="color:#a6e22e">next_tid</span>(tid)))) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 如果失败则重新获取obj
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">note_cmpxchg_failure</span>(<span style="color:#e6db74">&#34;slab_alloc&#34;</span>, s, tid);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> redo;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 预热链表, 增加下次命中几率
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">prefetch_freepointer</span>(s, next_object);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 记录状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">stat</span>(s, ALLOC_FASTPATH);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">maybe_wipe_obj_freeptr</span>(s, object);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">slab_want_init_on_alloc</span>(gfpflags, s)) <span style="color:#f92672">&amp;&amp;</span> object)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">memset</span>(object, <span style="color:#ae81ff">0</span>, s<span style="color:#f92672">-&gt;</span>object_size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 分析了以下这里kasan_slab_alloc直接返回原值, kmemleak_alloc_recursive为空, 如果slab开始分配时memcg_kmem_enabled有意义, 这里再做一下后续的扫尾工作(因为是hook函数所以初始功能极少)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">slab_post_alloc_hook</span>(s, gfpflags, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>object);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> object;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="61-a-nameslab_alloca__slab_alloc">6.1. <!-- raw HTML omitted --><!-- raw HTML omitted -->__slab_alloc</h3>
<ul>
<li>__slab_alloc -&gt; ___slab_alloc</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">___slab_alloc</span>(<span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>s, <span style="color:#66d9ef">gfp_t</span> gfpflags, <span style="color:#66d9ef">int</span> node,
</span></span><span style="display:flex;"><span>			  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr, <span style="color:#66d9ef">struct</span> kmem_cache_cpu <span style="color:#f92672">*</span>c)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>freelist;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果c-&gt;page为空, 代表cpu_slab中没有可用slab, 进入new_slab向cpu_slab中填充可用slab
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	page <span style="color:#f92672">=</span> c<span style="color:#f92672">-&gt;</span>page;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>page) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果node不在线或者node没有正常内存, 则忽略node约束
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(node <span style="color:#f92672">!=</span> NUMA_NO_NODE <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>			     <span style="color:#f92672">!</span><span style="color:#a6e22e">node_state</span>(node, N_NORMAL_MEMORY)))
</span></span><span style="display:flex;"><span>			node <span style="color:#f92672">=</span> NUMA_NO_NODE;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> new_slab;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>redo:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 判断page-&gt;node与node是否相同
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">node_match</span>(page, node))) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// node_state: return 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">node_state</span>(node, N_NORMAL_MEMORY)) {
</span></span><span style="display:flex;"><span>			node <span style="color:#f92672">=</span> NUMA_NO_NODE;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> redo;
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 记录状态node_miss_match
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">stat</span>(s, ALLOC_NODE_MISMATCH);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 将cpu_slab中的page放入node中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">deactivate_slab</span>(s, page, c<span style="color:#f92672">-&gt;</span>freelist, c);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> new_slab;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// PF_MEMALLOC: 忽略内存管理的水印进行分配, 分配失败则不再尝试, 如果当前page是pfmemalloc属性, 则调用deactivate_slab
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">pfmemalloc_match</span>(page, gfpflags))) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">deactivate_slab</span>(s, page, c<span style="color:#f92672">-&gt;</span>freelist, c);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> new_slab;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 检查freelist, 防止cpu迁移或中断导致freelist非空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	freelist <span style="color:#f92672">=</span> c<span style="color:#f92672">-&gt;</span>freelist;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (freelist)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> load_freelist;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 从c-&gt;page中获得freelist
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	freelist <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_freelist</span>(s, page);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>freelist) {
</span></span><span style="display:flex;"><span>		c<span style="color:#f92672">-&gt;</span>page <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">stat</span>(s, DEACTIVATE_BYPASS);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> new_slab;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">stat</span>(s, ALLOC_REFILL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>load_freelist:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// c-&gt;page对应被分配的obj所在的page, 应该被cpu冻结
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">VM_BUG_ON</span>(<span style="color:#f92672">!</span>c<span style="color:#f92672">-&gt;</span>page<span style="color:#f92672">-&gt;</span>frozen);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 更新cpu_slab的freelist, tid
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	c<span style="color:#f92672">-&gt;</span>freelist <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_freepointer</span>(s, freelist);
</span></span><span style="display:flex;"><span>	c<span style="color:#f92672">-&gt;</span>tid <span style="color:#f92672">=</span> <span style="color:#a6e22e">next_tid</span>(c<span style="color:#f92672">-&gt;</span>tid);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> freelist;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>new_slab:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 判断cpu_slab是否存在partial_slab(部分空间被使用的page)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">slub_percpu_partial</span>(c)) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 将partial_slab作为c-&gt;page(用来分配obj)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		page <span style="color:#f92672">=</span> c<span style="color:#f92672">-&gt;</span>page <span style="color:#f92672">=</span> <span style="color:#a6e22e">slub_percpu_partial</span>(c);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// #define slub_set_percpu_partial(c, p) (slub_percpu_partial(c) = (p)-&gt;next;})
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 更新partial链表头为page-&gt;next
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">slub_set_percpu_partial</span>(c, page);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">stat</span>(s, CPU_PARTIAL_ALLOC);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> redo;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// new_slab_objects: 1. get_partial(从node-&gt;partial获取page) 2. new_slab(伙伴算法获取page)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 从上述page中获得freelist
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	freelist <span style="color:#f92672">=</span> <span style="color:#a6e22e">new_slab_objects</span>(s, gfpflags, node, <span style="color:#f92672">&amp;</span>c);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span>freelist)) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 内存分配失败
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 配置CONFIG_SLUB_DEBUG后会打印报错信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">slab_out_of_memory</span>(s, gfpflags, node);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	page <span style="color:#f92672">=</span> c<span style="color:#f92672">-&gt;</span>page;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">kmem_cache_debug</span>(s) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">pfmemalloc_match</span>(page, gfpflags)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> load_freelist;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// kmem_cache_debug判断kmem_cache标志位是否包含SLAB_DEBUG_FLAGS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// alloc_debug_processing: return 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">kmem_cache_debug</span>(s) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">!</span><span style="color:#a6e22e">alloc_debug_processing</span>(s, page, freelist, addr))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> new_slab;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">deactivate_slab</span>(s, page, <span style="color:#a6e22e">get_freepointer</span>(s, freelist), c);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> freelist;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="611-a-nameget_freelistaget_freelist">6.1.1. <!-- raw HTML omitted --><!-- raw HTML omitted -->get_freelist</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">get_freelist</span>(<span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>s, <span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> page new;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> counters;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>freelist;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>		freelist <span style="color:#f92672">=</span> page<span style="color:#f92672">-&gt;</span>freelist;
</span></span><span style="display:flex;"><span>		counters <span style="color:#f92672">=</span> page<span style="color:#f92672">-&gt;</span>counters;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 获得下一个freelist
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		new.counters <span style="color:#f92672">=</span> counters;
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">VM_BUG_ON</span>(<span style="color:#f92672">!</span>new.frozen);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		new.inuse <span style="color:#f92672">=</span> page<span style="color:#f92672">-&gt;</span>objects;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// The page is still frozen if the return value is not NULL.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		new.frozen <span style="color:#f92672">=</span> freelist <span style="color:#f92672">!=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// page-&gt;freelist=NULL, page-&gt;counters=new.counters
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 将page-&gt;freelist从page中摘除, 后续会放进cpu_slab-&gt;freelist中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	} <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">__cmpxchg_double_slab</span>(s, page,
</span></span><span style="display:flex;"><span>		freelist, counters,
</span></span><span style="display:flex;"><span>		NULL, new.counters,
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;get_freelist&#34;</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> freelist;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="7-a-namekmem_cache_freeakmem_cache_free源码分析">7. <!-- raw HTML omitted --><!-- raw HTML omitted -->kmem_cache_free源码分析</h2>
<ol>
<li>kmem_cache_free -&gt; cache_from_obj(定位目标kmem_cache)</li>
<li>kmem_cache_free -&gt; slab_free</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> __always_inline <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">slab_free</span>(<span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>s, <span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page,
</span></span><span style="display:flex;"><span>				      <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>head, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>tail, <span style="color:#66d9ef">int</span> cnt,
</span></span><span style="display:flex;"><span>				      <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">slab_free_freelist_hook</span>(s, <span style="color:#f92672">&amp;</span>head, <span style="color:#f92672">&amp;</span>tail))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">do_slab_free</span>(s, page, head, tail, cnt, addr);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>slab_free -&gt; slab_free_freelist_hook</li>
<li>slab_free -&gt; do_slab_free</li>
</ul>
<h3 id="71-a-namecache_from_objacache_from_obj">7.1. <!-- raw HTML omitted --><!-- raw HTML omitted -->cache_from_obj</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span><span style="color:#a6e22e">cache_from_obj</span>(<span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>s, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>cachep;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果memcg没有开启且没有配置CONFIG_SLAB_FREELIST_HARDENED,kem_cache没有配置SLAB_CONSISTENCY_CHECKS, 则直接返回用户选择的kmem_cache
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">memcg_kmem_enabled</span>() <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#f92672">!</span><span style="color:#a6e22e">IS_ENABLED</span>(CONFIG_SLAB_FREELIST_HARDENED) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#f92672">!</span><span style="color:#a6e22e">unlikely</span>(s<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> SLAB_CONSISTENCY_CHECKS))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> s;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// virt_to_cache -&gt; virt_to_head_page -&gt; virt_to_page获得page
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 返回page-&gt;slab_cache作为kmem_cache(因为用户选择的kmem_cache不可信)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	cachep <span style="color:#f92672">=</span> <span style="color:#a6e22e">virt_to_cache</span>(x);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">WARN_ONCE</span>(cachep <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">slab_equal_or_root</span>(cachep, s),
</span></span><span style="display:flex;"><span>		  <span style="color:#e6db74">&#34;%s: Wrong slab cache. %s but object is from %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>		  __func__, s<span style="color:#f92672">-&gt;</span>name, cachep<span style="color:#f92672">-&gt;</span>name);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> cachep;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="72-a-nameslab_free_freelist_hookaslab_free_freelist_hook">7.2. <!-- raw HTML omitted --><!-- raw HTML omitted -->slab_free_freelist_hook</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">slab_free_freelist_hook</span>(<span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>s,
</span></span><span style="display:flex;"><span>					   <span style="color:#66d9ef">void</span> <span style="color:#f92672">**</span>head, <span style="color:#66d9ef">void</span> <span style="color:#f92672">**</span>tail)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>object;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>next <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>head;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>old_tail <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>tail <span style="color:#f92672">?</span> <span style="color:#f92672">*</span>tail : <span style="color:#f92672">*</span>head;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> rsize;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>head <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>tail <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 依次遍历freelist
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		object <span style="color:#f92672">=</span> next;
</span></span><span style="display:flex;"><span>		next <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_freepointer</span>(s, object);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">slab_want_init_on_free</span>(s)) {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 将object清空(red_zone区域除外)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">memset</span>(object, <span style="color:#ae81ff">0</span>, s<span style="color:#f92672">-&gt;</span>object_size);
</span></span><span style="display:flex;"><span>			rsize <span style="color:#f92672">=</span> (s<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> SLAB_RED_ZONE) <span style="color:#f92672">?</span> s<span style="color:#f92672">-&gt;</span>red_left_pad
</span></span><span style="display:flex;"><span>							   : <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">memset</span>((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)object <span style="color:#f92672">+</span> s<span style="color:#f92672">-&gt;</span>inuse, <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>			       s<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">-</span> s<span style="color:#f92672">-&gt;</span>inuse <span style="color:#f92672">-</span> rsize);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// slab_free_hook内部功能函数实现为空 return false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">slab_free_hook</span>(s, object)) {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// *object-&gt;offset=*head
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">set_freepointer</span>(s, object, <span style="color:#f92672">*</span>head);
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">*</span>head <span style="color:#f92672">=</span> object;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!*</span>tail)
</span></span><span style="display:flex;"><span>				<span style="color:#f92672">*</span>tail <span style="color:#f92672">=</span> object;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">while</span> (object <span style="color:#f92672">!=</span> old_tail);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>head <span style="color:#f92672">==</span> <span style="color:#f92672">*</span>tail)
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>tail <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>head <span style="color:#f92672">!=</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="73-a-namedo_slab_freeado_slab_free">7.3. <!-- raw HTML omitted --><!-- raw HTML omitted -->do_slab_free</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> __always_inline <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">do_slab_free</span>(<span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>s,
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>head, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>tail,
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">int</span> cnt, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>tail_obj <span style="color:#f92672">=</span> tail <span style="color:#f92672">?</span> <span style="color:#f92672">:</span> head;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> kmem_cache_cpu <span style="color:#f92672">*</span>c;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> tid;
</span></span><span style="display:flex;"><span>redo:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 使用tid保持cpu同步
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>		tid <span style="color:#f92672">=</span> <span style="color:#a6e22e">this_cpu_read</span>(s<span style="color:#f92672">-&gt;</span>cpu_slab<span style="color:#f92672">-&gt;</span>tid);
</span></span><span style="display:flex;"><span>		c <span style="color:#f92672">=</span> <span style="color:#a6e22e">raw_cpu_ptr</span>(s<span style="color:#f92672">-&gt;</span>cpu_slab);
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">IS_ENABLED</span>(CONFIG_PREEMPT) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>		 <span style="color:#a6e22e">unlikely</span>(tid <span style="color:#f92672">!=</span> <span style="color:#a6e22e">READ_ONCE</span>(c<span style="color:#f92672">-&gt;</span>tid)));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 和slab_alloc_node()中的barrier作用相同
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">barrier</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果待释放obj所属的page并不是cpu_slab对应的page则进入__slab_free慢释放
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(page <span style="color:#f92672">==</span> c<span style="color:#f92672">-&gt;</span>page)) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span> <span style="color:#f92672">**</span>freelist <span style="color:#f92672">=</span> <span style="color:#a6e22e">READ_ONCE</span>(c<span style="color:#f92672">-&gt;</span>freelist);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// tail_obj是待插入的obj, set_freepointer: *(tail_obj-&gt;offset)=freelist(原freelist)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">set_freepointer</span>(s, tail_obj, freelist);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 验证cpu没有被抢占后, 使得s-&gt;cpu_slab-&gt;freelist=head(tail_obj), tid=next_tid(tid), tail_obj成功插入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">this_cpu_cmpxchg_double</span>(
</span></span><span style="display:flex;"><span>				s<span style="color:#f92672">-&gt;</span>cpu_slab<span style="color:#f92672">-&gt;</span>freelist, s<span style="color:#f92672">-&gt;</span>cpu_slab<span style="color:#f92672">-&gt;</span>tid,
</span></span><span style="display:flex;"><span>				freelist, tid,
</span></span><span style="display:flex;"><span>				head, <span style="color:#a6e22e">next_tid</span>(tid)))) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">note_cmpxchg_failure</span>(<span style="color:#e6db74">&#34;slab_free&#34;</span>, s, tid);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> redo;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">stat</span>(s, FREE_FASTPATH);
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">__slab_free</span>(s, page, head, tail_obj, cnt, addr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="731-a-nameslab_freea__slab_free">7.3.1. <!-- raw HTML omitted --><!-- raw HTML omitted -->__slab_free</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__slab_free</span>(<span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>s, <span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>head, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>tail, <span style="color:#66d9ef">int</span> cnt,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>prior;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> was_frozen;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> page new;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> counters;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> kmem_cache_node <span style="color:#f92672">*</span>n <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// uninitialized_var消除没有初始化的警告
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">uninitialized_var</span>(flags);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">stat</span>(s, FREE_SLOWPATH);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">kmem_cache_debug</span>(s) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#f92672">!</span><span style="color:#a6e22e">free_debug_processing</span>(s, page, head, tail, cnt, addr))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// n置空, 释放free_debug_processing()设置的自旋锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(n)) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">spin_unlock_irqrestore</span>(<span style="color:#f92672">&amp;</span>n<span style="color:#f92672">-&gt;</span>list_lock, flags);
</span></span><span style="display:flex;"><span>			n <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		prior <span style="color:#f92672">=</span> page<span style="color:#f92672">-&gt;</span>freelist;
</span></span><span style="display:flex;"><span>		counters <span style="color:#f92672">=</span> page<span style="color:#f92672">-&gt;</span>counters;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// tail是待插入的obj, set_freepointer: *(tail_obj-&gt;offset)=freelist(原freelist)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">set_freepointer</span>(s, tail, prior);
</span></span><span style="display:flex;"><span>		new.counters <span style="color:#f92672">=</span> counters;
</span></span><span style="display:flex;"><span>		was_frozen <span style="color:#f92672">=</span> new.frozen;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// inuse_obj = inuse_obj - cnt, 当前page释放了cnt(1)个obj
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		new.inuse <span style="color:#f92672">-=</span> cnt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果该page(不存在正被使用的obj或者无可被使用的obj)且没有被冻结(不属于cpu_slab), 说明正在被释放的obj是该page的最后一个被使用的obj, 该page可被放入buddy
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> ((<span style="color:#f92672">!</span>new.inuse <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>prior) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>was_frozen) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 如果kmem_cache存在cpu_slab-&gt;partial且该page无可用obj则冻结page, 后续会被放入cpu_slab-&gt;partial
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">kmem_cache_has_cpu_partial</span>(s) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>prior) {
</span></span><span style="display:flex;"><span>				new.frozen <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// 获得node, 加锁node资源区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				n <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_node</span>(s, <span style="color:#a6e22e">page_to_nid</span>(page));
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">spin_lock_irqsave</span>(<span style="color:#f92672">&amp;</span>n<span style="color:#f92672">-&gt;</span>list_lock, flags);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 释放head(正在被释放的obj)进入page(page-&gt;freelist=head, page-&gt;counters=new.counters)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	} <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">cmpxchg_double_slab</span>(s, page,
</span></span><span style="display:flex;"><span>		prior, counters,
</span></span><span style="display:flex;"><span>		head, new.counters,
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;__slab_free&#34;</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(<span style="color:#f92672">!</span>n)) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果page没有被冻结, 则将page挂载进入cpu_slab-&gt;partial
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (new.frozen <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>was_frozen) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">put_cpu_partial</span>(s, page, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">stat</span>(s, CPU_PARTIAL_FREE);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// page被冻结后只更新&#34;FREE_FROZEN&#34;信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (was_frozen)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">stat</span>(s, FREE_FROZEN);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果page无obj被使用, 且kmem_cache的半满page超过临界点(n-&gt;nr_partial &gt;= s-&gt;min_partial), 则进行page释放
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span>new.inuse <span style="color:#f92672">&amp;&amp;</span> n<span style="color:#f92672">-&gt;</span>nr_partial <span style="color:#f92672">&gt;=</span> s<span style="color:#f92672">-&gt;</span>min_partial))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> slab_empty;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 释放obj后slab从full变为partial
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">kmem_cache_has_cpu_partial</span>(s) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span>prior)) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 将slab从full链表删除, 插入n-&gt;partial链表尾部
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">remove_full</span>(s, n, page);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">add_partial</span>(n, page, DEACTIVATE_TO_TAIL);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">stat</span>(s, FREE_ADD_PARTIAL);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 解锁node资源区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">spin_unlock_irqrestore</span>(<span style="color:#f92672">&amp;</span>n<span style="color:#f92672">-&gt;</span>list_lock, flags);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>slab_empty:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (prior) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果该page存在可用obj, 则该page会在partial链表, 所以在partial链表中将page删除
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">remove_partial</span>(n, page);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">stat</span>(s, FREE_REMOVE_PARTIAL);
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 将page从full链表中删除
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">remove_full</span>(s, n, page);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">spin_unlock_irqrestore</span>(<span style="color:#f92672">&amp;</span>n<span style="color:#f92672">-&gt;</span>list_lock, flags);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">stat</span>(s, FREE_SLAB);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">discard_slab</span>(s, page);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="discard_slab">discard_slab</h5>
<ol>
<li>discard_slab-&gt;dec_slabs_node(更新node信息)</li>
<li>discard_slab-&gt;free_slab-&gt;__free_slab</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__free_slab</span>(<span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>s, <span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 获得page_order
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> order <span style="color:#f92672">=</span> <span style="color:#a6e22e">compound_order</span>(page);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> pages <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> order;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (s<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> SLAB_CONSISTENCY_CHECKS) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>p;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 对page做安全检查 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">slab_pad_check</span>(s, page);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 对page中的每个obj进行安全检测
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">for_each_object</span>(p, s, <span style="color:#a6e22e">page_address</span>(page),
</span></span><span style="display:flex;"><span>						page<span style="color:#f92672">-&gt;</span>objects)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">check_object</span>(s, page, p, SLUB_RED_INACTIVE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 清除page标志位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">__ClearPageSlabPfmemalloc</span>(page);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">__ClearPageSlab</span>(page);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// page不再被引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	page<span style="color:#f92672">-&gt;</span>mapping <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 更新内存回收状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (current<span style="color:#f92672">-&gt;</span>reclaim_state)
</span></span><span style="display:flex;"><span>		current<span style="color:#f92672">-&gt;</span>reclaim_state<span style="color:#f92672">-&gt;</span>reclaimed_slab <span style="color:#f92672">+=</span> pages;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 更新系统状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">uncharge_slab_page</span>(page, order, s);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 伙伴算法释放内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">__free_pages</span>(page, order);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h6 id="slab_pad_check">slab_pad_check</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 当slab_debug开启后, kmem_cache建立时, 内存空间全部被覆写成0x5a, 一个slab被切割成obj时有可能不能被完全利用, 可能会剩余一些空间(padding), 又因为padding区域在内存分配期间不会被修改, 所以应该一直是0x5a, 本函数通过对0x5a进行检测, 试图发现溢出覆写错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">slab_pad_check</span>(<span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>s, <span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	u8 <span style="color:#f92672">*</span>start;
</span></span><span style="display:flex;"><span>	u8 <span style="color:#f92672">*</span>fault;
</span></span><span style="display:flex;"><span>	u8 <span style="color:#f92672">*</span>end;
</span></span><span style="display:flex;"><span>	u8 <span style="color:#f92672">*</span>pad;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> length;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> remainder;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果kmem_cache没有配置SLAB_POISON则直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(s<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> SLAB_POISON))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	start <span style="color:#f92672">=</span> <span style="color:#a6e22e">page_address</span>(page);
</span></span><span style="display:flex;"><span>	length <span style="color:#f92672">=</span> <span style="color:#a6e22e">page_size</span>(page);
</span></span><span style="display:flex;"><span>	end <span style="color:#f92672">=</span> start <span style="color:#f92672">+</span> length;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 获得切割obj后slab的剩余空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	remainder <span style="color:#f92672">=</span> length <span style="color:#f92672">%</span> s<span style="color:#f92672">-&gt;</span>size;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>remainder)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	pad <span style="color:#f92672">=</span> end <span style="color:#f92672">-</span> remainder;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">metadata_access_enable</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 访问元数据查看POISON_INUSE magic是否被修改, 定位错误的起始位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	fault <span style="color:#f92672">=</span> <span style="color:#a6e22e">memchr_inv</span>(pad, POISON_INUSE, remainder);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">metadata_access_disable</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>fault)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 定位数据覆盖的结尾
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> (end <span style="color:#f92672">&gt;</span> fault <span style="color:#f92672">&amp;&amp;</span> end[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> POISON_INUSE)
</span></span><span style="display:flex;"><span>		end<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 抛出错误, 打印错误覆盖区间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">slab_err</span>(s, page, <span style="color:#e6db74">&#34;Padding overwritten. 0x%p-0x%p&#34;</span>, fault, end <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">print_section</span>(KERN_ERR, <span style="color:#e6db74">&#34;Padding &#34;</span>, pad, remainder);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">restore_bytes</span>(s, <span style="color:#e6db74">&#34;slab padding&#34;</span>, POISON_INUSE, fault, end);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h6 id="check_object">check_object</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 讲解slub算法的开头, 列出了有关slab_debug所用到的magic_num以及obj内存布局, 本函数对magic_num和freelist进行安全检测
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">check_object</span>(<span style="color:#66d9ef">struct</span> kmem_cache <span style="color:#f92672">*</span>s, <span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page,
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>object, u8 val)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	u8 <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> object;
</span></span><span style="display:flex;"><span>	u8 <span style="color:#f92672">*</span>endobject <span style="color:#f92672">=</span> object <span style="color:#f92672">+</span> s<span style="color:#f92672">-&gt;</span>object_size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果kmem_cache区域配置了SLAB_RED_ZONE, 则对相应的magic_num进行检测
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (s<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> SLAB_RED_ZONE) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 检测red_left_pad
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">check_bytes_and_report</span>(s, page, object, <span style="color:#e6db74">&#34;Redzone&#34;</span>,
</span></span><span style="display:flex;"><span>			object <span style="color:#f92672">-</span> s<span style="color:#f92672">-&gt;</span>red_left_pad, val, s<span style="color:#f92672">-&gt;</span>red_left_pad))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 检测Redzone
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">check_bytes_and_report</span>(s, page, object, <span style="color:#e6db74">&#34;Redzone&#34;</span>,
</span></span><span style="display:flex;"><span>			endobject, val, s<span style="color:#f92672">-&gt;</span>inuse <span style="color:#f92672">-</span> s<span style="color:#f92672">-&gt;</span>object_size))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ((s<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> SLAB_POISON) <span style="color:#f92672">&amp;&amp;</span> s<span style="color:#f92672">-&gt;</span>object_size <span style="color:#f92672">&lt;</span> s<span style="color:#f92672">-&gt;</span>inuse) {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 检测padding区域
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">check_bytes_and_report</span>(s, page, p, <span style="color:#e6db74">&#34;Alignment padding&#34;</span>,
</span></span><span style="display:flex;"><span>				endobject, POISON_INUSE,
</span></span><span style="display:flex;"><span>				s<span style="color:#f92672">-&gt;</span>inuse <span style="color:#f92672">-</span> s<span style="color:#f92672">-&gt;</span>object_size);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (s<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> SLAB_POISON) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (val <span style="color:#f92672">!=</span> SLUB_RED_ACTIVE <span style="color:#f92672">&amp;&amp;</span> (s<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> __OBJECT_POISON) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 检测obj是否早已被free检测obj[-1]是否为POISON_END(0xa5)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			(<span style="color:#f92672">!</span><span style="color:#a6e22e">check_bytes_and_report</span>(s, page, p, <span style="color:#e6db74">&#34;Poison&#34;</span>, p,
</span></span><span style="display:flex;"><span>					POISON_FREE, s<span style="color:#f92672">-&gt;</span>object_size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>			 <span style="color:#f92672">!</span><span style="color:#a6e22e">check_bytes_and_report</span>(s, page, p, <span style="color:#e6db74">&#34;Poison&#34;</span>,
</span></span><span style="display:flex;"><span>				p <span style="color:#f92672">+</span> s<span style="color:#f92672">-&gt;</span>object_size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, POISON_END, <span style="color:#ae81ff">1</span>)))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">check_pad_bytes</span>(s, page, p);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">freeptr_outside_object</span>(s) <span style="color:#f92672">&amp;&amp;</span> val <span style="color:#f92672">==</span> SLUB_RED_ACTIVE)
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * Object and freepointer overlap. Cannot check
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * freepointer while object is allocated.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 检查freelist是否有效
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">check_valid_pointer</span>(s, page, <span style="color:#a6e22e">get_freepointer</span>(s, p))) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">object_err</span>(s, page, p, <span style="color:#e6db74">&#34;Freepointer corrupt&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果无效则丢弃该freelist链后续object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">set_freepointer</span>(s, p, NULL);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="8-a-namevmaa进程vma">8. <!-- raw HTML omitted --><!-- raw HTML omitted -->进程vma</h2>
<ul>
<li>
<p>进程由许多的segment组成, 例如text segment,data segment, bss segment等, segment中被填充各种功能的数据, 每个segment具有不同的权限(r, w, x)</p>
</li>
<li>
<p>对于进程来说segment由什么结构来标识? 这就是接下来要将的进程vma</p>
</li>
</ul>
<h3 id="81-a-namevm_area_structavm_area_struct-结构体">8.1. <!-- raw HTML omitted --><!-- raw HTML omitted -->vm_area_struct 结构体</h3>
<ul>
<li>
<p>在进程中每个segment都被描述为vm_area_struct</p>
</li>
<li>
<p>task_struct -&gt; mm_struct -&gt; vm_area_struct</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> vm_area_struct {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 第一个cache line
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> vm_start;		
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> vm_end;						<span style="color:#75715e">// vm_area_struct所对应的vma在进程地址空间中的起始和结束地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vm_next, <span style="color:#f92672">*</span>vm_prev;	<span style="color:#75715e">// 按照vma在进程地址空间中的顺序, 将vma链入双链表,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rb_node vm_rb;						<span style="color:#75715e">// 红黑树结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> rb_subtree_gap;				<span style="color:#75715e">// 记录该vma与上一个vma(可以选择双链表中或者红黑树中)之间的空闲空间大小, 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 第二个cache line
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>vm_mm;					<span style="color:#75715e">// 指向该vma对应的进程的mm_struct结构体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">pgprot_t</span> vm_page_prot;						<span style="color:#75715e">// 该vma访问权限
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> vm_flags;						<span style="color:#75715e">// 描述该vma标志位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> vm_operations_struct <span style="color:#f92672">*</span>vm_ops;	<span style="color:#75715e">// 指向function集合, 虚表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> vm_pgoff;						<span style="color:#75715e">// 以page为单位的文件映射偏移量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span> vm_file;						<span style="color:#75715e">// 指向被映射的文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="82-a-namefind_vmavmaafind_vmavma查找">8.2. <!-- raw HTML omitted --><!-- raw HTML omitted -->find_vma(vma查找)</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span><span style="color:#a6e22e">find_vma</span>(<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rb_node <span style="color:#f92672">*</span>rb_node;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 在cache中寻找vma
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	vma <span style="color:#f92672">=</span> <span style="color:#a6e22e">vmacache_find</span>(mm, addr);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(vma))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> vma;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 定位红黑树根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	rb_node <span style="color:#f92672">=</span> mm<span style="color:#f92672">-&gt;</span>mm_rb.rb_node;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 在红黑树中查找vma
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> (rb_node) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>tmp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 获得当前结点的vm_area_struct
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		tmp <span style="color:#f92672">=</span> <span style="color:#a6e22e">rb_entry</span>(rb_node, <span style="color:#66d9ef">struct</span> vm_area_struct, vm_rb);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (tmp<span style="color:#f92672">-&gt;</span>vm_end <span style="color:#f92672">&gt;</span> addr) {
</span></span><span style="display:flex;"><span>			vma <span style="color:#f92672">=</span> tmp;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (tmp<span style="color:#f92672">-&gt;</span>vm_start <span style="color:#f92672">&lt;=</span> addr)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>			rb_node <span style="color:#f92672">=</span> rb_node<span style="color:#f92672">-&gt;</span>rb_left;
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			rb_node <span style="color:#f92672">=</span> rb_node<span style="color:#f92672">-&gt;</span>rb_right;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果查找到的vma有效, 则更新cache
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (vma)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">vmacache_update</span>(addr, vma);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> vma;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="821-a-namevmacache_findavmacache_find">8.2.1. <!-- raw HTML omitted --><!-- raw HTML omitted -->vmacache_find</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span><span style="color:#a6e22e">vmacache_find</span>(<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 通过左移addr, 定位addr对应的index(这个位置可能会存在对应的vma)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#a6e22e">VMACACHE_HASH</span>(addr);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 记录事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">count_vm_vmacache_event</span>(VMACACHE_FIND_CALLS);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 检测mm是否是当前进程的mm_struct, 如果是第一次触发cache, 将进行初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">vmacache_valid</span>(mm))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 遍历current-&gt;vmacache.vmas[](从idx开始, 因为inx对应的位置cache hit可能性最大)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> VMACACHE_SIZE; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>vmacache.vmas[idx];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (vma) {
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_DEBUG_VM_VMACACHE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">WARN_ON_ONCE</span>(vma<span style="color:#f92672">-&gt;</span>vm_mm <span style="color:#f92672">!=</span> mm))
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// 判断vma是否匹配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (vma<span style="color:#f92672">-&gt;</span>vm_start <span style="color:#f92672">&lt;=</span> addr <span style="color:#f92672">&amp;&amp;</span> vma<span style="color:#f92672">-&gt;</span>vm_end <span style="color:#f92672">&gt;</span> addr) {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">count_vm_vmacache_event</span>(VMACACHE_FIND_HITS);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> vma;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// inx遍历到VMACACHE_SIZE后, 归0继续遍历(idx是从中间开始遍历的)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">++</span>idx <span style="color:#f92672">==</span> VMACACHE_SIZE)
</span></span><span style="display:flex;"><span>			idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="83-a-nameinsert_vm_structvmaainsert_vm_structvma插入">8.3. <!-- raw HTML omitted --><!-- raw HTML omitted -->insert_vm_struct(vma插入)</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">insert_vm_struct</span>(<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm, <span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>prev;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rb_node <span style="color:#f92672">**</span>rb_link, <span style="color:#f92672">*</span>rb_parent;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 定位插入vma的目标位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// prev = rb_parent对应的vm_area_struct
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// rb_link = 待插入的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// rb_parent = rb_link的父结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">find_vma_links</span>(mm, vma<span style="color:#f92672">-&gt;</span>vm_start, vma<span style="color:#f92672">-&gt;</span>vm_end,
</span></span><span style="display:flex;"><span>			   <span style="color:#f92672">&amp;</span>prev, <span style="color:#f92672">&amp;</span>rb_link, <span style="color:#f92672">&amp;</span>rb_parent))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ((vma<span style="color:#f92672">-&gt;</span>vm_flags <span style="color:#f92672">&amp;</span> VM_ACCOUNT) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>	     <span style="color:#a6e22e">security_vm_enough_memory_mm</span>(mm, <span style="color:#a6e22e">vma_pages</span>(vma)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 匿名vma要设置页偏移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">vma_is_anonymous</span>(vma)) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">BUG_ON</span>(vma<span style="color:#f92672">-&gt;</span>anon_vma);
</span></span><span style="display:flex;"><span>		vma<span style="color:#f92672">-&gt;</span>vm_pgoff <span style="color:#f92672">=</span> vma<span style="color:#f92672">-&gt;</span>vm_start <span style="color:#f92672">&gt;&gt;</span> PAGE_SHIFT;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 将vma插入vma管理体系
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// vma_link -&gt; __vma_link -&gt; __vma_link_list, 将vma插入双链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// vma_link -&gt; __vma_link -&gt; __vma_link_rb, 将vma插入红黑树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">vma_link</span>(mm, vma, prev, rb_link, rb_parent);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="831-a-namefind_vma_linksafind_vma_links">8.3.1. <!-- raw HTML omitted --><!-- raw HTML omitted -->find_vma_links</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find_vma_links</span>(<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> addr,
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> end, <span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">**</span>pprev,
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> rb_node <span style="color:#f92672">***</span>rb_link, <span style="color:#66d9ef">struct</span> rb_node <span style="color:#f92672">**</span>rb_parent)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rb_node <span style="color:#f92672">**</span>__rb_link, <span style="color:#f92672">*</span>__rb_parent, <span style="color:#f92672">*</span>rb_prev;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	__rb_link <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>mm<span style="color:#f92672">-&gt;</span>mm_rb.rb_node;
</span></span><span style="display:flex;"><span>	rb_prev <span style="color:#f92672">=</span> __rb_parent <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">*</span>__rb_link) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma_tmp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		__rb_parent <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>__rb_link;
</span></span><span style="display:flex;"><span>		vma_tmp <span style="color:#f92672">=</span> <span style="color:#a6e22e">rb_entry</span>(__rb_parent, <span style="color:#66d9ef">struct</span> vm_area_struct, vm_rb);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (vma_tmp<span style="color:#f92672">-&gt;</span>vm_end <span style="color:#f92672">&gt;</span> addr) {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 如果vma_tmp_end_addr大于vma_end_addr且vma_start_end_addr小于vma_start_addr, 说明vma_tmp和vma重合, 函数报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (vma_tmp<span style="color:#f92672">-&gt;</span>vm_start <span style="color:#f92672">&lt;</span> end)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 继续遍历左节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			__rb_link <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>__rb_parent<span style="color:#f92672">-&gt;</span>rb_left;
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			rb_prev <span style="color:#f92672">=</span> __rb_parent;
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 继续遍历右节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			__rb_link <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>__rb_parent<span style="color:#f92672">-&gt;</span>rb_right;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 当__rb_link为空, 即对应结点为空时, 退出遍历红黑树循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// __rb_link对应空结点, 即目标插入位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// __rb_parent对应__rb_link的父结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// pprev对应rb_prev指向的vm_arena_struct
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>pprev <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (rb_prev)
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span>pprev <span style="color:#f92672">=</span> <span style="color:#a6e22e">rb_entry</span>(rb_prev, <span style="color:#66d9ef">struct</span> vm_area_struct, vm_rb);
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>rb_link <span style="color:#f92672">=</span> __rb_link;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span>rb_parent <span style="color:#f92672">=</span> __rb_parent;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="832-a-name-1a红黑树规则">8.3.2. <!-- raw HTML omitted --><!-- raw HTML omitted -->红黑树规则</h4>
<ul>
<li>
<p>红黑树规则:</p>
<ul>
<li>节点是红色或黑色</li>
<li>根节点是黑色</li>
<li>每个叶节点都是黑色的空节点</li>
<li>每个红色节点的两个子节点都是黑色(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li>
<li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点</li>
</ul>
</li>
<li>
<p>插入节点时通过变色或者旋转维持红黑树规则</p>
</li>
</ul>
<h2 id="9-a-name-1a缺页中断">9. <!-- raw HTML omitted --><!-- raw HTML omitted -->缺页中断</h2>
<p><img src="../../mm/__do_page_fault.png" alt="__do_page_fault"></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Page fault error code bits:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   bit 0 ==	 0: no page found	1: protection fault
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   bit 1 ==	 0: read access		1: write access
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   bit 2 ==	 0: kernel-mode access	1: user-mode access
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   bit 3 ==				1: use of reserved bit detected
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   bit 4 ==				1: fault was an instruction fetch
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   bit 5 ==				1: protection keys block access
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> x86_pf_error_code {
</span></span><span style="display:flex;"><span>	X86_PF_PROT	<span style="color:#f92672">=</span>		<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>	X86_PF_WRITE	<span style="color:#f92672">=</span>		<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>	X86_PF_USER	<span style="color:#f92672">=</span>		<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">2</span>,
</span></span><span style="display:flex;"><span>	X86_PF_RSVD	<span style="color:#f92672">=</span>		<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">3</span>,
</span></span><span style="display:flex;"><span>	X86_PF_INSTR	<span style="color:#f92672">=</span>		<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">4</span>,
</span></span><span style="display:flex;"><span>	X86_PF_PK	<span style="color:#f92672">=</span>		<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">5</span>,
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="91-a-namedo_page_faulta__do_page_fault源码分析">9.1. <!-- raw HTML omitted --><!-- raw HTML omitted -->__do_page_fault源码分析</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> noinline <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">__do_page_fault</span>(<span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> hw_error_code,
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> address)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 将变量放入cache, 加快速度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">prefetchw</span>(<span style="color:#f92672">&amp;</span>current<span style="color:#f92672">-&gt;</span>mm<span style="color:#f92672">-&gt;</span>mmap_sem);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// mmiotrace跟踪器, 用于跟踪基于内存映射的io设备
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">kmmio_fault</span>(regs, address)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 判断缺页中断发生在内核态还是用户态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">fault_in_kernel_space</span>(address)))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">do_kern_addr_fault</span>(regs, hw_error_code, address);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">do_user_addr_fault</span>(regs, hw_error_code, address);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="92-a-namefault_in_kernel_spaceafault_in_kernel_space">9.2. <!-- raw HTML omitted --><!-- raw HTML omitted -->fault_in_kernel_space</h3>
<ul>
<li>vsyscall和vdso的作用与区别
<ul>
<li>作用: 一般来说, 用户态与内核态通过系统调用进行交互, 但是这种交互非常浪费时间, 那么对于需要实时性的api如gettimeofday等就不太适用, 使用vsyscall或vdso可以加速</li>
<li>区别:
<ul>
<li>vsyscall是一种比较古老的机制, 他在固定地址映射内核内存页实现快速执行内核功能, 但安全性不高, 被vdso逐渐替代, 但是vdso只存在与动态链接, 静态链接程序没有vdso, 所以为了兼容性, vsyscall被保留下来</li>
<li>vdso可以应用aslr实现地址随机化, 而且无需考虑cpu差异性</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">fault_in_kernel_space</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> address)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// x86_64架构下vsyscall在TASK_SIZE_MAX之上, 但并非内核空间, 所以单独列出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// #define VSYSCALL_ADDR (-10UL &lt;&lt; 20), VSYSCALL_ADDR即为vsyscall固定地址(在x86_64架构下(-10)用8字节存储, VSYSCALL_ADDR=0xffffffffff600000)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">IS_ENABLED</span>(CONFIG_X86_64) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">is_vsyscall_vaddr</span>(address))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 将大于TASK_SIZE_MAX的地址视为内核空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> address <span style="color:#f92672">&gt;=</span> TASK_SIZE_MAX;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="93-a-namedo_kern_addr_faultado_kern_addr_fault">9.3. <!-- raw HTML omitted --><!-- raw HTML omitted -->do_kern_addr_fault</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">do_kern_addr_fault</span>(<span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> hw_error_code,
</span></span><span style="display:flex;"><span>		   <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> address)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// X86_PF_PK存在于用户页, 并非内核页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">WARN_ON_ONCE</span>(hw_error_code <span style="color:#f92672">&amp;</span> X86_PF_PK);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 检测错误是否由于vmalloc fault导致
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(hw_error_code <span style="color:#f92672">&amp;</span> (X86_PF_RSVD <span style="color:#f92672">|</span> X86_PF_USER <span style="color:#f92672">|</span> X86_PF_PROT))) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">vmalloc_fault</span>(address) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 检测错误是否是由于TLB表项陈旧(内核页权限变更后, TLB没有更新)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 如果TLB表项陈旧导致错误, 那么只有两种可能. 1. 数据写入时TLB(), 2. 指令执行时TLB(NX)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">spurious_kernel_fault</span>(hw_error_code, address))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 判断kprobe是否hook了缺页错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">kprobe_page_fault</span>(regs, X86_TRAP_PF))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 非法地址访问导致页错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">bad_area_nosemaphore</span>(regs, hw_error_code, address);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="931-a-namevmalloc_faultavmalloc_fault">9.3.1. <!-- raw HTML omitted --><!-- raw HTML omitted -->vmalloc_fault</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> noinline <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">vmalloc_fault</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> address)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pgd_t</span> <span style="color:#f92672">*</span>pgd, <span style="color:#f92672">*</span>pgd_k;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">p4d_t</span> <span style="color:#f92672">*</span>p4d, <span style="color:#f92672">*</span>p4d_k;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pud_t</span> <span style="color:#f92672">*</span>pud;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pmd_t</span> <span style="color:#f92672">*</span>pmd;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pte_t</span> <span style="color:#f92672">*</span>pte;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// #define high_memory (-128UL &lt;&lt; 20)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// #define VMALLOC_START (((unsigned long)high_memory + VMALLOC_OFFSET) &amp; ~(VMALLOC_OFFSET-1))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// VMALLOC空间和前面保留8M的hole保证安全性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 经计算VMALLOC_START=0xfffffffff8000000+8M
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(address <span style="color:#f92672">&gt;=</span> VMALLOC_START <span style="color:#f92672">&amp;&amp;</span> address <span style="color:#f92672">&lt;</span> VMALLOC_END))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 使用vmalloc分配内存后, 内存映射会被直接写入全局内核页表init_mm
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 进程的内核页表是在进程被创建时, 直接复制内核页表获得, 不具备实时性, 所以只有当发生vmalloc缺页中断时, 才会把对应的全局内核页表项复制到进程内核页表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 获得进程内核页表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	pgd <span style="color:#f92672">=</span> (<span style="color:#66d9ef">pgd_t</span> <span style="color:#f92672">*</span>)<span style="color:#a6e22e">__va</span>(<span style="color:#a6e22e">read_cr3_pa</span>()) <span style="color:#f92672">+</span> <span style="color:#a6e22e">pgd_index</span>(address);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 获得全局内核页表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	pgd_k <span style="color:#f92672">=</span> <span style="color:#a6e22e">pgd_offset_k</span>(address);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 将与addr关联的全局内核页表项复制到进程内核页表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">pgd_none</span>(<span style="color:#f92672">*</span>pgd_k))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">pgtable_l5_enabled</span>()) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">pgd_none</span>(<span style="color:#f92672">*</span>pgd)) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">set_pgd</span>(pgd, <span style="color:#f92672">*</span>pgd_k);
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">arch_flush_lazy_mmu_mode</span>();
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">BUG_ON</span>(<span style="color:#a6e22e">pgd_page_vaddr</span>(<span style="color:#f92672">*</span>pgd) <span style="color:#f92672">!=</span> <span style="color:#a6e22e">pgd_page_vaddr</span>(<span style="color:#f92672">*</span>pgd_k));
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 获得进程内核页表和全局内核页表对应的p4d, 令p4d_proc=p4d_kern实现页表项复制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	p4d <span style="color:#f92672">=</span> <span style="color:#a6e22e">p4d_offset</span>(pgd, address);
</span></span><span style="display:flex;"><span>	p4d_k <span style="color:#f92672">=</span> <span style="color:#a6e22e">p4d_offset</span>(pgd_k, address);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">p4d_none</span>(<span style="color:#f92672">*</span>p4d_k))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">p4d_none</span>(<span style="color:#f92672">*</span>p4d) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">pgtable_l5_enabled</span>()) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">set_p4d</span>(p4d, <span style="color:#f92672">*</span>p4d_k);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">arch_flush_lazy_mmu_mode</span>();
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">BUG_ON</span>(<span style="color:#a6e22e">p4d_pfn</span>(<span style="color:#f92672">*</span>p4d) <span style="color:#f92672">!=</span> <span style="color:#a6e22e">p4d_pfn</span>(<span style="color:#f92672">*</span>p4d_k));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">BUILD_BUG_ON</span>(CONFIG_PGTABLE_LEVELS <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 对pud, pmd, pte做安全检测
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	pud <span style="color:#f92672">=</span> <span style="color:#a6e22e">pud_offset</span>(p4d, address);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">pud_none</span>(<span style="color:#f92672">*</span>pud))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">pud_large</span>(<span style="color:#f92672">*</span>pud))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	pmd <span style="color:#f92672">=</span> <span style="color:#a6e22e">pmd_offset</span>(pud, address);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">pmd_none</span>(<span style="color:#f92672">*</span>pmd))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">pmd_large</span>(<span style="color:#f92672">*</span>pmd))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	pte <span style="color:#f92672">=</span> <span style="color:#a6e22e">pte_offset_kernel</span>(pmd, address);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果pte对应的page并非正在被使用则缺页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">pte_present</span>(<span style="color:#f92672">*</span>pte))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="932-a-namespurious_kernel_faultaspurious_kernel_fault">9.3.2. <!-- raw HTML omitted --><!-- raw HTML omitted -->spurious_kernel_fault</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> noinline <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">spurious_kernel_fault</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> error_code, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> address)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pgd_t</span> <span style="color:#f92672">*</span>pgd;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">p4d_t</span> <span style="color:#f92672">*</span>p4d;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pud_t</span> <span style="color:#f92672">*</span>pud;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pmd_t</span> <span style="color:#f92672">*</span>pmd;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pte_t</span> <span style="color:#f92672">*</span>pte;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 由于TLB表项陈旧导致的虚假错误, 给出的错误原因只有两种:写入(X86_PF_WRITE), 指令执行(X86_PF_INSTR)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (error_code <span style="color:#f92672">!=</span> (X86_PF_WRITE <span style="color:#f92672">|</span> X86_PF_PROT) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>	    error_code <span style="color:#f92672">!=</span> (X86_PF_INSTR <span style="color:#f92672">|</span> X86_PF_PROT))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 定位内核页表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	pgd <span style="color:#f92672">=</span> init_mm.pgd <span style="color:#f92672">+</span> <span style="color:#a6e22e">pgd_index</span>(address);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 判断pgd是否在内存中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">pgd_present</span>(<span style="color:#f92672">*</span>pgd))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 通过偏移获得p4d表项
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	p4d <span style="color:#f92672">=</span> <span style="color:#a6e22e">p4d_offset</span>(pgd, address);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">p4d_present</span>(<span style="color:#f92672">*</span>p4d))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果在p4d表项处开启huge page机制, 则直接进入spurious_kernel_fault_check
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">/* spurious_kernel_fault_check:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	if ((error_code &amp; X86_PF_WRITE) &amp;&amp; !pte_write(*pte))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	if ((error_code &amp; X86_PF_INSTR) &amp;&amp; !pte_exec(*pte))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 检测是否是因为tlb项老旧导致错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">p4d_large</span>(<span style="color:#f92672">*</span>p4d))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">spurious_kernel_fault_check</span>(error_code, (<span style="color:#66d9ef">pte_t</span> <span style="color:#f92672">*</span>) p4d);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 以下处理流程相同, 不再描述
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	pud <span style="color:#f92672">=</span> <span style="color:#a6e22e">pud_offset</span>(p4d, address);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">pud_present</span>(<span style="color:#f92672">*</span>pud))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">pud_large</span>(<span style="color:#f92672">*</span>pud))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">spurious_kernel_fault_check</span>(error_code, (<span style="color:#66d9ef">pte_t</span> <span style="color:#f92672">*</span>) pud);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	pmd <span style="color:#f92672">=</span> <span style="color:#a6e22e">pmd_offset</span>(pud, address);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">pmd_present</span>(<span style="color:#f92672">*</span>pmd))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">pmd_large</span>(<span style="color:#f92672">*</span>pmd))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">spurious_kernel_fault_check</span>(error_code, (<span style="color:#66d9ef">pte_t</span> <span style="color:#f92672">*</span>) pmd);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	pte <span style="color:#f92672">=</span> <span style="color:#a6e22e">pte_offset_kernel</span>(pmd, address);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">pte_present</span>(<span style="color:#f92672">*</span>pte))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">spurious_kernel_fault_check</span>(error_code, pte);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ret)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">spurious_kernel_fault_check</span>(error_code, (<span style="color:#66d9ef">pte_t</span> <span style="color:#f92672">*</span>) pmd);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果在pte阶段还是没有检测到虚假错误则报一个bug
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">WARN_ONCE</span>(<span style="color:#f92672">!</span>ret, <span style="color:#e6db74">&#34;PMD has incorrect permission bits</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="933-a-namebad_area_nosemaphoreabad_area_nosemaphore">9.3.3. <!-- raw HTML omitted --><!-- raw HTML omitted -->bad_area_nosemaphore</h4>
<ul>
<li>bad_area_nosemaphore -&gt; __bad_area_nosemaphore</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">__bad_area_nosemaphore</span>(<span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> error_code,
</span></span><span style="display:flex;"><span>		       <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> address, u32 pkey, <span style="color:#66d9ef">int</span> si_code)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk <span style="color:#f92672">=</span> current;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果请求来自用户态, 说明想要越界访问内核空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">user_mode</span>(regs) <span style="color:#f92672">&amp;&amp;</span> (error_code <span style="color:#f92672">&amp;</span> X86_PF_USER)) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">local_irq_enable</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * Valid to do another page fault here because this one came
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 * from user space:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">		 */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 不忽略nx页上的取指错误 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">is_prefetch</span>(regs, error_code, address))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">is_errata100</span>(regs, address))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 为了防止内核页表布局被泄露, 这里把用户态访问内核空间错误伪造成protection faults
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (address <span style="color:#f92672">&gt;=</span> TASK_SIZE_MAX)
</span></span><span style="display:flex;"><span>			error_code <span style="color:#f92672">|=</span> X86_PF_PROT;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(show_unhandled_signals))
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 打印错误信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">show_signal_msg</span>(regs, error_code, address, tsk);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">set_signal_archinfo</span>(address, error_code);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (si_code <span style="color:#f92672">==</span> SEGV_PKUERR)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">force_sig_pkuerr</span>((<span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>)address, pkey);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 发送SIGSEGV信号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">force_sig_fault</span>(SIGSEGV, si_code, (<span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>)address);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">is_f00f_bug</span>(regs, address))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 在内核中发生内核缺页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">no_context</span>(regs, error_code, address, SIGSEGV, si_code);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="no_context">no_context</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> noinline <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">no_context</span>(<span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> error_code,
</span></span><span style="display:flex;"><span>	   <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> address, <span style="color:#66d9ef">int</span> signal, <span style="color:#66d9ef">int</span> si_code)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk <span style="color:#f92672">=</span> current;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> sig;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">user_mode</span>(regs)) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 用户模式访问内核态, 直接oops
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">goto</span> oops;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 搜索异常表, 试图找到一个对应该异常的例程来进行修正
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">fixup_exception</span>(regs, X86_TRAP_PF, error_code, address)) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 任何中断错误都会在fixup_exception中获得处理, 下面的错误处理流程只用于任务上下文中的错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">in_interrupt</span>())
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>;	
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (current<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">thread</span>.sig_on_uaccess_err <span style="color:#f92672">&amp;&amp;</span> signal) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">set_signal_archinfo</span>(address, error_code);
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">force_sig_fault</span>(signal, si_code, (<span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>)address);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * 32-bit:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *   Valid to do another page fault here, because if this fault
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *   had been triggered by is_prefetch fixup_exception would have
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *   handled it.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * 64-bit:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *   Hall of CPU/BIOS bugs.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">is_prefetch</span>(regs, error_code, address))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">is_errata93</span>(regs, address))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 固件访问错误恢复
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">IS_ENABLED</span>(CONFIG_EFI))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">efi_recover_from_page_fault</span>(address);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>oops:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 确定时内核缺陷, 使用oops打印错误...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	flags <span style="color:#f92672">=</span> <span style="color:#a6e22e">oops_begin</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">show_fault_oops</span>(regs, error_code, address);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">task_stack_end_corrupted</span>(tsk))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">printk</span>(KERN_EMERG <span style="color:#e6db74">&#34;Thread overran stack, or stack corrupted</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	sig <span style="color:#f92672">=</span> SIGKILL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">__die</span>(<span style="color:#e6db74">&#34;Oops&#34;</span>, regs, error_code))
</span></span><span style="display:flex;"><span>		sig <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* Executive summary in case the body of the oops scrolled away */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printk</span>(KERN_DEFAULT <span style="color:#e6db74">&#34;CR2: %016lx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, address);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">oops_end</span>(flags, regs, sig);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="94-a-namedo_user_addr_faultado_user_addr_fault">9.4. <!-- raw HTML omitted --><!-- raw HTML omitted -->do_user_addr_fault</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">do_user_addr_fault</span>(<span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> hw_error_code,
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> address)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>tsk;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">vm_fault_t</span> fault, major <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> flags <span style="color:#f92672">=</span> FAULT_FLAG_ALLOW_RETRY <span style="color:#f92672">|</span> FAULT_FLAG_KILLABLE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	tsk <span style="color:#f92672">=</span> current;
</span></span><span style="display:flex;"><span>	mm <span style="color:#f92672">=</span> tsk<span style="color:#f92672">-&gt;</span>mm;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 判断kprobe是否hook了缺页错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">kprobe_page_fault</span>(regs, X86_TRAP_PF)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Reserved bits不会被设置在用户的页表项, 如果存在Reserved bits则发生页表错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(hw_error_code <span style="color:#f92672">&amp;</span> X86_PF_RSVD))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">pgtable_bad</span>(regs, hw_error_code, address);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果开启smap且kernel(supervisor)访问用户态地址(X86_PF_USER=0)则进入bad_area_nosemaphore
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">cpu_feature_enabled</span>(X86_FEATURE_SMAP) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>		     <span style="color:#f92672">!</span>(hw_error_code <span style="color:#f92672">&amp;</span> X86_PF_USER) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>		     <span style="color:#f92672">!</span>(regs<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> X86_EFLAGS_AC)))
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">bad_area_nosemaphore</span>(regs, hw_error_code, address);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * If we&#39;re in an interrupt, have no user context or are running
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * in a region with pagefaults disabled then we must not take the fault
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">faulthandler_disabled</span>() <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>mm)) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">bad_area_nosemaphore</span>(regs, hw_error_code, address);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 因为到达这一步时cr2中的虚拟地址已经被另存且vmalloc_fault被处理所以开启中断是安全可行的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">user_mode</span>(regs)) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">local_irq_enable</span>();
</span></span><span style="display:flex;"><span>		flags <span style="color:#f92672">|=</span> FAULT_FLAG_USER;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (regs<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> X86_EFLAGS_IF)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">local_irq_enable</span>();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 记录事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">perf_sw_event</span>(PERF_COUNT_SW_PAGE_FAULTS, <span style="color:#ae81ff">1</span>, regs, address);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 更新flags标志位(后面引用)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (hw_error_code <span style="color:#f92672">&amp;</span> X86_PF_WRITE)
</span></span><span style="display:flex;"><span>		flags <span style="color:#f92672">|=</span> FAULT_FLAG_WRITE;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (hw_error_code <span style="color:#f92672">&amp;</span> X86_PF_INSTR)
</span></span><span style="display:flex;"><span>		flags <span style="color:#f92672">|=</span> FAULT_FLAG_INSTRUCTION;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef CONFIG_X86_64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// vsyscall没有vma, 所以在find_vma之前对vsyscall做模拟
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">is_vsyscall_vaddr</span>(address)) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">emulate_vsyscall</span>(hw_error_code, regs, address))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 1. 内核只能访问用户地址空间的在exception_tables上定义的指令, 如果直接进行这样的尝试(但指令却在exception_tables之外)则会因为持有了mmap_sem锁, 而让系统死锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 2. 所以, 只有当获得mmap_sem锁失败后, 才能尝试使用1.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">down_read_trylock</span>(<span style="color:#f92672">&amp;</span>mm<span style="color:#f92672">-&gt;</span>mmap_sem))) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">user_mode</span>(regs) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">search_exception_tables</span>(regs<span style="color:#f92672">-&gt;</span>ip)) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">bad_area_nosemaphore</span>(regs, hw_error_code, address);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>retry:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">down_read</span>(<span style="color:#f92672">&amp;</span>mm<span style="color:#f92672">-&gt;</span>mmap_sem);
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果获得mmap_sem锁成功则会错过down_read内的might_sleep, 这里补一个might_sleep
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">might_sleep</span>();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 判断vma是否合法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	vma <span style="color:#f92672">=</span> <span style="color:#a6e22e">find_vma</span>(mm, address);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span>vma)) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">bad_area</span>(regs, hw_error_code, address);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 做简单的安全检测
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(vma<span style="color:#f92672">-&gt;</span>vm_start <span style="color:#f92672">&lt;=</span> address))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> good_area;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 判断vma是否向下增加
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span>(vma<span style="color:#f92672">-&gt;</span>vm_flags <span style="color:#f92672">&amp;</span> VM_GROWSDOWN))) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">bad_area</span>(regs, hw_error_code, address);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果address在栈空间, 则根据address和vma-&gt;start的关系决定是否扩充栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 如果address &lt; vma-&gt;start, 则另vma-&gt;start=address向下扩充stack
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">expand_stack</span>(vma, address))) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">bad_area</span>(regs, hw_error_code, address);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>good_area:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 判断是否因为页操作与vma权限不符(保留X86_PF_PK错误, 因为这是留给写时复制的, 并非权限错误)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">access_error</span>(hw_error_code, vma))) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">bad_area_access_error</span>(regs, hw_error_code, address, vma);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 缺页处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	fault <span style="color:#f92672">=</span> <span style="color:#a6e22e">handle_mm_fault</span>(vma, address, flags);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span></code></pre></div><h4 id="941-a-namehandle_mm_faultahandle_mm_fault">9.4.1. <!-- raw HTML omitted --><!-- raw HTML omitted -->handle_mm_fault</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">vm_fault_t</span> <span style="color:#a6e22e">__handle_mm_fault</span>(<span style="color:#66d9ef">struct</span> vm_area_struct <span style="color:#f92672">*</span>vma,
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> address, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> vm_fault vmf <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>		.vma <span style="color:#f92672">=</span> vma,
</span></span><span style="display:flex;"><span>		.address <span style="color:#f92672">=</span> address <span style="color:#f92672">&amp;</span> PAGE_MASK,
</span></span><span style="display:flex;"><span>		.flags <span style="color:#f92672">=</span> flags,
</span></span><span style="display:flex;"><span>		.pgoff <span style="color:#f92672">=</span> <span style="color:#a6e22e">linear_page_index</span>(vma, address),
</span></span><span style="display:flex;"><span>		.gfp_mask <span style="color:#f92672">=</span> <span style="color:#a6e22e">__get_fault_gfp_mask</span>(vma),
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> dirty <span style="color:#f92672">=</span> flags <span style="color:#f92672">&amp;</span> FAULT_FLAG_WRITE;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 以vma-&gt;vm_mm为根结点遍历页表, 定位到pmd
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> mm_struct <span style="color:#f92672">*</span>mm <span style="color:#f92672">=</span> vma<span style="color:#f92672">-&gt;</span>vm_mm;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pgd_t</span> <span style="color:#f92672">*</span>pgd;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">p4d_t</span> <span style="color:#f92672">*</span>p4d;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">vm_fault_t</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 定位pgd
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	pgd <span style="color:#f92672">=</span> <span style="color:#a6e22e">pgd_offset</span>(mm, address);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果没开5级页表直接返回pgd
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	p4d <span style="color:#f92672">=</span> <span style="color:#a6e22e">p4d_alloc</span>(mm, pgd, address);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>p4d)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> VM_FAULT_OOM;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 定位pud
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	vmf.pud <span style="color:#f92672">=</span> <span style="color:#a6e22e">pud_alloc</span>(mm, p4d, address);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vmf.pud)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> VM_FAULT_OOM;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 中间表项为空, 且开启huge_page, 设置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 如果pud为空, 且vma可以创建透明的huge_page, 则create_huge_pud触发huge_page错误(匿名页不支持)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">pud_none</span>(<span style="color:#f92672">*</span>vmf.pud) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">__transparent_hugepage_enabled</span>(vma)) {
</span></span><span style="display:flex;"><span>		ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">create_huge_pud</span>(<span style="color:#f92672">&amp;</span>vmf);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(ret <span style="color:#f92672">&amp;</span> VM_FAULT_FALLBACK))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">pud_t</span> orig_pud <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>vmf.pud;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">barrier</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// pud具有_PAGE_PSE标志位, 且pud为devmap
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">pud_trans_huge</span>(orig_pud) <span style="color:#f92672">||</span> <span style="color:#a6e22e">pud_devmap</span>(orig_pud)) {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// pud将要被更新为脏页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (dirty <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">pud_write</span>(orig_pud)) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// 触发huge_page错误(匿名页不支持)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">wp_huge_pud</span>(<span style="color:#f92672">&amp;</span>vmf, orig_pud);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(ret <span style="color:#f92672">&amp;</span> VM_FAULT_FALLBACK))
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>			} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">huge_pud_set_accessed</span>(<span style="color:#f92672">&amp;</span>vmf, orig_pud);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	vmf.pmd <span style="color:#f92672">=</span> <span style="color:#a6e22e">pmd_alloc</span>(mm, vmf.pud, address);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vmf.pmd)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> VM_FAULT_OOM;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果pmd为空, 且vma可以创建透明的huge_page, 则create_huge_pmd创建大页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">pmd_none</span>(<span style="color:#f92672">*</span>vmf.pmd) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">__transparent_hugepage_enabled</span>(vma)) {
</span></span><span style="display:flex;"><span>		ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">create_huge_pmd</span>(<span style="color:#f92672">&amp;</span>vmf);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(ret <span style="color:#f92672">&amp;</span> VM_FAULT_FALLBACK))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">pmd_t</span> orig_pmd <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>vmf.pmd;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">barrier</span>();
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 判断pmd是否在swap分区(不在内存中)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">is_swap_pmd</span>(orig_pmd))) {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 如果支持迁移但并非迁移pmd入口, 则上报bug
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">VM_BUG_ON</span>(<span style="color:#a6e22e">thp_migration_supported</span>() <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>					  <span style="color:#f92672">!</span><span style="color:#a6e22e">is_pmd_migration_entry</span>(orig_pmd));
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">is_pmd_migration_entry</span>(orig_pmd))
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">pmd_migration_entry_wait</span>(mm, vmf.pmd);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// pud具有_PAGE_PSE标志位, 且pud为devmap
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">pmd_trans_huge</span>(orig_pmd) <span style="color:#f92672">||</span> <span style="color:#a6e22e">pmd_devmap</span>(orig_pmd)) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">pmd_protnone</span>(orig_pmd) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">vma_is_accessible</span>(vma))
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">do_huge_pmd_numa_page</span>(<span style="color:#f92672">&amp;</span>vmf, orig_pmd);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (dirty <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">pmd_write</span>(orig_pmd)) {
</span></span><span style="display:flex;"><span>				ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">wp_huge_pmd</span>(<span style="color:#f92672">&amp;</span>vmf, orig_pmd);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(ret <span style="color:#f92672">&amp;</span> VM_FAULT_FALLBACK))
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>			} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">huge_pmd_set_accessed</span>(<span style="color:#f92672">&amp;</span>vmf, orig_pmd);
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// vmf被填充, 下一步根据vmf分配物理页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">handle_pte_fault</span>(<span style="color:#f92672">&amp;</span>vmf);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="handle_pte_fault">handle_pte_fault</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">vm_fault_t</span> <span style="color:#a6e22e">handle_pte_fault</span>(<span style="color:#66d9ef">struct</span> vm_fault <span style="color:#f92672">*</span>vmf)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pte_t</span> entry;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 若pmd不存在, 则pte不存在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">pmd_none</span>(<span style="color:#f92672">*</span>vmf<span style="color:#f92672">-&gt;</span>pmd))) {
</span></span><span style="display:flex;"><span>		vmf<span style="color:#f92672">-&gt;</span>pte <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// pmd_devmap_trans_unstable{return pmd_devmap(*pmd) || pmd_trans_unstable(pmd);}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// pmd_devmap检测pmd是否为_PAGE_DEVMAP, 如果是则直接返回1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// pmd_trans_unstable-&gt;pmd_none_or_trans_huge_or_clear_bad{...}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 检测pmd是否为空, 或者是否可以转换为huge_page, 否则进入pmd_clear_bad
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 提前检测_PAGE_DEVMAP, 可以避免后面devmap页进入pmd_none_or_trans_huge_or_clear_bad后陷入pmd_clear_bad, 而滥用dmesg打印错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// pmd_devmap_trans_unstable=pmd_devmap+pmd_trans_unstable 可这个命名太抽象 =.=
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">pmd_devmap_trans_unstable</span>(vmf<span style="color:#f92672">-&gt;</span>pmd))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 此时pmd存在且不可能变成huge_pmd, 使用pte_offset_map是安全的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		vmf<span style="color:#f92672">-&gt;</span>pte <span style="color:#f92672">=</span> <span style="color:#a6e22e">pte_offset_map</span>(vmf<span style="color:#f92672">-&gt;</span>pmd, vmf<span style="color:#f92672">-&gt;</span>address);
</span></span><span style="display:flex;"><span>		vmf<span style="color:#f92672">-&gt;</span>orig_pte <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>vmf<span style="color:#f92672">-&gt;</span>pte;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">barrier</span>();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">pte_none</span>(vmf<span style="color:#f92672">-&gt;</span>orig_pte)) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">pte_unmap</span>(vmf<span style="color:#f92672">-&gt;</span>pte);
</span></span><span style="display:flex;"><span>			vmf<span style="color:#f92672">-&gt;</span>pte <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// pte为空, 分配页表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vmf<span style="color:#f92672">-&gt;</span>pte) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">vma_is_anonymous</span>(vmf<span style="color:#f92672">-&gt;</span>vma))
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 处理匿名页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">do_anonymous_page</span>(vmf);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 处理文件映射页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">do_fault</span>(vmf);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// -----------  物理页存在  -----------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 页表已建立, 但不存在与内存, 做页交换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">pte_present</span>(vmf<span style="color:#f92672">-&gt;</span>orig_pte))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">do_swap_page</span>(vmf);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">pte_protnone</span>(vmf<span style="color:#f92672">-&gt;</span>orig_pte) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">vma_is_accessible</span>(vmf<span style="color:#f92672">-&gt;</span>vma))
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 维持node平衡, 进行页迁移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">do_numa_page</span>(vmf);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	vmf<span style="color:#f92672">-&gt;</span>ptl <span style="color:#f92672">=</span> <span style="color:#a6e22e">pte_lockptr</span>(vmf<span style="color:#f92672">-&gt;</span>vma<span style="color:#f92672">-&gt;</span>vm_mm, vmf<span style="color:#f92672">-&gt;</span>pmd);
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">spin_lock</span>(vmf<span style="color:#f92672">-&gt;</span>ptl);
</span></span><span style="display:flex;"><span>	entry <span style="color:#f92672">=</span> vmf<span style="color:#f92672">-&gt;</span>orig_pte;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 锁定资源区后, 检测pte是否发生变化, 如果发生, 直接解锁资源区 return
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">pte_same</span>(<span style="color:#f92672">*</span>vmf<span style="color:#f92672">-&gt;</span>pte, entry)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> unlock;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 因写入而触发中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (vmf<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> FAULT_FLAG_WRITE) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">pte_write</span>(entry))
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 写时复制缺页中断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">do_wp_page</span>(vmf);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 标记脏页
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		entry <span style="color:#f92672">=</span> <span style="color:#a6e22e">pte_mkdirty</span>(entry);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	entry <span style="color:#f92672">=</span> <span style="color:#a6e22e">pte_mkyoung</span>(entry);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果pte内容没有变化进入else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">ptep_set_access_flags</span>(vmf<span style="color:#f92672">-&gt;</span>vma, vmf<span style="color:#f92672">-&gt;</span>address, vmf<span style="color:#f92672">-&gt;</span>pte, entry,
</span></span><span style="display:flex;"><span>				vmf<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> FAULT_FLAG_WRITE)) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// pte内容更改, 刷新mmu
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">update_mmu_cache</span>(vmf<span style="color:#f92672">-&gt;</span>vma, vmf<span style="color:#f92672">-&gt;</span>address, vmf<span style="color:#f92672">-&gt;</span>pte);
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果pte没有发生变化, 且是写中断错误, 这里可能对应写时复制, 所以更新tlb
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (vmf<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> FAULT_FLAG_WRITE)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">flush_tlb_fix_spurious_fault</span>(vmf<span style="color:#f92672">-&gt;</span>vma, vmf<span style="color:#f92672">-&gt;</span>address);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>unlock:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pte_unmap_unlock</span>(vmf<span style="color:#f92672">-&gt;</span>pte, vmf<span style="color:#f92672">-&gt;</span>ptl);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="10-a-nameptmallocaptmalloc">10. <!-- raw HTML omitted --><!-- raw HTML omitted -->ptmalloc</h2>
<blockquote>
<p>ptmalloc是linux 用户态堆管理机制, 也是本文源码分析的最后一部分, 链接如下:</p>
</blockquote>
<p><a href="https://www.povcfe.site/posts/ptmalloc/">ptmalloc源码解析</a></p>
<h2 id="11-a-name-1a杂记">11. <!-- raw HTML omitted --><!-- raw HTML omitted -->杂记</h2>
<ul>
<li>山高路远不畏险</li>
<li>还有很多需要写的东西, 留给下一篇文章</li>
</ul>
</section>

  
  

  
  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    <a
      class="flex w-1/2 items-center rounded-l-md p-6 pr-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]"
      href="https://www.povcfe.site/post/reprint/"
      ><span class="mr-1.5">←</span><span>一些思考</span></a
    >
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]"
      href="https://www.povcfe.site/post/kernel_boot/"
      ><span>linux内核(5.6.6)---内核引导</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  
  

  
  

  
  

  


  
</article>


    </main>

    <footer
  class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"
>
  <div class="mr-auto">
    &copy; 2024
    <a class="link" href="https://www.povcfe.site/">povcfe&#39;s site</a>
  </div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank"
    >Powered by Hugo️️</a
  >️
  <a
    class="link"
    href="https://github.com/nanxiaobei/hugo-paper"
    rel="noopener"
    target="_blank"
    >✎ Paper</a
  >
</footer>

  </body>
</html>
