<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>linux内核(5.4.81)---内存管理模块源码分析 - LoveIt</title><meta name="Description" content="About LoveIt Theme"><meta property="og:title" content="linux内核(5.4.81)---内存管理模块源码分析" />
<meta property="og:description" content="已投稿于安全客
   页表   1.1. 页表查询&ndash;以x86_64下的4级页表举例(硬件)  1.1.1. TLB转换 1.1.2. 页表转换 1.1.3. 页表结构cache转换   1.2. 拓展  1.2.1. 普通页表cache 1.2.2. Huge_Page 1.2.3. 页表标志位      伙伴算法(buddy)    alloc_pages源码分析   3.1. alloc_pages_current 3.2. __alloc_pages_nodemask  3.2.1. get_page_from_freelist 3.2.2. _alloc_pages_slowpath      _free_pages源码分析   4.1. free_unref_page  4.1.1. free_pcppages_bulk   4.2. __free_pages_ok  4.2.1. __free_one_page      slub算法   5." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://povcfe.github.io/kernel_mm/" />
<meta property="og:image" content="https://povcfe.github.io/logo.png"/>
<meta property="article:published_time" content="2021-01-12T03:54:11-08:00" />
<meta property="article:modified_time" content="2021-01-12T03:54:11-08:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://povcfe.github.io/logo.png"/>

<meta name="twitter:title" content="linux内核(5.4.81)---内存管理模块源码分析"/>
<meta name="twitter:description" content="已投稿于安全客
   页表   1.1. 页表查询&ndash;以x86_64下的4级页表举例(硬件)  1.1.1. TLB转换 1.1.2. 页表转换 1.1.3. 页表结构cache转换   1.2. 拓展  1.2.1. 普通页表cache 1.2.2. Huge_Page 1.2.3. 页表标志位      伙伴算法(buddy)    alloc_pages源码分析   3.1. alloc_pages_current 3.2. __alloc_pages_nodemask  3.2.1. get_page_from_freelist 3.2.2. _alloc_pages_slowpath      _free_pages源码分析   4.1. free_unref_page  4.1.1. free_pcppages_bulk   4.2. __free_pages_ok  4.2.1. __free_one_page      slub算法   5."/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://povcfe.github.io/kernel_mm/" /><link rel="prev" href="https://povcfe.github.io/kernel_boot/" /><link rel="next" href="https://povcfe.github.io/reprint/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "linux内核(5.4.81)---内存管理模块源码分析",
        "inLanguage": "en",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/povcfe.github.io\/kernel_mm\/"
        },"image": ["https:\/\/povcfe.github.io\/images\/Apple-Devices-Preview.png"],"genre": "posts","keywords": "linux kernel, 源码分析, 内存管理","wordcount":  8974 ,
        "url": "https:\/\/povcfe.github.io\/kernel_mm\/","datePublished": "2021-01-12T03:54:11-08:00","dateModified": "2021-01-12T03:54:11-08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "xxxx","logo": "https:\/\/povcfe.github.io\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "xxxx"
            },"description": ""
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="LoveIt"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>LoveIt</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> Posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><a class="menu-item" href="/categories/documentation/"> Docs </a><a class="menu-item" href="/about/"> About </a><a class="menu-item" href="https://github.com/dillonzq/LoveIt" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item language" title="Select Language">English<i class="fas fa-chevron-right fa-fw"></i>
                        <select class="language-select" id="language-select-desktop" onchange="location = this.value;"><option value="/kernel_mm/" selected>English</option></select>
                    </a><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="Search">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="Clear">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="LoveIt"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>LoveIt</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="Search">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="Clear">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        Cancel
                    </a>
                </div><a class="menu-item" href="/posts/" title="">Posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a class="menu-item" href="/categories/documentation/" title="">Docs</a><a class="menu-item" href="/about/" title="">About</a><a class="menu-item" href="https://github.com/dillonzq/LoveIt" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw"></i>
            </a><a href="javascript:void(0);" class="menu-item" title="Select Language">English<i class="fas fa-chevron-right fa-fw"></i>
                    <select class="language-select" onchange="location = this.value;"><option value="/kernel_mm/" selected>English</option></select>
                </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">linux内核(5.4.81)---内存管理模块源码分析</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>xxxx</a></span>&nbsp;<span class="post-category">included in <a href="/categories/linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="far fa-folder fa-fw"></i>linux内核源码分析</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-01-12">2021-01-12</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;8974 words&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;43 minutes&nbsp;<span id="/kernel_mm/" class="leancloud_visitors" data-flag-title="linux内核(5.4.81)---内存管理模块源码分析">
                        <i class="far fa-eye fa-fw"></i>&nbsp;<span class=leancloud-visitors-count></span>&nbsp;views
                    </span>&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#1-a-namea页表">1. <a name=''></a>页表</a>
      <ul>
        <li><a href="#11-a-name--x86_644a页表查询--以x86_64下的4级页表举例硬件">1.1. <a name='--x86_644'></a>页表查询&ndash;以x86_64下的4级页表举例(硬件)</a>
          <ul>
            <li><a href="#111-a-nametlbatlb转换">1.1.1. <a name='TLB'></a>TLB转换</a></li>
            <li><a href="#112-a-name-1a页表转换">1.1.2. <a name='-1'></a>页表转换</a></li>
            <li><a href="#113-a-namecachea页表结构cache转换">1.1.3. <a name='cache'></a>页表结构cache转换</a></li>
          </ul>
        </li>
        <li><a href="#12-a-name-1a拓展">1.2. <a name='-1'></a>拓展</a>
          <ul>
            <li><a href="#121-a-namecache-1a普通页表cache">1.2.1. <a name='cache-1'></a>普通页表cache</a></li>
            <li><a href="#122-a-namehuge_pageahuge_page">1.2.2. <a name='Huge_Page'></a>Huge_Page</a></li>
            <li><a href="#123-a-name-1a页表标志位">1.2.3. <a name='-1'></a>页表标志位</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#2-a-namebuddya伙伴算法buddy">2. <a name='buddy'></a>伙伴算法(buddy)</a></li>
    <li><a href="#3-a-namealloc_pagesaalloc_pages源码分析">3. <a name='alloc_pages'></a>alloc_pages源码分析</a>
      <ul>
        <li><a href="#31-a-namealloc_pages_currentaalloc_pages_current">3.1. <a name='alloc_pages_current'></a>alloc_pages_current</a></li>
        <li><a href="#32-a-namealloc_pages_nodemaska__alloc_pages_nodemask">3.2. <a name='alloc_pages_nodemask'></a>__alloc_pages_nodemask</a>
          <ul>
            <li><a href="#321-a-nameget_page_from_freelistaget_page_from_freelist">3.2.1. <a name='get_page_from_freelist'></a>get_page_from_freelist</a>
              <ul>
                <li><a href="#rmqueue">rmqueue</a>
                  <ul>
                    <li><a href="#rmqueue_pcplis">rmqueue_pcplis</a></li>
                    <li><a href="#__rmqueue_smallest">__rmqueue_smallest</a></li>
                    <li><a href="#__rmqueue">__rmqueue</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#322-a-namealloc_pages_slowpatha_alloc_pages_slowpath">3.2.2. <a name='alloc_pages_slowpath'></a>_alloc_pages_slowpath</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#4-a-namefree_pagesa_free_pages源码分析">4. <a name='free_pages'></a>_free_pages源码分析</a>
      <ul>
        <li><a href="#41-a-namefree_unref_pageafree_unref_page">4.1. <a name='free_unref_page'></a>free_unref_page</a>
          <ul>
            <li><a href="#411-a-namefree_pcppages_bulkafree_pcppages_bulk">4.1.1. <a name='free_pcppages_bulk'></a>free_pcppages_bulk</a></li>
          </ul>
        </li>
        <li><a href="#42-a-namefree_pages_oka__free_pages_ok">4.2. <a name='free_pages_ok'></a>__free_pages_ok</a>
          <ul>
            <li><a href="#421-a-namefree_one_pagea__free_one_page">4.2.1. <a name='free_one_page'></a>__free_one_page</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#5-a-nameslubaslub算法">5. <a name='slub'></a>slub算法</a>
      <ul>
        <li><a href="#51-a-name-1a结构体解析">5.1. <a name='-1'></a>结构体解析</a></li>
      </ul>
    </li>
    <li><a href="#6-a-namekmem_cache_allocakmem_cache_alloc源码分析">6. <a name='kmem_cache_alloc'></a>kmem_cache_alloc源码分析</a>
      <ul>
        <li><a href="#61-a-nameslab_alloca__slab_alloc">6.1. <a name='slab_alloc'></a>__slab_alloc</a>
          <ul>
            <li><a href="#611-a-nameget_freelistaget_freelist">6.1.1. <a name='get_freelist'></a>get_freelist</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#7-a-namekmem_cache_freeakmem_cache_free源码分析">7. <a name='kmem_cache_free'></a>kmem_cache_free源码分析</a>
      <ul>
        <li><a href="#71-a-namecache_from_objacache_from_obj">7.1. <a name='cache_from_obj'></a>cache_from_obj</a></li>
        <li><a href="#72-a-nameslab_free_freelist_hookaslab_free_freelist_hook">7.2. <a name='slab_free_freelist_hook'></a>slab_free_freelist_hook</a></li>
        <li><a href="#73-a-namedo_slab_freeado_slab_free">7.3. <a name='do_slab_free'></a>do_slab_free</a>
          <ul>
            <li><a href="#731-a-nameslab_freea__slab_free">7.3.1. <a name='slab_free'></a>__slab_free</a>
              <ul>
                <li><a href="#discard_slab">discard_slab</a>
                  <ul>
                    <li><a href="#slab_pad_check">slab_pad_check</a></li>
                    <li><a href="#check_object">check_object</a></li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#8-a-namevmaa进程vma">8. <a name='vma'></a>进程vma</a>
      <ul>
        <li><a href="#81-a-namevm_area_structavm_area_struct-结构体">8.1. <a name='vm_area_struct'></a>vm_area_struct 结构体</a></li>
        <li><a href="#82-a-namefind_vmavmaafind_vmavma查找">8.2. <a name='find_vmavma'></a>find_vma(vma查找)</a>
          <ul>
            <li><a href="#821-a-namevmacache_findavmacache_find">8.2.1. <a name='vmacache_find'></a>vmacache_find</a></li>
          </ul>
        </li>
        <li><a href="#83-a-nameinsert_vm_structvmaainsert_vm_structvma插入">8.3. <a name='insert_vm_structvma'></a>insert_vm_struct(vma插入)</a>
          <ul>
            <li><a href="#831-a-namefind_vma_linksafind_vma_links">8.3.1. <a name='find_vma_links'></a>find_vma_links</a></li>
            <li><a href="#832-a-name-1a红黑树规则">8.3.2. <a name='-1'></a>红黑树规则</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#9-a-name-1a缺页中断">9. <a name='-1'></a>缺页中断</a>
      <ul>
        <li><a href="#91-a-namedo_page_faulta__do_page_fault源码分析">9.1. <a name='do_page_fault'></a>__do_page_fault源码分析</a></li>
        <li><a href="#92-a-namefault_in_kernel_spaceafault_in_kernel_space">9.2. <a name='fault_in_kernel_space'></a>fault_in_kernel_space</a></li>
        <li><a href="#93-a-namedo_kern_addr_faultado_kern_addr_fault">9.3. <a name='do_kern_addr_fault'></a>do_kern_addr_fault</a>
          <ul>
            <li><a href="#931-a-namevmalloc_faultavmalloc_fault">9.3.1. <a name='vmalloc_fault'></a>vmalloc_fault</a></li>
            <li><a href="#932-a-namespurious_kernel_faultaspurious_kernel_fault">9.3.2. <a name='spurious_kernel_fault'></a>spurious_kernel_fault</a></li>
            <li><a href="#933-a-namebad_area_nosemaphoreabad_area_nosemaphore">9.3.3. <a name='bad_area_nosemaphore'></a>bad_area_nosemaphore</a>
              <ul>
                <li><a href="#no_context">no_context</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#94-a-namedo_user_addr_faultado_user_addr_fault">9.4. <a name='do_user_addr_fault'></a>do_user_addr_fault</a>
          <ul>
            <li><a href="#941-a-namehandle_mm_faultahandle_mm_fault">9.4.1. <a name='handle_mm_fault'></a>handle_mm_fault</a>
              <ul>
                <li><a href="#handle_pte_fault">handle_pte_fault</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#10-a-nameptmallocaptmalloc">10. <a name='ptmalloc'></a>ptmalloc</a></li>
    <li><a href="#11-a-name-1a杂记">11. <a name='-1'></a>杂记</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p><a href="https://www.anquanke.com/post/id/228651" target="_blank" rel="noopener noreffer">已投稿于安全客</a></p>
<!-- vscode-markdown-toc -->
<ul>
<li>
<ol>
<li><a href="#" rel="">页表</a></li>
</ol>
<ul>
<li>1.1. <a href="#--x86_644" rel="">页表查询&ndash;以x86_64下的4级页表举例(硬件)</a>
<ul>
<li>1.1.1. <a href="#TLB" rel="">TLB转换</a></li>
<li>1.1.2. <a href="#-1" rel="">页表转换</a></li>
<li>1.1.3. <a href="#cache" rel="">页表结构cache转换</a></li>
</ul>
</li>
<li>1.2. <a href="#-1" rel="">拓展</a>
<ul>
<li>1.2.1. <a href="#cache-1" rel="">普通页表cache</a></li>
<li>1.2.2. <a href="#Huge_Page" rel="">Huge_Page</a></li>
<li>1.2.3. <a href="#-1" rel="">页表标志位</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="2">
<li><a href="#buddy" rel="">伙伴算法(buddy)</a></li>
</ol>
</li>
<li>
<ol start="3">
<li><a href="#alloc_pages" rel="">alloc_pages源码分析</a></li>
</ol>
<ul>
<li>3.1. <a href="#alloc_pages_current" rel="">alloc_pages_current</a></li>
<li>3.2. <a href="#alloc_pages_nodemask" rel="">__alloc_pages_nodemask</a>
<ul>
<li>3.2.1. <a href="#get_page_from_freelist" rel="">get_page_from_freelist</a></li>
<li>3.2.2. <a href="#alloc_pages_slowpath" rel="">_alloc_pages_slowpath</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="4">
<li><a href="#free_pages" rel="">_free_pages源码分析</a></li>
</ol>
<ul>
<li>4.1. <a href="#free_unref_page" rel="">free_unref_page</a>
<ul>
<li>4.1.1. <a href="#free_pcppages_bulk" rel="">free_pcppages_bulk</a></li>
</ul>
</li>
<li>4.2. <a href="#free_pages_ok" rel="">__free_pages_ok</a>
<ul>
<li>4.2.1. <a href="#free_one_page" rel="">__free_one_page</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="5">
<li><a href="#slub" rel="">slub算法</a></li>
</ol>
<ul>
<li>5.1. <a href="#-1" rel="">结构体解析</a></li>
</ul>
</li>
<li>
<ol start="6">
<li><a href="#kmem_cache_alloc" rel="">kmem_cache_alloc源码分析</a></li>
</ol>
<ul>
<li>6.1. <a href="#slab_alloc" rel="">__slab_alloc</a>
<ul>
<li>6.1.1. <a href="#get_freelist" rel="">get_freelist</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="7">
<li><a href="#kmem_cache_free" rel="">kmem_cache_free源码分析</a></li>
</ol>
<ul>
<li>7.1. <a href="#cache_from_obj" rel="">cache_from_obj</a></li>
<li>7.2. <a href="#slab_free_freelist_hook" rel="">slab_free_freelist_hook</a></li>
<li>7.3. <a href="#do_slab_free" rel="">do_slab_free</a>
<ul>
<li>7.3.1. <a href="#slab_free" rel="">__slab_free</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="8">
<li><a href="#vma" rel="">进程vma</a></li>
</ol>
<ul>
<li>8.1. <a href="#vm_area_struct" rel="">vm_area_struct 结构体</a></li>
<li>8.2. <a href="#find_vmavma" rel="">find_vma(vma查找)</a>
<ul>
<li>8.2.1. <a href="#vmacache_find" rel="">vmacache_find</a></li>
</ul>
</li>
<li>8.3. <a href="#insert_vm_structvma" rel="">insert_vm_struct(vma插入)</a>
<ul>
<li>8.3.1. <a href="#find_vma_links" rel="">find_vma_links</a></li>
<li>8.3.2. <a href="#-1" rel="">红黑树规则</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="9">
<li><a href="#-1" rel="">缺页中断</a></li>
</ol>
<ul>
<li>9.1. <a href="#do_page_fault" rel="">__do_page_fault源码分析</a></li>
<li>9.2. <a href="#fault_in_kernel_space" rel="">fault_in_kernel_space</a></li>
<li>9.3. <a href="#do_kern_addr_fault" rel="">do_kern_addr_fault</a>
<ul>
<li>9.3.1. <a href="#vmalloc_fault" rel="">vmalloc_fault</a></li>
<li>9.3.2. <a href="#spurious_kernel_fault" rel="">spurious_kernel_fault</a></li>
<li>9.3.3. <a href="#bad_area_nosemaphore" rel="">bad_area_nosemaphore</a></li>
</ul>
</li>
<li>9.4. <a href="#do_user_addr_fault" rel="">do_user_addr_fault</a>
<ul>
<li>9.4.1. <a href="#handle_mm_fault" rel="">handle_mm_fault</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="10">
<li><a href="#ptmalloc" rel="">ptmalloc</a></li>
</ol>
</li>
<li>
<ol start="11">
<li><a href="#-1" rel="">杂记</a></li>
</ol>
</li>
</ul>
<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->
<p>linux作为开源内核，被广泛使用。同时随着用户态安全机制的逐渐完善，攻击成本逐年升高，越来越多的黑客将目光投向linux内核，linux内核安全问题也随之被越来越多的安全研究人员关注。但作为一个规模宏大的开源项目，linux内核安全研究存在非常高的研究门槛，不管是针对特定模块的漏洞挖掘，还是cve复现，对内核的理解限制了绝大多数安全研究人员。而本文则希望通过对内核源码做详细分析来让更多的安全研究人员越过内核门槛。
这篇文章的贡献如下：</p>
<p>（1）硬件层面上分析linux内核页表</p>
<p>（2）从buddy源码分析linux内核页管理</p>
<p>（3）从slub源码分析linux内核小内存管理</p>
<p>（4）从vma源码分析linux内核对于进程内存空间的布局及管理</p>
<p>（5）分析缺页中断流程</p>
<p>（6）从ptmalloc源码分析用户态内存管理机制，以及如何通过特定api与linux内核交互</p>
<h2 id="1-a-namea页表">1. <a name=''></a>页表</h2>
<h3 id="11-a-name--x86_644a页表查询--以x86_64下的4级页表举例硬件">1.1. <a name='--x86_644'></a>页表查询&ndash;以x86_64下的4级页表举例(硬件)</h3>
<ul>
<li>流程总览(定义虚拟地址virt_addr, 寻找对应的物理地址phy_addr)</li>
<li>顺序: TLB -&gt; 页表结构cache -&gt; 页表(MMU硬件实现)</li>
<li>MMU = TLB(Translation Lookaside Buffer) + table walk unit</li>
</ul>
<h4 id="111-a-nametlbatlb转换">1.1.1. <a name='TLB'></a>TLB转换</h4>
<ol>
<li>明确概念:</li>
</ol>
<p>VPN(virtual page number), PPN(physical page number),VPO(virtual page offset)和PPO(physical page offset)</p>
<ul>
<li>对于线性地址和物理地址而言, 都是以page为最小的管理单元, 那么也就是说如果线性地址可以映射到某物理地址, 则两者页偏移相同(默认page size = 4K, 占用低12bits), 即VPO = PPO</li>
<li>TLB可以简单理解成VPN-&gt;PPN(36bits), 实现了一个线性映射, 基本结构如下:
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">___________________
|__VPN1___|__PPN1___|
|__VPN2___|__PPN2___|
|__VPN3___|__PPN3___|
...       ...
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<ol start="2">
<li>通过VPN(virt_addr[12:48])定位表项</li>
</ol>
<ul>
<li>
<p>全相连(full associative)&ndash; VPN可以被填充在TLB中的任何位置</p>
<ul>
<li>定位VPN对应的表项需要遍历TLB中的所有表项</li>
</ul>
</li>
<li>
<p>直接匹配&ndash; VPN被映射在特定位置</p>
<ul>
<li>如果TLB存在n个表项, 那么VPN%n即为该VPN的索引</li>
<li>定位到索引后, 查看VPN是否匹配, 如果不匹配则TLB miss</li>
</ul>
</li>
<li>
<p>组相连(set-associative)&ndash; 全相连和直接匹配相结合</p>
<ul>
<li>TLB被划分为m组, 每个组存在n表项, VPN分为set(VPN[47-log2(m):48]), tag(VPN[12:48-log2(m)])</li>
<li>VPN[47-log2(m):48]%m为该VPN的set索引</li>
<li>定位到索引后, 查看set内是否存在tag, 如果不存在则TLB miss</li>
</ul>
</li>
</ul>
<h4 id="112-a-name-1a页表转换">1.1.2. <a name='-1'></a>页表转换</h4>
<ol>
<li>明确概念:</li>
</ol>
<ul>
<li>对于四级页表: PGD(page global directory), PUD(page upper directory), PMD(page middle directory), PTE(page table entry), 每个页表占9bits, 支持48bits虚拟地址</li>
<li>对于五级页表：添加P4D表项, 支持57位虚拟地址</li>
</ul>
<ol start="2">
<li>通过virt_addr[12:48]定位page table entry</li>
</ol>
<ul>
<li>CR3寄存器存储PGD物理地址, virt_addr[39:48]为PGD_index, PGD+PGD_index=PGD_addr</li>
<li>virt_addr[30:39]为PUD_index, PGD_addr+PUD_index=PUD_addr</li>
<li>virt_addr[21:30]为PME_index, PUD_addr+PME_index=PME_addr</li>
<li>virt_addr[12:21]为PTE_index, PME_addr+PTE_index=PTE_addr</li>
</ul>
<ol start="3">
<li>PTE_addr即为page table entry是一个表项映射到PPN</li>
</ol>
<h4 id="113-a-namecachea页表结构cache转换">1.1.3. <a name='cache'></a>页表结构cache转换</h4>
<ol>
<li>明确概念:</li>
</ol>
<ul>
<li>如果某些虚拟地址临近, 那么很有可能他们会有相同的页表项(PGD or PUD or PMD or PTE),对于这种情况如果还是依次查询页表就会浪费大量时间, 所以存在页表结构cache, 用来缓存页表</li>
</ul>
<ol start="2">
<li>cache种类:</li>
</ol>
<ul>
<li>PDE cache(virt_addr[21:48]作为tag, 映射PME entry地址)</li>
<li>PDPTE cache(virt_addr[30:48]作为tag, 映射PUD entry地址)</li>
<li>PML4 cache(virt_addr[39:48]作为tag, 映射PGD entry地址)</li>
</ul>
<h3 id="12-a-name-1a拓展">1.2. <a name='-1'></a>拓展</h3>
<h4 id="121-a-namecache-1a普通页表cache">1.2.1. <a name='cache-1'></a>普通页表cache</h4>
<ol>
<li>明确概念:</li>
</ol>
<ul>
<li>页表保存在内存中, 可以被缓存到普通cache</li>
</ul>
<ol start="2">
<li>各级页表中存在PCD(page-level cache disable)标志位, 控制下一级页表是否需要被缓存</li>
</ol>
<h4 id="122-a-namehuge_pageahuge_page">1.2.2. <a name='Huge_Page'></a>Huge_Page</h4>
<ol>
<li>明确概念:</li>
</ol>
<ul>
<li>页表中指向下一级的地址是按页对齐的, 也就是低12bits无效, 可以用作flag标志位</li>
<li>page size flag为1时表示当前页表的下级地址对应大页地址而不是页表</li>
</ul>
<ol start="2">
<li>
<p>x86两级页表支持4MB大页(跳过PTE, 4K*2^10=4MB)</p>
</li>
<li>
<p>x86_64四级页表支持2MB大页(跳过PTE, 4K*2^9=2MB), 1GB大页(跳过PME, 2M*2^9=1GB)</p>
</li>
</ol>
<h4 id="123-a-name-1a页表标志位">1.2.3. <a name='-1'></a>页表标志位</h4>
<ul>
<li>
<p>P(Present) - 为1表明该page存在于当前物理内存中, 为0则触发page fault。</p>
</li>
<li>
<p>G(Global)- 标记kernel对应的页, 也存在于TLB entry, 表示该页不会被flush掉。</p>
</li>
<li>
<p>A(Access) - 当page被访问(读/写)过后, 硬件置1。软件可置0, 然后对应的TLB将会被flush掉。</p>
</li>
<li>
<p>D(Dirty)- 对写回的page有作用。当page被写入后, 硬件置1, 表明该page的内容比外部disk/flash对应部分要新, 当系统内存不足, 要将该page回收的时候, 需首先将其内容flush到外部存储, 之后软件将该标志位清0。</p>
</li>
<li>
<p>R/W和U/S属于权限控制类：</p>
</li>
</ul>
<ol>
<li>
<p>R/W(Read/Write) - 置1表示该page是writable的, 置0是readonly。</p>
</li>
<li>
<p>U/S(User/Supervisor) - 置0表示只有supervisor(比如操作系统中的kernel)才可访问该page, 置1表示user也可以访问。</p>
</li>
</ol>
<ul>
<li>PCD和PWT和cache属性相关：</li>
</ul>
<ol>
<li>
<p>PCD(Page Cache Disabled)- 置1表示disable, 即该page中的内容是不可以被cache的。如果置0(enable), 还要看CR0寄存器中的CD位这个总控开关是否也是0。</p>
</li>
<li>
<p>PWT (Page Write Through)- 置1表示该page对应的cache部分采用write through的方式, 否则采用write back。</p>
</li>
</ol>
<ul>
<li>64位特有:</li>
</ul>
<ol>
<li>
<p>XD (Execute Disable)- 在bit[63]中</p>
</li>
<li>
<p>CR3支持PCID:</p>
</li>
</ol>
<ul>
<li>CR4寄存器的PCIDE位 = 1, 则CR3低12位表示PCID(覆盖PCD和PWT&ndash;CR3低12bits只有PCD和PWT标志位)</li>
</ul>
<h2 id="2-a-namebuddya伙伴算法buddy">2. <a name='buddy'></a>伙伴算法(buddy)</h2>
<ul>
<li>alloc_pages(内存分配)概略图</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../mm/alloc_pages.png"
        data-srcset="../../mm/alloc_pages.png, ../../mm/alloc_pages.png 1.5x, ../../mm/alloc_pages.png 2x"
        data-sizes="auto"
        alt="../../mm/alloc_pages.png"
        title="alloc_pages" /></p>
<ul>
<li>__free_pages(内存释放)缩略图</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../mm/__free_pages.png"
        data-srcset="../../mm/__free_pages.png, ../../mm/__free_pages.png 1.5x, ../../mm/__free_pages.png 2x"
        data-sizes="auto"
        alt="../../mm/__free_pages.png"
        title="alloc_pages" /></p>
<h2 id="3-a-namealloc_pagesaalloc_pages源码分析">3. <a name='alloc_pages'></a>alloc_pages源码分析</h2>
<ol>
<li>pol变量保存内存分配策略(man set_mempolicy)</li>
</ol>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../mm/mpol.png"
        data-srcset="../../mm/mpol.png, ../../mm/mpol.png 1.5x, ../../mm/mpol.png 2x"
        data-sizes="auto"
        alt="../../mm/mpol.png"
        title="mpol" /></p>
<ul>
<li>MPOL_DEFAULT: 默认策略, 优先从当前结点分配内存, 若当前结点无空闲内存, 则从最近的有空闲内存的结点分配</li>
<li>MPOL_BIND: 指定内存分配结点集合, 若该集合内无空闲内存, 则分配失败</li>
<li>MPOL_INTERLEAVE: 内存分配要覆盖所有结点, 且每个结点使用的内存大小相同, 常用于共享内存区域</li>
<li>MPOL_PREFERRED: 从指定结点上分配内存, 若该结点无空闲内存, 则从其他结点分配</li>
<li>MPOL_LOCAL: 同MPOL_DEFAULT</li>
</ul>
<ol start="2">
<li>water_mark</li>
</ol>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../mm/water_mark.png"
        data-srcset="../../mm/water_mark.png, ../../mm/water_mark.png 1.5x, ../../mm/water_mark.png 2x"
        data-sizes="auto"
        alt="../../mm/water_mark.png"
        title="water_mark" /></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">enum</span> <span class="n">zone_watermarks</span> <span class="p">{</span>
        <span class="n">WMARK_MIN</span><span class="p">,</span>
        <span class="n">WMARK_LOW</span><span class="p">,</span>
        <span class="n">WMARK_HIGH</span><span class="p">,</span>
        <span class="n">NR_WMARK</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>WMARK_MIN: 当空闲页面的数量降到WMARK_MIN时, 唤醒 kswapd 守护进程以同步的方式进行直接内存回收, 同时只有GFP_ATOMIC可以在这种情况下分配内存</li>
<li>WMARK_LOW: 当空闲页面的数量降到WMARK_LOW时, 唤醒 kswapd 守护进程进行内存回收</li>
<li>WMARK_HIGH: kswapd进程休眠</li>
</ul>
<ol start="3">
<li>自旋锁(spin_lock)</li>
</ol>
<ul>
<li>为什么使用自旋锁:
<ul>
<li>使用常规锁会发生上下文切换,时间不可预期,对于一些简单的、极短的临界区来说是一种性能损耗</li>
<li>中断上下文是不允许睡眠的,除了自旋锁以外的其他锁都有可能导致睡眠或者进程切换,这是违背了中断的设计初衷,会发生不可预知的错误</li>
</ul>
</li>
<li>自旋锁的功能: 一直轮询等待检查临界区是否可用, 直至时间片用完</li>
<li>自旋锁使用原则:
<ul>
<li>禁止抢占: 如果A, B同时访问临界区, A进程首先获得自旋锁, B进程轮询等待, B抢占A后, B无法获得自旋锁, 造成死锁</li>
<li>禁止睡眠: 如果自旋锁锁住以后进入睡眠,而又不能进行处理器抢占,内核的调取器无法调取其他进程获得该CPU,从而导致该CPU被挂起；同时该进程也无法自唤醒且一直持有该自旋锁,进一步会导致其他使用该自旋锁的位置出现死锁</li>
</ul>
</li>
<li>自旋锁的几个实现:
<ul>
<li>spin_lock: 只禁止内核抢占, 不会关闭本地中断</li>
<li>spin_lock_irq: 禁止内核抢占, 且关闭本地中断</li>
<li>spin_lock_irqsave: 禁止内核抢占, 关闭中断, 保存中断状态寄存器的标志位</li>
</ul>
</li>
<li>spin_lock与spin_lock_irq的区别:
<ul>
<li>禁止中断与禁止抢占的原因相同</li>
</ul>
</li>
<li>spin_lock_irq与spin_lock_irqsave的区别:
<ul>
<li>假设临界区被两把spin_lock_irq(a-&gt;b)锁定, 当b解锁后(a还在加锁中), 不会保存a加锁后的中断寄存器状态(直接开中断), 也就是锁a在加锁时, 中断被打开, 导致spin_lock_irq在功能上和spin_lock相同, 也就具备了spin_lock的中断隐患</li>
</ul>
</li>
</ul>
<h3 id="31-a-namealloc_pages_currentaalloc_pages_current">3.1. <a name='alloc_pages_current'></a>alloc_pages_current</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">alloc_pages_current</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// pol变量保存内存分配策略(默认为default_policy)
</span><span class="c1"></span>	<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">pol</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">default_policy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="c1">// 如果不在中断状态下且未指定在当前结点分配内存时, 使用get_task_policy获得当前进程内存分配策略
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_interrupt</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">gfp</span> <span class="o">&amp;</span> <span class="n">__GFP_THISNODE</span><span class="p">))</span>
		<span class="n">pol</span> <span class="o">=</span> <span class="n">get_task_policy</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="c1">// 如果内存分配策略为MPOL_INTERLEAVE, 则进入alloc_page_interleave
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">pol</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">==</span> <span class="n">MPOL_INTERLEAVE</span><span class="p">)</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page_interleave</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">interleave_nodes</span><span class="p">(</span><span class="n">pol</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">__alloc_pages_nodemask</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
				<span class="n">policy_node</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">pol</span><span class="p">,</span> <span class="n">numa_node_id</span><span class="p">()),</span>
				<span class="n">policy_nodemask</span><span class="p">(</span><span class="n">gfp</span><span class="p">,</span> <span class="n">pol</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="32-a-namealloc_pages_nodemaska__alloc_pages_nodemask">3.2. <a name='alloc_pages_nodemask'></a>__alloc_pages_nodemask</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span>
<span class="nf">__alloc_pages_nodemask</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="kt">int</span> <span class="n">preferred_nid</span><span class="p">,</span>
							<span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloc_flags</span> <span class="o">=</span> <span class="n">ALLOC_WMARK_LOW</span><span class="p">;</span>
	<span class="n">gfp_t</span> <span class="n">alloc_mask</span><span class="p">;</span> <span class="cm">/* The gfp_t that was actually used for allocation */</span>
	<span class="k">struct</span> <span class="n">alloc_context</span> <span class="n">ac</span> <span class="o">=</span> <span class="p">{</span> <span class="p">};</span>

	<span class="c1">// 如果order大于MAX_ORDER(11), 则内存分配失败
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">order</span> <span class="o">&gt;=</span> <span class="n">MAX_ORDER</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_NOWARN</span><span class="p">));</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// 添加gfp_allowed_mask标志位
</span><span class="c1"></span>	<span class="n">gfp_mask</span> <span class="o">&amp;=</span> <span class="n">gfp_allowed_mask</span><span class="p">;</span>
	<span class="n">alloc_mask</span> <span class="o">=</span> <span class="n">gfp_mask</span><span class="p">;</span>

	<span class="c1">// 填充ac参数(用于内存分配), 并做一些检查
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prepare_alloc_pages</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">preferred_nid</span><span class="p">,</span> <span class="n">nodemask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ac</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alloc_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alloc_flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="c1">// 决定是否平衡各个zone中的脏页, 确定zone(相当于对prepare_alloc_pages的补充)
</span><span class="c1"></span>	<span class="n">finalise_ac</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ac</span><span class="p">);</span>

	<span class="c1">// 给alloc_flags添加ALLOC_NOFRAGMENT标志位(不使用zone备用迁移类型), 如果遍历完本地zone后仍然无法分配内存则取消该标志位, 该方案是为了减少内存碎片
</span><span class="c1"></span>	<span class="n">alloc_flags</span> <span class="o">|=</span> <span class="n">alloc_flags_nofragment</span><span class="p">(</span><span class="n">ac</span><span class="p">.</span><span class="n">preferred_zoneref</span><span class="o">-&gt;</span><span class="n">zone</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>

	<span class="c1">// 通过快分配分配内存页
</span><span class="c1"></span>	<span class="n">page</span> <span class="o">=</span> <span class="n">get_page_from_freelist</span><span class="p">(</span><span class="n">alloc_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ac</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">alloc_mask</span> <span class="o">=</span> <span class="n">current_gfp_context</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>
	<span class="n">ac</span><span class="p">.</span><span class="n">spread_dirty_pages</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ac</span><span class="p">.</span><span class="n">nodemask</span> <span class="o">!=</span> <span class="n">nodemask</span><span class="p">))</span>
		<span class="n">ac</span><span class="p">.</span><span class="n">nodemask</span> <span class="o">=</span> <span class="n">nodemask</span><span class="p">;</span>

	<span class="c1">// 通过慢分配分配内存页
</span><span class="c1"></span>	<span class="n">page</span> <span class="o">=</span> <span class="n">__alloc_pages_slowpath</span><span class="p">(</span><span class="n">alloc_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ac</span><span class="p">);</span>

<span class="nl">out</span><span class="p">:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcg_kmem_enabled</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_ACCOUNT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">page</span> <span class="o">&amp;&amp;</span>
	    <span class="n">unlikely</span><span class="p">(</span><span class="n">__memcg_kmem_charge</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__free_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace_mm_page_alloc</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">alloc_mask</span><span class="p">,</span> <span class="n">ac</span><span class="p">.</span><span class="n">migratetype</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>prepare_alloc_pages</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">prepare_alloc_pages</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">preferred_nid</span><span class="p">,</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">alloc_context</span> <span class="o">*</span><span class="n">ac</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="o">*</span><span class="n">alloc_mask</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">alloc_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// ac填充从gfp_mask获取的内存分配参数
</span><span class="c1"></span>
	<span class="c1">// 获得当前nodemask对应的zone的max_index
</span><span class="c1"></span>	<span class="n">ac</span><span class="o">-&gt;</span><span class="n">high_zoneidx</span> <span class="o">=</span> <span class="n">gfp_zone</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>

	<span class="c1">// 获得node对应的zone_list
</span><span class="c1"></span>	<span class="n">ac</span><span class="o">-&gt;</span><span class="n">zonelist</span> <span class="o">=</span> <span class="n">node_zonelist</span><span class="p">(</span><span class="n">preferred_nid</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="n">ac</span><span class="o">-&gt;</span><span class="n">nodemask</span> <span class="o">=</span> <span class="n">nodemask</span><span class="p">;</span>

	<span class="c1">// 选择迁移类型
</span><span class="c1"></span>	<span class="n">ac</span><span class="o">-&gt;</span><span class="n">migratetype</span> <span class="o">=</span> <span class="n">gfpflags_to_migratetype</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>

	<span class="c1">// 判断是否存在cpuset机制
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">cpusets_enabled</span><span class="p">())</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">alloc_mask</span> <span class="o">|=</span> <span class="n">__GFP_HARDWALL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">nodemask</span><span class="p">)</span>
			<span class="n">ac</span><span class="o">-&gt;</span><span class="n">nodemask</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpuset_current_mems_allowed</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">alloc_flags</span> <span class="o">|=</span> <span class="n">ALLOC_CPUSET</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// 函数未实现
</span><span class="c1"></span>	<span class="n">fs_reclaim_acquire</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>
	<span class="n">fs_reclaim_release</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>

    <span class="c1">// 如果内存紧张可能会休眠
</span><span class="c1"></span>	<span class="n">might_sleep_if</span><span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_DIRECT_RECLAIM</span><span class="p">);</span>

	<span class="c1">// 对gfp_mask, ord做检查(默认没有开启CONFIG_FAIL_PAGE_ALLOC的情况下, 直接return false)
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">should_fail_alloc_page</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="c1">// 匹配CMA机制
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_CMA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">migratetype</span> <span class="o">==</span> <span class="n">MIGRATE_MOVABLE</span><span class="p">)</span>
		<span class="o">*</span><span class="n">alloc_flags</span> <span class="o">|=</span> <span class="n">ALLOC_CMA</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>finalise_ac</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">finalise_ac</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="k">struct</span> <span class="n">alloc_context</span> <span class="o">*</span><span class="n">ac</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Dirty zone balancing only done in the fast path */</span>
	<span class="n">ac</span><span class="o">-&gt;</span><span class="n">spread_dirty_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_WRITE</span><span class="p">);</span>

    <span class="c1">// 从zone_list头部开始寻找匹配nodemask的zoneref
</span><span class="c1"></span>	<span class="n">ac</span><span class="o">-&gt;</span><span class="n">preferred_zoneref</span> <span class="o">=</span> <span class="n">first_zones_zonelist</span><span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">zonelist</span><span class="p">,</span>
					<span class="n">ac</span><span class="o">-&gt;</span><span class="n">high_zoneidx</span><span class="p">,</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">nodemask</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="321-a-nameget_page_from_freelistaget_page_from_freelist">3.2.1. <a name='get_page_from_freelist'></a>get_page_from_freelist</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span>
<span class="nf">get_page_from_freelist</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alloc_flags</span><span class="p">,</span>
						<span class="k">const</span> <span class="k">struct</span> <span class="n">alloc_context</span> <span class="o">*</span><span class="n">ac</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zoneref</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pglist_data</span> <span class="o">*</span><span class="n">last_pgdat_dirty_limit</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">bool</span> <span class="n">no_fallback</span><span class="p">;</span>

<span class="nl">retry</span><span class="p">:</span>
	<span class="cm">/*
</span><span class="cm">	 * Scan zonelist, looking for a zone with enough free.
</span><span class="cm">	 */</span>

	<span class="c1">// ALLOC_NOFRAGMENT标志位由alloc_flags_nofragment()函数设置
</span><span class="c1"></span>	<span class="c1">// no_fallback: node-&gt;node_zonelists[]包含本node的zones以及备用zones, 设置fallback后可使用备用zones
</span><span class="c1"></span>	<span class="n">no_fallback</span> <span class="o">=</span> <span class="n">alloc_flags</span> <span class="o">&amp;</span> <span class="n">ALLOC_NOFRAGMENT</span><span class="p">;</span>
	<span class="n">z</span> <span class="o">=</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">preferred_zoneref</span><span class="p">;</span>

	<span class="c1">// 遍历zone
</span><span class="c1"></span>	<span class="n">for_next_zone_zonelist_nodemask</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">zonelist</span><span class="p">,</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">high_zoneidx</span><span class="p">,</span>
								<span class="n">ac</span><span class="o">-&gt;</span><span class="n">nodemask</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mark</span><span class="p">;</span>

		<span class="c1">// 判断cpuset是否开启且当前CPU是否允许在内存域zone所在结点中分配内存
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">cpusets_enabled</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">alloc_flags</span> <span class="o">&amp;</span> <span class="n">ALLOC_CPUSET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">__cpuset_zone_allowed</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

		<span class="c1">// ac-&gt;spread_dirty_pages不为0表示gfp_mask存在__GFP_WRITE标志位, 有可能增加脏页
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">spread_dirty_pages</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">last_pgdat_dirty_limit</span> <span class="o">==</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">zone_pgdat</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="c1">// 如果zone对应的node脏页超标则使用last_pgdat_dirty_limit标识, 并跳过该zone
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_dirty_ok</span><span class="p">(</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">zone_pgdat</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">last_pgdat_dirty_limit</span> <span class="o">=</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">zone_pgdat</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// 如果设置no_fallback且当前zone并非preferred_zone, 则索引zone-&gt;node, 如果该node并非preferred_zone-&gt;node, 则取消ALLOC_NOFRAGMENT标志位即设置fallback(因为相比于内存碎片, 内存局部性更重要)
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">no_fallback</span> <span class="o">&amp;&amp;</span> <span class="n">nr_online_nodes</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
		    <span class="n">zone</span> <span class="o">!=</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">preferred_zoneref</span><span class="o">-&gt;</span><span class="n">zone</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">local_nid</span><span class="p">;</span>

			<span class="n">local_nid</span> <span class="o">=</span> <span class="n">zone_to_nid</span><span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">preferred_zoneref</span><span class="o">-&gt;</span><span class="n">zone</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">zone_to_nid</span><span class="p">(</span><span class="n">zone</span><span class="p">)</span> <span class="o">!=</span> <span class="n">local_nid</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">alloc_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ALLOC_NOFRAGMENT</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// 获取该zone的水准, 并检查该zone的水位是否水准之上
</span><span class="c1"></span>		<span class="n">mark</span> <span class="o">=</span> <span class="n">wmark_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">alloc_flags</span> <span class="o">&amp;</span> <span class="n">ALLOC_WMARK_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zone_watermark_fast</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">mark</span><span class="p">,</span>
				       <span class="n">ac_classzone_idx</span><span class="p">(</span><span class="n">ac</span><span class="p">),</span> <span class="n">alloc_flags</span><span class="p">,</span>
				       <span class="n">gfp_mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

			<span class="c1">// 如果存在ALLOC_NO_WATERMARKS标志位则忽略水位, 进入try_this_zone
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">alloc_flags</span> <span class="o">&amp;</span> <span class="n">ALLOC_NO_WATERMARKS</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">try_this_zone</span><span class="p">;</span>

			<span class="cm">/*
</span><span class="cm">			static bool zone_allows_reclaim(struct zone *local_zone, struct zone *zone)
</span><span class="cm">			{
</span><span class="cm">				return node_distance(zone_to_nid(local_zone), zone_to_nid(zone)) &lt;=
</span><span class="cm">							node_reclaim_distance;
</span><span class="cm">			}
</span><span class="cm">			*/</span>
			<span class="c1">// 如果系统不允许回收内存或者preferred-&gt;zone与当前zone的node_distance大于node_reclaim_distance(默认30), 则更换zone
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">node_reclaim_mode</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
			    <span class="o">!</span><span class="n">zone_allows_reclaim</span><span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">preferred_zoneref</span><span class="o">-&gt;</span><span class="n">zone</span><span class="p">,</span> <span class="n">zone</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="c1">// 内存回收
</span><span class="c1"></span>			<span class="n">ret</span> <span class="o">=</span> <span class="n">node_reclaim</span><span class="p">(</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">zone_pgdat</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">case</span> <span class="nl">NODE_RECLAIM_NOSCAN</span><span class="p">:</span>
				<span class="cm">/* did not scan */</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">case</span> <span class="nl">NODE_RECLAIM_FULL</span><span class="p">:</span>
				<span class="cm">/* scanned but unreclaimable */</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">default</span><span class="o">:</span>
				<span class="c1">// 内存回收后, 水位正常
</span><span class="c1"></span>				<span class="k">if</span> <span class="p">(</span><span class="n">zone_watermark_ok</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">mark</span><span class="p">,</span>
						<span class="n">ac_classzone_idx</span><span class="p">(</span><span class="n">ac</span><span class="p">),</span> <span class="n">alloc_flags</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">try_this_zone</span><span class="p">;</span>

				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="nl">try_this_zone</span><span class="p">:</span>
        <span class="c1">// 伙伴算法开始分配页内存
</span><span class="c1"></span>		<span class="n">page</span> <span class="o">=</span> <span class="n">rmqueue</span><span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">preferred_zoneref</span><span class="o">-&gt;</span><span class="n">zone</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
				<span class="n">gfp_mask</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">,</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">migratetype</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">prep_new_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">order</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">alloc_flags</span> <span class="o">&amp;</span> <span class="n">ALLOC_HARDER</span><span class="p">)))</span>
				<span class="n">reserve_highatomic_pageblock</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>

			<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="rmqueue">rmqueue</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">rmqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">preferred_zone</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
			<span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloc_flags</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">migratetype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="c1">//如果分配单页, 则进入rmqueue_pcplist
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">order</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">rmqueue_pcplist</span><span class="p">(</span><span class="n">preferred_zone</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">,</span>
					<span class="n">migratetype</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

    <span class="c1">// 不能使用__GFP_NOFAIL, 分配order&gt;1的页
</span><span class="c1"></span>	<span class="n">WARN_ON_ONCE</span><span class="p">((</span><span class="n">gfp_flags</span> <span class="o">&amp;</span> <span class="n">__GFP_NOFAIL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">order</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">));</span>

	<span class="c1">// 使用自旋锁加锁zone资源
</span><span class="c1"></span>	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="c1">// ALLOC_HARDER表示高优先级分配, 进入__rmqueue_smallest
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">alloc_flags</span> <span class="o">&amp;</span> <span class="n">ALLOC_HARDER</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">__rmqueue_smallest</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">MIGRATE_HIGHATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
				<span class="c1">// 用于debug的插桩设计
</span><span class="c1"></span>				<span class="n">trace_mm_page_alloc_zone_locked</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="c1">// 不满足上诉条件或page未分配成功, 进入__rmqueue
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">__rmqueue</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="n">check_new_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">));</span>
		<span class="c1">// check_new_pages遍历page_block中的struct page, 检查page成员, 如果出错则打印错误原因
</span><span class="c1"></span>	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>

	<span class="c1">// page_block被分配后更新zone成员信息 
</span><span class="c1"></span>	<span class="n">__mod_zone_freepage_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">),</span>
				  <span class="n">get_pcppage_migratetype</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="n">__count_zid_vm_events</span><span class="p">(</span><span class="n">PGALLOC</span><span class="p">,</span> <span class="n">page_zonenum</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">);</span>

	<span class="c1">// 如果系统是NUMA架构, 则更新NUMA hit/miss 数据
</span><span class="c1"></span>	<span class="n">zone_statistics</span><span class="p">(</span><span class="n">preferred_zone</span><span class="p">,</span> <span class="n">zone</span><span class="p">);</span>

	<span class="c1">// 恢复中断信息
</span><span class="c1"></span>	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

<span class="nl">out</span><span class="p">:</span>
	<span class="cm">/* Separate test+clear to avoid unnecessary atomics */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">ZONE_BOOSTED_WATERMARK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">ZONE_BOOSTED_WATERMARK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">wakeup_kswapd</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">zone_idx</span><span class="p">(</span><span class="n">zone</span><span class="p">));</span>
	<span class="p">}</span>

    <span class="c1">// 编译阶段的变量类型检查
</span><span class="c1"></span>	<span class="n">VM_BUG_ON_PAGE</span><span class="p">(</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="n">bad_range</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">page</span><span class="p">),</span> <span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>

<span class="nl">failed</span><span class="p">:</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h6 id="rmqueue_pcplis">rmqueue_pcplis</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">rmqueue_pcplist</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">preferred_zone</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">migratetype</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloc_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">per_cpu_pages</span> <span class="o">*</span><span class="n">pcp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="c1">// 禁用全部中断, 并将当前中断状态保存至flags
</span><span class="c1"></span>	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="c1">// 获得当前cpu的pcp结构体(热页)
</span><span class="c1"></span>	<span class="n">pcp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">pageset</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pcp</span><span class="p">;</span>

	<span class="c1">// 根据迁移类型选择热页链表
</span><span class="c1"></span>	<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pcp</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">[</span><span class="n">migratetype</span><span class="p">];</span>

	<span class="c1">// 在list中分配内存页
</span><span class="c1"></span>	<span class="n">page</span> <span class="o">=</span> <span class="n">__rmqueue_pcplist</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span>  <span class="n">migratetype</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">,</span> <span class="n">pcp</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__count_zid_vm_events</span><span class="p">(</span><span class="n">PGALLOC</span><span class="p">,</span> <span class="n">page_zonenum</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>

		<span class="c1">// Update NUMA hit/miss statistics
</span><span class="c1"></span>		<span class="n">zone_statistics</span><span class="p">(</span><span class="n">preferred_zone</span><span class="p">,</span> <span class="n">zone</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// 恢复中断状态并开中断
</span><span class="c1"></span>	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<ul>
<li>__rmqueue_pcplist</li>
</ul>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">__rmqueue_pcplist</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="kt">int</span> <span class="n">migratetype</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloc_flags</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">per_cpu_pages</span> <span class="o">*</span><span class="n">pcp</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="c1">// 如果列表为空, 则使用rmqueue_bulk装载内存页进入列表
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pcp</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+=</span> <span class="n">rmqueue_bulk</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">pcp</span><span class="o">-&gt;</span><span class="n">batch</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span>
					<span class="n">migratetype</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">list</span><span class="p">)))</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="c1">// 获得lru列表首部页结点
</span><span class="c1"></span>		<span class="n">page</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>

		<span class="c1">// 将页结点从page-&gt;lru列表删除
</span><span class="c1"></span>		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>

		<span class="c1">// 空闲page计数器-1
</span><span class="c1"></span>		<span class="n">pcp</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>

		<span class="c1">// 对page做安全检查
</span><span class="c1"></span>	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">check_new_pcp</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<blockquote>
<ul>
<li>rmqueue_bulk</li>
</ul>
</blockquote>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">int</span> <span class="nf">rmqueue_bulk</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">migratetype</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloc_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">alloced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">// 对zone资源加锁
</span><span class="c1"></span>	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 从zone中取出page放入pcp热页缓存列表, 直至pcp被填满
</span><span class="c1"></span>		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">__rmqueue</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">,</span>
								<span class="n">alloc_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="c1">// check_pcp_refill封装check_new_page
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">check_pcp_refill</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="c1">// 添加page至list-&gt;lru
</span><span class="c1"></span>		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">alloced</span><span class="o">++</span><span class="p">;</span>

		<span class="c1">// 如果page位于cma中, 则更新NR_FREE_CMA_PAGES
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">is_migrate_cma</span><span class="p">(</span><span class="n">get_pcppage_migratetype</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>
			<span class="n">__mod_zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_FREE_CMA_PAGES</span><span class="p">,</span>
					      <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="c1">// 从zone摘取page_block过程循环了i次, 每个page_block包含2^i个page, NR_FREE_PAGES-i &lt;&lt; order, 更新NR_FREE_PAGES
</span><span class="c1"></span>	<span class="n">__mod_zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_FREE_PAGES</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">));</span>

	<span class="c1">// 解锁
</span><span class="c1"></span>	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">alloced</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h6 id="__rmqueue_smallest">__rmqueue_smallest</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">__always_inline</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">__rmqueue_smallest</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">migratetype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">current_order</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">free_area</span> <span class="o">*</span><span class="n">area</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="c1">// 从指定order到MAX_ORDER遍历zone-&gt;free_area[]
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="n">current_order</span> <span class="o">=</span> <span class="n">order</span><span class="p">;</span> <span class="n">current_order</span> <span class="o">&lt;</span> <span class="n">MAX_ORDER</span><span class="p">;</span> <span class="o">++</span><span class="n">current_order</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">area</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">free_area</span><span class="p">[</span><span class="n">current_order</span><span class="p">]);</span>

		<span class="c1">// 从zone-&gt;free_area[][migratetype]-&gt;lru链表头部获得page()
</span><span class="c1"></span>		<span class="n">page</span> <span class="o">=</span> <span class="n">get_page_from_free_area</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="c1">// 从zone-&gt;free_area[][migratetype]-&gt;lru中删除page, 更新zone成员
</span><span class="c1"></span>		<span class="n">del_page_from_free_area</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">area</span><span class="p">);</span>

		<span class="c1">// 将current_order阶的page_block拆成小块,并将小块放到对应的阶的链表中去
</span><span class="c1"></span>		<span class="n">expand</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">current_order</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>

		<span class="c1">// 设置page迁移类型
</span><span class="c1"></span>		<span class="n">set_pcppage_migratetype</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h6 id="__rmqueue">__rmqueue</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">__always_inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span>
<span class="nf">__rmqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="kt">int</span> <span class="n">migratetype</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloc_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

<span class="nl">retry</span><span class="p">:</span>
	<span class="c1">// 使用__rmqueue_smallest获得page
</span><span class="c1"></span>	<span class="n">page</span> <span class="o">=</span> <span class="n">__rmqueue_smallest</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="c1">// page分配失败后, 如果迁移类型是MIGRATE_MOVABLE, 进入__rmqueue_cma_fallback
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">migratetype</span> <span class="o">==</span> <span class="n">MIGRATE_MOVABLE</span><span class="p">)</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">__rmqueue_cma_fallback</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>

		<span class="c1">// page分配再次失败后使用判断是否可以使用备用迁移类型(如果可以则修改order, migratetype)然后跳转进入retry
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="n">__rmqueue_fallback</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">,</span>
								<span class="n">alloc_flags</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace_mm_page_alloc_zone_locked</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<ul>
<li>__rmqueue_fallback</li>
</ul>
</blockquote>
<ol>
<li>备用迁移类型</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">int</span> <span class="n">fallbacks</span><span class="p">[</span><span class="n">MIGRATE_TYPES</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">MIGRATE_UNMOVABLE</span><span class="p">]</span>   <span class="o">=</span> <span class="p">{</span> <span class="n">MIGRATE_RECLAIMABLE</span><span class="p">,</span> <span class="n">MIGRATE_MOVABLE</span><span class="p">,</span>   <span class="n">MIGRATE_TYPES</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">MIGRATE_MOVABLE</span><span class="p">]</span>     <span class="o">=</span> <span class="p">{</span> <span class="n">MIGRATE_RECLAIMABLE</span><span class="p">,</span> <span class="n">MIGRATE_UNMOVABLE</span><span class="p">,</span> <span class="n">MIGRATE_TYPES</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">MIGRATE_RECLAIMABLE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">MIGRATE_UNMOVABLE</span><span class="p">,</span>   <span class="n">MIGRATE_MOVABLE</span><span class="p">,</span>   <span class="n">MIGRATE_TYPES</span> <span class="p">},</span>
<span class="cp">#ifdef CONFIG_CMA
</span><span class="cp">#endif
</span><span class="cp">#ifdef CONFIG_MEMORY_ISOLATION
</span><span class="cp">#endif
</span><span class="cp"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>__rmqueue_fallback</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">bool</span>
<span class="nf">__rmqueue_fallback</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start_migratetype</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloc_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">free_area</span> <span class="o">*</span><span class="n">area</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">current_order</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">min_order</span> <span class="o">=</span> <span class="n">order</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fallback_mt</span><span class="p">;</span>
	<span class="kt">bool</span> <span class="n">can_steal</span><span class="p">;</span>

	<span class="c1">// 如果设置alloc_flags为ALLOC_NOFRAGMENT(内存碎片优化), min_order=pageblock_order(MAX_ORDER-1)---尽可能分配大页
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_flags</span> <span class="o">&amp;</span> <span class="n">ALLOC_NOFRAGMENT</span><span class="p">)</span>
		<span class="n">min_order</span> <span class="o">=</span> <span class="n">pageblock_order</span><span class="p">;</span>

	<span class="c1">// 遍历zone-&gt;free_area[order](order=MAX_ORDER-1~min_order)
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="n">current_order</span> <span class="o">=</span> <span class="n">MAX_ORDER</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">current_order</span> <span class="o">&gt;=</span> <span class="n">min_order</span><span class="p">;</span>
				<span class="o">--</span><span class="n">current_order</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">area</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">free_area</span><span class="p">[</span><span class="n">current_order</span><span class="p">]);</span>

		<span class="c1">// 查找可以盗取的迁移类型
</span><span class="c1"></span>		<span class="n">fallback_mt</span> <span class="o">=</span> <span class="n">find_suitable_fallback</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">current_order</span><span class="p">,</span>
				<span class="n">start_migratetype</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">can_steal</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fallback_mt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="c1">// 如果can_steal=0且迁移类型为MIGRATE_MOVABLE, 当前所在的order大于需求order, 跳转进入find_smallest
</span><span class="c1"></span>		<span class="c1">// 这里的can_steal=0并不表示不能盗取, 只是对于迁移类型为MIGRATE_MOVABLE的内存分配需求有更好的解决方法(窃取和拆分最小的可用页块而不是最大的可用页块)所以单独列出
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_steal</span> <span class="o">&amp;&amp;</span> <span class="n">start_migratetype</span> <span class="o">==</span> <span class="n">MIGRATE_MOVABLE</span>
					<span class="o">&amp;&amp;</span> <span class="n">current_order</span> <span class="o">&gt;</span> <span class="n">order</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">find_smallest</span><span class="p">;</span>

		<span class="k">goto</span> <span class="n">do_steal</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

<span class="nl">find_smallest</span><span class="p">:</span>
	<span class="c1">// 从最小的order开始遍历
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="n">current_order</span> <span class="o">=</span> <span class="n">order</span><span class="p">;</span> <span class="n">current_order</span> <span class="o">&lt;</span> <span class="n">MAX_ORDER</span><span class="p">;</span>
							<span class="n">current_order</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">area</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">free_area</span><span class="p">[</span><span class="n">current_order</span><span class="p">]);</span>
		<span class="n">fallback_mt</span> <span class="o">=</span> <span class="n">find_suitable_fallback</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">current_order</span><span class="p">,</span>
				<span class="n">start_migratetype</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">can_steal</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fallback_mt</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">current_order</span> <span class="o">==</span> <span class="n">MAX_ORDER</span><span class="p">);</span>

<span class="nl">do_steal</span><span class="p">:</span>
	<span class="c1">// 获得备用迁移类型对应的page_block
</span><span class="c1"></span>	<span class="n">page</span> <span class="o">=</span> <span class="n">get_page_from_free_area</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">fallback_mt</span><span class="p">);</span>

	<span class="c1">// 判断直接盗取(改变page_block的迁移类型), 还是借用(分配但不改变页块迁移类型)
</span><span class="c1"></span>	<span class="n">steal_suitable_fallback</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">,</span> <span class="n">start_migratetype</span><span class="p">,</span>
								<span class="n">can_steal</span><span class="p">);</span>

	<span class="n">trace_mm_page_alloc_extfrag</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">current_order</span><span class="p">,</span>
		<span class="n">start_migratetype</span><span class="p">,</span> <span class="n">fallback_mt</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<blockquote>
<ul>
<li>find_suitable_fallback</li>
</ul>
</blockquote>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">find_suitable_fallback</span><span class="p">(</span><span class="k">struct</span> <span class="n">free_area</span> <span class="o">*</span><span class="n">area</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">migratetype</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">only_stealable</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">*</span><span class="n">can_steal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fallback_mt</span><span class="p">;</span>

	<span class="c1">// 判断该order内存链表是否为空
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">nr_free</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="o">*</span><span class="n">can_steal</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 遍历备用迁移类型
</span><span class="c1"></span>		<span class="n">fallback_mt</span> <span class="o">=</span> <span class="n">fallbacks</span><span class="p">[</span><span class="n">migratetype</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>

		<span class="c1">// MIGRATE_TYPES表示不可用, 退出
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">fallback_mt</span> <span class="o">==</span> <span class="n">MIGRATE_TYPES</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="c1">// 如果area-&gt;free_list[fallback_mt]为空, 遍历下一个备用迁移类型
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">free_area_empty</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">fallback_mt</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="c1">// 判断是否可盗取
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">can_steal_fallback</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">))</span>
			<span class="o">*</span><span class="n">can_steal</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">only_stealable</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">fallback_mt</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">can_steal</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">fallback_mt</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<blockquote>
<blockquote>
<ul>
<li>can_steal_fallback</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">bool</span> <span class="nf">can_steal_fallback</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start_mt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// 判断order是否大于等于MAX_ORDER-1
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">&gt;=</span> <span class="n">pageblock_order</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="c1">// 如果order&gt;=(MAX_ORDER-1)/2 或者 迁移类型为MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE 或者 page_group_by_mobility_disabled=1(gdb动调发现默认为0) 则表示可以盗取
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">&gt;=</span> <span class="n">pageblock_order</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">||</span>
		<span class="n">start_mt</span> <span class="o">==</span> <span class="n">MIGRATE_RECLAIMABLE</span> <span class="o">||</span>
		<span class="n">start_mt</span> <span class="o">==</span> <span class="n">MIGRATE_UNMOVABLE</span> <span class="o">||</span>
		<span class="n">page_group_by_mobility_disabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="322-a-namealloc_pages_slowpatha_alloc_pages_slowpath">3.2.2. <a name='alloc_pages_slowpath'></a>_alloc_pages_slowpath</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span>
<span class="nf">__alloc_pages_slowpath</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">alloc_context</span> <span class="o">*</span><span class="n">ac</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">bool</span> <span class="n">can_direct_reclaim</span> <span class="o">=</span> <span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_DIRECT_RECLAIM</span><span class="p">;</span>

	<span class="c1">// PAGE_ALLOC_COSTLY_ORDER=3
</span><span class="c1"></span>	<span class="k">const</span> <span class="kt">bool</span> <span class="n">costly_order</span> <span class="o">=</span> <span class="n">order</span> <span class="o">&gt;</span> <span class="n">PAGE_ALLOC_COSTLY_ORDER</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloc_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">did_some_progress</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">compact_priority</span> <span class="n">compact_priority</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">compact_result</span> <span class="n">compact_result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">compaction_retries</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">no_progress_loops</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpuset_mems_cookie</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reserve_flags</span><span class="p">;</span>

	<span class="c1">// 如果内存分配标志包含__GFP_ATOMIC(来自不能阻塞或延迟和失败没有回调的原子上下文的请求), __GFP_DIRECT_RECLAIM(可以直接回收, 表示有回收需要时会阻塞请求), 明显二者冲突, 此处做一个校验
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">((</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">__GFP_ATOMIC</span><span class="o">|</span><span class="n">__GFP_DIRECT_RECLAIM</span><span class="p">))</span> <span class="o">==</span>
				<span class="p">(</span><span class="n">__GFP_ATOMIC</span><span class="o">|</span><span class="n">__GFP_DIRECT_RECLAIM</span><span class="p">)))</span>
		<span class="n">gfp_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">__GFP_ATOMIC</span><span class="p">;</span>

<span class="nl">retry_cpuset</span><span class="p">:</span>
	<span class="n">compaction_retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">no_progress_loops</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">compact_priority</span> <span class="o">=</span> <span class="n">DEF_COMPACT_PRIORITY</span><span class="p">;</span>
	<span class="n">cpuset_mems_cookie</span> <span class="o">=</span> <span class="n">read_mems_allowed_begin</span><span class="p">();</span>

	<span class="c1">// 降低要求, 重新构建标志位
</span><span class="c1"></span>	<span class="n">alloc_flags</span> <span class="o">=</span> <span class="n">gfp_to_alloc_flags</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>

	<span class="n">ac</span><span class="o">-&gt;</span><span class="n">preferred_zoneref</span> <span class="o">=</span> <span class="n">first_zones_zonelist</span><span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">zonelist</span><span class="p">,</span>
					<span class="n">ac</span><span class="o">-&gt;</span><span class="n">high_zoneidx</span><span class="p">,</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">nodemask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">preferred_zoneref</span><span class="o">-&gt;</span><span class="n">zone</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nopage</span><span class="p">;</span>

	<span class="c1">// 如果设置了ALLOC_KSWAPD, 则唤醒交换进程
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_flags</span> <span class="o">&amp;</span> <span class="n">ALLOC_KSWAPD</span><span class="p">)</span>
		<span class="n">wake_all_kswapds</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">ac</span><span class="p">);</span>

	<span class="c1">// 内存调整后再次分配
</span><span class="c1"></span>	<span class="n">page</span> <span class="o">=</span> <span class="n">get_page_from_freelist</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">,</span> <span class="n">ac</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">got_pg</span><span class="p">;</span>

	<span class="c1">// 如果满足以下条件则尝试进行内存压缩
</span><span class="c1"></span>	<span class="c1">// 1. 如果标识__GFP_DIRECT_RECLAIM&amp;ALLOC_NO_WATERMARK且order&gt;3(costly_order=1)则进入__alloc_pages_direct_compact
</span><span class="c1"></span>	<span class="c1">// 2. 如果标识__GFP_DIRECT_RECLAIM&amp;ALLOC_NO_WATERMARK且order&lt;3(costly_order=0)且迁移类型不为MIGRATE_MOVABLE则进入__alloc_pages_direct_compact
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">can_direct_reclaim</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">costly_order</span> <span class="o">||</span>
			   <span class="p">(</span><span class="n">order</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">migratetype</span> <span class="o">!=</span> <span class="n">MIGRATE_MOVABLE</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">gfp_pfmemalloc_allowed</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">__alloc_pages_direct_compact</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
						<span class="n">alloc_flags</span><span class="p">,</span> <span class="n">ac</span><span class="p">,</span>
						<span class="n">INIT_COMPACT_PRIORITY</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">compact_result</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">got_pg</span><span class="p">;</span>

		<span class="c1">// 设置压缩参数, 后面会专门讲解这部分
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">&gt;=</span> <span class="n">pageblock_order</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_IO</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="o">!</span><span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_RETRY_MAYFAIL</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">compact_result</span> <span class="o">==</span> <span class="n">COMPACT_SKIPPED</span> <span class="o">||</span>
			    <span class="n">compact_result</span> <span class="o">==</span> <span class="n">COMPACT_DEFERRED</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">nopage</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">costly_order</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_NORETRY</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">compact_result</span> <span class="o">==</span> <span class="n">COMPACT_DEFERRED</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">nopage</span><span class="p">;</span>

			<span class="n">compact_priority</span> <span class="o">=</span> <span class="n">INIT_COMPACT_PRIORITY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">retry</span><span class="p">:</span>
	<span class="c1">// 再次唤醒交换进程
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_flags</span> <span class="o">&amp;</span> <span class="n">ALLOC_KSWAPD</span><span class="p">)</span>
		<span class="n">wake_all_kswapds</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">ac</span><span class="p">);</span>

	<span class="n">reserve_flags</span> <span class="o">=</span> <span class="n">__gfp_pfmemalloc_flags</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reserve_flags</span><span class="p">)</span>
		<span class="n">alloc_flags</span> <span class="o">=</span> <span class="n">reserve_flags</span><span class="p">;</span>

	<span class="c1">// 如果cpu不允许在zone所在node中分配内存且可以进行no_water_mark分配则通过ac-&gt;nodemask = NULL降低内存分配标准, 再次分配
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">alloc_flags</span> <span class="o">&amp;</span> <span class="n">ALLOC_CPUSET</span><span class="p">)</span> <span class="o">||</span> <span class="n">reserve_flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ac</span><span class="o">-&gt;</span><span class="n">nodemask</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ac</span><span class="o">-&gt;</span><span class="n">preferred_zoneref</span> <span class="o">=</span> <span class="n">first_zones_zonelist</span><span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">zonelist</span><span class="p">,</span>
					<span class="n">ac</span><span class="o">-&gt;</span><span class="n">high_zoneidx</span><span class="p">,</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">nodemask</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">get_page_from_freelist</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">,</span> <span class="n">ac</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">got_pg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_direct_reclaim</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nopage</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_MEMALLOC</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nopage</span><span class="p">;</span>

	<span class="c1">// 内存回收后分配内存
</span><span class="c1"></span>	<span class="n">page</span> <span class="o">=</span> <span class="n">__alloc_pages_direct_reclaim</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">,</span> <span class="n">ac</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">did_some_progress</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">got_pg</span><span class="p">;</span>

	<span class="c1">// 内存压缩后分配内存
</span><span class="c1"></span>	<span class="n">page</span> <span class="o">=</span> <span class="n">__alloc_pages_direct_compact</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">,</span> <span class="n">ac</span><span class="p">,</span>
					<span class="n">compact_priority</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">compact_result</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">got_pg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_NORETRY</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nopage</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">costly_order</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_RETRY_MAYFAIL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">nopage</span><span class="p">;</span>

	<span class="c1">// 分析是否应该再次内存回收
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">should_reclaim_retry</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">ac</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">,</span>
				 <span class="n">did_some_progress</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">no_progress_loops</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

	<span class="c1">// 分析是否应该再次内存压缩
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">did_some_progress</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			<span class="n">should_compact_retry</span><span class="p">(</span><span class="n">ac</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">,</span>
				<span class="n">compact_result</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">compact_priority</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">compaction_retries</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">check_retry_cpuset</span><span class="p">(</span><span class="n">cpuset_mems_cookie</span><span class="p">,</span> <span class="n">ac</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry_cpuset</span><span class="p">;</span>

	<span class="c1">// 杀死一些进程以获得内存
</span><span class="c1"></span>	<span class="n">page</span> <span class="o">=</span> <span class="n">__alloc_pages_may_oom</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">ac</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">did_some_progress</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">got_pg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tsk_is_oom_victim</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">alloc_flags</span> <span class="o">==</span> <span class="n">ALLOC_OOM</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_NOMEMALLOC</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">nopage</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">did_some_progress</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">no_progress_loops</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">nopage</span><span class="p">:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_retry_cpuset</span><span class="p">(</span><span class="n">cpuset_mems_cookie</span><span class="p">,</span> <span class="n">ac</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry_cpuset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_NOFAIL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">can_direct_reclaim</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_MEMALLOC</span><span class="p">);</span>

		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">order</span> <span class="o">&gt;</span> <span class="n">PAGE_ALLOC_COSTLY_ORDER</span><span class="p">);</span>

		<span class="c1">// 使用ALLOC_HARDER标志进行内存分配
</span><span class="c1"></span>		<span class="n">page</span> <span class="o">=</span> <span class="n">__alloc_pages_cpuset_fallback</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">ALLOC_HARDER</span><span class="p">,</span> <span class="n">ac</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">got_pg</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">fail</span><span class="p">:</span>
	<span class="n">warn_alloc</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">nodemask</span><span class="p">,</span>
			<span class="s">&#34;page allocation failure: order:%u&#34;</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
<span class="nl">got_pg</span><span class="p">:</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="4-a-namefree_pagesa_free_pages源码分析">4. <a name='free_pages'></a>_free_pages源码分析</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">__free_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// 检查并更新(-1)page-&gt;_refcount, 当page-&gt;_refcount=0时, return true
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">put_page_testzero</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>

		<span class="c1">// 如果order=0 --&gt; free_unref_page
</span><span class="c1"></span>		<span class="c1">// 如果order&gt;0 --&gt; __free_pages_ok 
</span><span class="c1"></span>		<span class="n">free_the_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="41-a-namefree_unref_pageafree_unref_page">4.1. <a name='free_unref_page'></a>free_unref_page</h3>
<ul>
<li>free_unref_page -&gt; free_unref_page_commit</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span> <span class="nf">free_unref_page_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span> <span class="o">=</span> <span class="n">page_zone</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">per_cpu_pages</span> <span class="o">*</span><span class="n">pcp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">migratetype</span><span class="p">;</span>

	<span class="c1">// 获得迁移类型
</span><span class="c1"></span>	<span class="n">migratetype</span> <span class="o">=</span> <span class="n">get_pcppage_migratetype</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">__count_vm_event</span><span class="p">(</span><span class="n">PGFREE</span><span class="p">);</span>

	<span class="c1">// pcp_list 只放置unmovable, reclaimable, movable类型page
</span><span class="c1"></span>	<span class="c1">// 大于等于MIGRATE_PCPTYPES的迁移类型中MIGRATE_ISOLATE不能被放入pcp
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">migratetype</span> <span class="o">&gt;=</span> <span class="n">MIGRATE_PCPTYPES</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_migrate_isolate</span><span class="p">(</span><span class="n">migratetype</span><span class="p">)))</span> <span class="p">{</span>

			<span class="c1">// 放入伙伴系统
</span><span class="c1"></span>			<span class="n">free_one_page</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">migratetype</span> <span class="o">=</span> <span class="n">MIGRATE_MOVABLE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pcp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">pageset</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pcp</span><span class="p">;</span>

	<span class="c1">// 将page放入pcp-&gt;lists[migratetype]链表表头
</span><span class="c1"></span>	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcp</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">[</span><span class="n">migratetype</span><span class="p">]);</span>
	<span class="n">pcp</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>

	<span class="c1">// 如果pcp-&gt;count(pcp中页数目) &gt;= pcp-&gt;high(pcp中最大页数目), 则将多余的page放入伙伴系统
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">pcp</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">pcp</span><span class="o">-&gt;</span><span class="n">high</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">batch</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">pcp</span><span class="o">-&gt;</span><span class="n">batch</span><span class="p">);</span>
		<span class="n">free_pcppages_bulk</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">pcp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="411-a-namefree_pcppages_bulkafree_pcppages_bulk">4.1.1. <a name='free_pcppages_bulk'></a>free_pcppages_bulk</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span> <span class="nf">free_pcppages_bulk</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">per_cpu_pages</span> <span class="o">*</span><span class="n">pcp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">migratetype</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">batch_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">prefetch_nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">bool</span> <span class="n">isolated_pageblocks</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">pcp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="c1">// 通过循环遍历迁移类型列表, 依次递增删除页数(batch_free)
</span><span class="c1"></span>	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">batch_free</span><span class="o">++</span><span class="p">;</span>

			<span class="c1">// 循环查询pcp-&gt;lists[migratetype]
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">migratetype</span> <span class="o">==</span> <span class="n">MIGRATE_PCPTYPES</span><span class="p">)</span>
				<span class="n">migratetype</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pcp</span><span class="o">-&gt;</span><span class="n">lists</span><span class="p">[</span><span class="n">migratetype</span><span class="p">];</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">list</span><span class="p">));</span>

		<span class="c1">// 只有一个迁移类型非空, 在这里释放全部count
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">batch_free</span> <span class="o">==</span> <span class="n">MIGRATE_PCPTYPES</span><span class="p">)</span>
			<span class="n">batch_free</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="c1">// 从列表尾部获得page
</span><span class="c1"></span>			<span class="n">page</span> <span class="o">=</span> <span class="n">list_last_entry</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
			<span class="n">pcp</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bulkfree_pcp_prepare</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="c1">// 将取出的page全部放入以head为头的链表中
</span><span class="c1"></span>			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">);</span>

			<span class="c1">// 数据预取可以加快速度
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">prefetch_nr</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">pcp</span><span class="o">-&gt;</span><span class="n">batch</span><span class="p">)</span>
				<span class="n">prefetch_buddy</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">batch_free</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">list</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">isolated_pageblocks</span> <span class="o">=</span> <span class="n">has_isolate_pageblock</span><span class="p">(</span><span class="n">zone</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 获得迁移类型
</span><span class="c1"></span>		<span class="kt">int</span> <span class="n">mt</span> <span class="o">=</span> <span class="n">get_pcppage_migratetype</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="c1">// 迁移类型不能是isolated
</span><span class="c1"></span>		<span class="n">VM_BUG_ON_PAGE</span><span class="p">(</span><span class="n">is_migrate_isolate</span><span class="p">(</span><span class="n">mt</span><span class="p">),</span> <span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">isolated_pageblocks</span><span class="p">))</span>
			<span class="n">mt</span> <span class="o">=</span> <span class="n">get_pageblock_migratetype</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="c1">// 释放page进入伙伴算法
</span><span class="c1"></span>		<span class="n">__free_one_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="n">zone</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mt</span><span class="p">);</span>
		<span class="n">trace_mm_page_pcpu_drain</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mt</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="42-a-namefree_pages_oka__free_pages_ok">4.2. <a name='free_pages_ok'></a>__free_pages_ok</h3>
<ul>
<li>__free_pages_ok -&gt; free_one_page</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span> <span class="nf">free_one_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">migratetype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="c1">// 判断zone是否存在isolate迁移类型, page是否是isolate迁移类型(一般没有这个配置)
</span><span class="c1"></span> 	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">has_isolate_pageblock</span><span class="p">(</span><span class="n">zone</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">is_migrate_isolate</span><span class="p">(</span><span class="n">migratetype</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">migratetype</span> <span class="o">=</span> <span class="n">get_pfnblock_migratetype</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">__free_one_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="421-a-namefree_one_pagea__free_one_page">4.2.1. <a name='free_one_page'></a>__free_one_page</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__free_one_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">migratetype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">combined_pfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">buddy_pfn</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">buddy</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_order</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">capture_control</span> <span class="o">*</span><span class="n">capc</span> <span class="o">=</span> <span class="n">task_capc</span><span class="p">(</span><span class="n">zone</span><span class="p">);</span>

	<span class="n">max_order</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">MAX_ORDER</span><span class="p">,</span> <span class="n">pageblock_order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">zone_is_initialized</span><span class="p">(</span><span class="n">zone</span><span class="p">));</span>
	<span class="n">VM_BUG_ON_PAGE</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PAGE_FLAGS_CHECK_AT_PREP</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">migratetype</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">is_migrate_isolate</span><span class="p">(</span><span class="n">migratetype</span><span class="p">)))</span>
		<span class="c1">// 更新zone状态
</span><span class="c1"></span>		<span class="n">__mod_zone_freepage_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>

	<span class="n">VM_BUG_ON_PAGE</span><span class="p">(</span><span class="n">pfn</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">page</span><span class="p">);</span>
	<span class="n">VM_BUG_ON_PAGE</span><span class="p">(</span><span class="n">bad_range</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">page</span><span class="p">),</span> <span class="n">page</span><span class="p">);</span>

<span class="nl">continue_merging</span><span class="p">:</span>
	<span class="c1">// 循环遍历直到order = max_order - 1
</span><span class="c1"></span>	<span class="k">while</span> <span class="p">(</span><span class="n">order</span> <span class="o">&lt;</span> <span class="n">max_order</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">compaction_capture</span><span class="p">(</span><span class="n">capc</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__mod_zone_freepage_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">),</span>
								<span class="n">migratetype</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="c1">// buddy_pfn = page_pfn ^ (1 &lt;&lt; order);
</span><span class="c1"></span>		<span class="c1">// 定位兄弟页
</span><span class="c1"></span>		<span class="n">buddy_pfn</span> <span class="o">=</span> <span class="n">__find_buddy_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>

		<span class="c1">// 获得兄弟页的struct page
</span><span class="c1"></span>		<span class="n">buddy</span> <span class="o">=</span> <span class="n">page</span> <span class="o">+</span> <span class="p">(</span><span class="n">buddy_pfn</span> <span class="o">-</span> <span class="n">pfn</span><span class="p">);</span>

		<span class="c1">// 判断buddy_pfn是否有效
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pfn_valid_within</span><span class="p">(</span><span class="n">buddy_pfn</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">done_merging</span><span class="p">;</span>

		<span class="c1">// 1. buddy_ord == order
</span><span class="c1"></span>		<span class="c1">// 2. buddy_zone == zone
</span><span class="c1"></span>		<span class="c1">// 3. buddy-&gt;_refcount == 0
</span><span class="c1"></span>		<span class="c1">// 若满足以上条件则buddy可合并
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_is_buddy</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">buddy</span><span class="p">,</span> <span class="n">order</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">done_merging</span><span class="p">;</span>

		<span class="c1">// it is CONFIG_DEBUG_PAGEALLOC guard page
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">page_is_guard</span><span class="p">(</span><span class="n">buddy</span><span class="p">))</span>
			<span class="n">clear_page_guard</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">buddy</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="c1">// 将buddy从对应free_area[order]中删除
</span><span class="c1"></span>			<span class="n">del_page_from_free_area</span><span class="p">(</span><span class="n">buddy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">free_area</span><span class="p">[</span><span class="n">order</span><span class="p">]);</span>

		<span class="c1">// 设置合并页的struct page以及pfn
</span><span class="c1"></span>		<span class="n">combined_pfn</span> <span class="o">=</span> <span class="n">buddy_pfn</span> <span class="o">&amp;</span> <span class="n">pfn</span><span class="p">;</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">page</span> <span class="o">+</span> <span class="p">(</span><span class="n">combined_pfn</span> <span class="o">-</span> <span class="n">pfn</span><span class="p">);</span>
		<span class="n">pfn</span> <span class="o">=</span> <span class="n">combined_pfn</span><span class="p">;</span>
		<span class="n">order</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_order</span> <span class="o">&lt;</span> <span class="n">MAX_ORDER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If we are here, it means order is &gt;= pageblock_order.
</span><span class="cm">		 * We want to prevent merge between freepages on isolate
</span><span class="cm">		 * pageblock and normal pageblock. Without this, pageblock
</span><span class="cm">		 * isolation could cause incorrect freepage or CMA accounting.
</span><span class="cm">		 *
</span><span class="cm">		 * We don&#39;t want to hit this code for the more frequent
</span><span class="cm">		 * low-order merging.
</span><span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">has_isolate_pageblock</span><span class="p">(</span><span class="n">zone</span><span class="p">)))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">buddy_mt</span><span class="p">;</span>

			<span class="n">buddy_pfn</span> <span class="o">=</span> <span class="n">__find_buddy_pfn</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
			<span class="n">buddy</span> <span class="o">=</span> <span class="n">page</span> <span class="o">+</span> <span class="p">(</span><span class="n">buddy_pfn</span> <span class="o">-</span> <span class="n">pfn</span><span class="p">);</span>
			<span class="n">buddy_mt</span> <span class="o">=</span> <span class="n">get_pageblock_migratetype</span><span class="p">(</span><span class="n">buddy</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">migratetype</span> <span class="o">!=</span> <span class="n">buddy_mt</span>
					<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">is_migrate_isolate</span><span class="p">(</span><span class="n">migratetype</span><span class="p">)</span> <span class="o">||</span>
						<span class="n">is_migrate_isolate</span><span class="p">(</span><span class="n">buddy_mt</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">done_merging</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">max_order</span><span class="o">++</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">continue_merging</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">done_merging</span><span class="p">:</span>
	<span class="c1">// 设置page的阶数, 将page标记为伙伴系统页
</span><span class="c1"></span>	<span class="n">set_page_order</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>

	<span class="c1">// 如果page并不是最大的page, 检查伙伴页是否是free状态的, 如果是, 但是上述步骤合并失败则有可能伙伴页正在被释放, 这时候应该把page放在zone-&gt;free_area[order]尾部(延缓page被分配出去), 这样等伙伴页释放完成后就可以一起被合并成更大的page了
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">((</span><span class="n">order</span> <span class="o">&lt;</span> <span class="n">MAX_ORDER</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">pfn_valid_within</span><span class="p">(</span><span class="n">buddy_pfn</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_shuffle_order</span><span class="p">(</span><span class="n">order</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">higher_page</span><span class="p">,</span> <span class="o">*</span><span class="n">higher_buddy</span><span class="p">;</span>
		<span class="n">combined_pfn</span> <span class="o">=</span> <span class="n">buddy_pfn</span> <span class="o">&amp;</span> <span class="n">pfn</span><span class="p">;</span>
		<span class="n">higher_page</span> <span class="o">=</span> <span class="n">page</span> <span class="o">+</span> <span class="p">(</span><span class="n">combined_pfn</span> <span class="o">-</span> <span class="n">pfn</span><span class="p">);</span>
		<span class="n">buddy_pfn</span> <span class="o">=</span> <span class="n">__find_buddy_pfn</span><span class="p">(</span><span class="n">combined_pfn</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">higher_buddy</span> <span class="o">=</span> <span class="n">higher_page</span> <span class="o">+</span> <span class="p">(</span><span class="n">buddy_pfn</span> <span class="o">-</span> <span class="n">combined_pfn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pfn_valid_within</span><span class="p">(</span><span class="n">buddy_pfn</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">page_is_buddy</span><span class="p">(</span><span class="n">higher_page</span><span class="p">,</span> <span class="n">higher_buddy</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>

			<span class="c1">// 把page置入zone-&gt;free_area[order]链表尾部
</span><span class="c1"></span>			<span class="n">add_to_free_area_tail</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">free_area</span><span class="p">[</span><span class="n">order</span><span class="p">],</span>
					      <span class="n">migratetype</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_shuffle_order</span><span class="p">(</span><span class="n">order</span><span class="p">))</span>
		<span class="c1">// 获得随机数, 随机决定放在头还是尾???
</span><span class="c1"></span>		<span class="n">add_to_free_area_random</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">free_area</span><span class="p">[</span><span class="n">order</span><span class="p">],</span>
				<span class="n">migratetype</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="c1">// 把page置入zone-&gt;free_area[order]链表头部
</span><span class="c1"></span>		<span class="n">add_to_free_area</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">free_area</span><span class="p">[</span><span class="n">order</span><span class="p">],</span> <span class="n">migratetype</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="5-a-nameslubaslub算法">5. <a name='slub'></a>slub算法</h2>
<ul>
<li>slab_debug 下的object:
<ul>
<li>kmem_cache缓冲区建立后, 所有内存空间用POISON_INUSE(0X5a)填充</li>
<li>object被释放后用POISON_FREE(0X6b)填充</li>
<li>read_left_pad, red_zone用特殊字节填充, 用作magic_num</li>
</ul>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../mm/obj.png"
        data-srcset="../../mm/obj.png, ../../mm/obj.png 1.5x, ../../mm/obj.png 2x"
        data-sizes="auto"
        alt="../../mm/obj.png"
        title="obj" /></p>
<ul>
<li>kmem_cache_alloc概略图</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../mm/kmem_cache_alloc.png"
        data-srcset="../../mm/kmem_cache_alloc.png, ../../mm/kmem_cache_alloc.png 1.5x, ../../mm/kmem_cache_alloc.png 2x"
        data-sizes="auto"
        alt="../../mm/kmem_cache_alloc.png"
        title="kmem_cache_alloc" /></p>
<ul>
<li>kmem_cache_free概略图</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../mm/kmem_cache_free.png"
        data-srcset="../../mm/kmem_cache_free.png, ../../mm/kmem_cache_free.png 1.5x, ../../mm/kmem_cache_free.png 2x"
        data-sizes="auto"
        alt="../../mm/kmem_cache_free.png"
        title="kmem_cache_free" /></p>
<h3 id="51-a-name-1a结构体解析">5.1. <a name='-1'></a>结构体解析</h3>
<ul>
<li>kmem_cache结构体</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">cpu_slab</span><span class="p">;</span>		<span class="c1">// per cpu变量, cpu本地内存缓存池, 存储slab
</span><span class="c1"></span>	<span class="n">slab_flags_t</span> <span class="n">flags</span><span class="p">;</span>								<span class="c1">// object分配掩码	
</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min_partial</span><span class="p">;</span>						<span class="c1">// kmem_cache_node中的partial链表slab的数量上限, 超过限度多余的slab会被释放
</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>								<span class="c1">// 被分配的object真实大小
</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">object_size</span><span class="p">;</span>						<span class="c1">// 用户申请的obj_size
</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>							<span class="c1">// slub将要被分配出去的obj中存储下一个空闲obj指针(next_obj), 而存储这个空闲obj指针的地址就用obj-&gt;offset来表示
</span><span class="c1"></span><span class="cp">#ifdef CONFIG_SLUB_CPU_PARTIAL
</span><span class="cp"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu_partial</span><span class="p">;</span>						<span class="c1">// 如果cpu_slab中存在partial链表, 那么该值将作为partial链表数量上限, 超过上限后全部slab将被转移到kmem_cache_node中的partial链表
</span><span class="c1"></span><span class="cp">#endif
</span><span class="cp"></span>	<span class="k">struct</span> <span class="n">kmem_cache_order_objects</span> <span class="n">oo</span><span class="p">;</span>				<span class="c1">// 低16位代表一个slab中所有object的数量(oo &amp; ((1 &lt;&lt; 16) - 1)), 高16位代表一个slab管理的page数量((2^(oo  16)) pages)
</span><span class="c1"></span>	<span class="k">struct</span> <span class="n">kmem_cache_order_objects</span> <span class="n">max</span><span class="p">;</span>			<span class="c1">// max=oo, 表示最大分配量
</span><span class="c1"></span>	<span class="k">struct</span> <span class="n">kmem_cache_order_objects</span> <span class="n">min</span><span class="p">;</span>			<span class="c1">// min功能与oo, max相同, 表示最小分配量
</span><span class="c1"></span>	<span class="n">gfp_t</span> <span class="n">allocflags</span><span class="p">;</span>								<span class="c1">// 从伙伴系统继承的内存掩码
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">refcount</span><span class="p">;</span>									<span class="c1">// 重用计数器, 当用户请求创建的slub分配器大小与已经创建的slub分配器相似时, 计数+1, 进行slub重用
</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">inuse</span><span class="p">;</span>								<span class="c1">// 元数据偏移量
</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">align</span><span class="p">;</span>								<span class="c1">// 字节对齐大小			
</span><span class="c1"></span>	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>								<span class="c1">// sysfs文件系统显示使用
</span><span class="c1"></span>	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>							<span class="c1">// 挂载所有的slab
</span><span class="c1"></span>
	<span class="p">...</span>

	<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">node</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>		<span class="c1">// slab节点
</span><span class="c1"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>kmem_cache_cpu结构体</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">freelist</span><span class="p">;</span>								<span class="c1">// 指向下一个可用空闲obj
</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tid</span><span class="p">;</span>								<span class="c1">// 相当于cpu的标识, 用于辨别cpu是否被抢占, 用于同步
</span><span class="c1"></span>	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>								<span class="c1">// 当前正在被分配的slab
</span><span class="c1"></span><span class="cp">#ifdef CONFIG_SLUB_CPU_PARTIAL
</span><span class="cp"></span>	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">partial</span><span class="p">;</span>							<span class="c1">// 指向曾分配完所有的obj，但当前已回收至少一个对象的slab
</span><span class="c1"></span><span class="cp">#endif
</span><span class="cp"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>kmem_cache_node结构体</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="n">list_lock</span><span class="p">;</span>							<span class="c1">// 保护node资源的自旋锁
</span><span class="c1"></span><span class="cp">#ifdef CONFIG_SLUB
</span><span class="cp"></span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_partial</span><span class="p">;</span>						<span class="c1">// 本结点partial_slab数目
</span><span class="c1"></span>	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">partial</span><span class="p">;</span>						<span class="c1">// partial_slab链表
</span><span class="c1"></span><span class="cp">#endif
</span><span class="cp"></span><span class="p">};</span>

</code></pre></td></tr></table>
</div>
</div><h2 id="6-a-namekmem_cache_allocakmem_cache_alloc源码分析">6. <a name='kmem_cache_alloc'></a>kmem_cache_alloc源码分析</h2>
<ul>
<li>kmem_cache_alloc() -&gt; slab_alloc() -&gt; slab_alloc_node()</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">slab_alloc_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
		<span class="n">gfp_t</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tid</span><span class="p">;</span>

	<span class="c1">// 对keme_cache做预处理
</span><span class="c1"></span>	<span class="n">s</span> <span class="o">=</span> <span class="n">slab_pre_alloc_hook</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">redo</span><span class="p">:</span>
	<span class="c1">// tid, c是通过两次读取cpu获得, 如果抢占模式被开启, 有可能两次获取的cpu不同, 这里每次读取tid和c之后都会比较tid是否等于c-&gt;tid, 如果不相等, 则说明两次数据读取对应的cpu不同, 则再次读取数据, 直至相同(构造的很精巧, 比关闭抢占提升了效率) 
</span><span class="c1"></span>	<span class="k">do</span> <span class="p">{</span>
		<span class="n">tid</span> <span class="o">=</span> <span class="n">this_cpu_read</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">);</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">raw_cpu_ptr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_PREEMPT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		 <span class="n">unlikely</span><span class="p">(</span><span class="n">tid</span> <span class="o">!=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">)));</span>

	<span class="c1">// 屏障, 保证上面和下面的代码因为优化而相互影响
</span><span class="c1"></span>	<span class="n">barrier</span><span class="p">();</span>
	<span class="n">object</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">;</span>

	<span class="c1">// 如果当前cpu的空闲列表为空或当前正在使用的页为空或page-&gt;node与node不匹配则进入__slab_alloc慢分配
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">object</span> <span class="o">||</span> <span class="o">!</span><span class="n">page</span> <span class="o">||</span> <span class="o">!</span><span class="n">node_match</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">node</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">object</span> <span class="o">=</span> <span class="n">__slab_alloc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
		<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ALLOC_SLOWPATH</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// freepointer_addr = (unsigned long)object + s-&gt;offset;
</span><span class="c1"></span>		<span class="c1">// probe_kernel_read(&amp;p, (void **)freepointer_addr, sizeof(p));
</span><span class="c1"></span>		<span class="c1">// return freelist_ptr(s, p, freepointer_addr);
</span><span class="c1"></span>		<span class="c1">// get_freepointer_safe: 通过s-&gt;offset偏移获得存储下一个空闲obj的地址, 然后使用probe_kernel_read安全的将obj地址写入p中, freelist_ptr在没有定义CONFIG_SLAB_FREELIST_HARDENED时直接返回p
</span><span class="c1"></span>		<span class="kt">void</span> <span class="o">*</span><span class="n">next_object</span> <span class="o">=</span> <span class="n">get_freepointer_safe</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>

		<span class="c1">// 判断this_cpu(s-&gt;cpu_slab-&gt;freelist)是否等于object且this_cpu(s-&gt;cpu_slab-&gt;tid)是否等于tid, 如果成立则this_cpu(s-&gt;cpu_slab-&gt;freelist)=next_object, this_cpu(s-&gt;cpu_slab-&gt;tid)=tid+1, 否则return false
</span><span class="c1"></span>		<span class="c1">// this_cpu_cmpxchg_double将上诉操作变成原子操作
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">this_cpu_cmpxchg_double</span><span class="p">(</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">,</span>
				<span class="n">object</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span>
				<span class="n">next_object</span><span class="p">,</span> <span class="n">next_tid</span><span class="p">(</span><span class="n">tid</span><span class="p">))))</span> <span class="p">{</span>

			<span class="c1">// 如果失败则重新获取obj
</span><span class="c1"></span>			<span class="n">note_cmpxchg_failure</span><span class="p">(</span><span class="s">&#34;slab_alloc&#34;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">redo</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="c1">// 预热链表, 增加下次命中几率
</span><span class="c1"></span>		<span class="n">prefetch_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">next_object</span><span class="p">);</span>

		<span class="c1">// 记录状态
</span><span class="c1"></span>		<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ALLOC_FASTPATH</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">maybe_wipe_obj_freeptr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">slab_want_init_on_alloc</span><span class="p">(</span><span class="n">gfpflags</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">object</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">object_size</span><span class="p">);</span>

	<span class="c1">// 分析了以下这里kasan_slab_alloc直接返回原值, kmemleak_alloc_recursive为空, 如果slab开始分配时memcg_kmem_enabled有意义, 这里再做一下后续的扫尾工作(因为是hook函数所以初始功能极少)
</span><span class="c1"></span>	<span class="n">slab_post_alloc_hook</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">object</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="61-a-nameslab_alloca__slab_alloc">6.1. <a name='slab_alloc'></a>__slab_alloc</h3>
<ul>
<li>__slab_alloc -&gt; ___slab_alloc</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">___slab_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">freelist</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="c1">// 如果c-&gt;page为空, 代表cpu_slab中没有可用slab, 进入new_slab向cpu_slab中填充可用slab
</span><span class="c1"></span>	<span class="n">page</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 如果node不在线或者node没有正常内存, 则忽略node约束
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="n">NUMA_NO_NODE</span> <span class="o">&amp;&amp;</span>
			     <span class="o">!</span><span class="n">node_state</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">N_NORMAL_MEMORY</span><span class="p">)))</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">NUMA_NO_NODE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">new_slab</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">redo</span><span class="p">:</span>
	<span class="c1">// 判断page-&gt;node与node是否相同
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">node_match</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">node</span><span class="p">)))</span> <span class="p">{</span>
		<span class="c1">// node_state: return 0
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_state</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">N_NORMAL_MEMORY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">NUMA_NO_NODE</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">redo</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// 记录状态node_miss_match
</span><span class="c1"></span>			<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ALLOC_NODE_MISMATCH</span><span class="p">);</span>

			<span class="c1">// 将cpu_slab中的page放入node中
</span><span class="c1"></span>			<span class="n">deactivate_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">new_slab</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// PF_MEMALLOC: 忽略内存管理的水印进行分配, 分配失败则不再尝试, 如果当前page是pfmemalloc属性, 则调用deactivate_slab
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pfmemalloc_match</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">deactivate_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">new_slab</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// 检查freelist, 防止cpu迁移或中断导致freelist非空
</span><span class="c1"></span>	<span class="n">freelist</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">freelist</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">load_freelist</span><span class="p">;</span>

	<span class="c1">// 从c-&gt;page中获得freelist
</span><span class="c1"></span>	<span class="n">freelist</span> <span class="o">=</span> <span class="n">get_freelist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">freelist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">DEACTIVATE_BYPASS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">new_slab</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ALLOC_REFILL</span><span class="p">);</span>

<span class="nl">load_freelist</span><span class="p">:</span>

	<span class="c1">// c-&gt;page对应被分配的obj所在的page, 应该被cpu冻结
</span><span class="c1"></span>	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">frozen</span><span class="p">);</span>

	<span class="c1">// 更新cpu_slab的freelist, tid
</span><span class="c1"></span>	<span class="n">c</span><span class="o">-&gt;</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">get_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">freelist</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">=</span> <span class="n">next_tid</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">freelist</span><span class="p">;</span>

<span class="nl">new_slab</span><span class="p">:</span>
	<span class="c1">// 判断cpu_slab是否存在partial_slab(部分空间被使用的page)
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">slub_percpu_partial</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
		<span class="c1">// 将partial_slab作为c-&gt;page(用来分配obj)
</span><span class="c1"></span>		<span class="n">page</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">slub_percpu_partial</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

		<span class="c1">// #define slub_set_percpu_partial(c, p) (slub_percpu_partial(c) = (p)-&gt;next;})
</span><span class="c1"></span>		<span class="c1">// 更新partial链表头为page-&gt;next
</span><span class="c1"></span>		<span class="n">slub_set_percpu_partial</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">CPU_PARTIAL_ALLOC</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">redo</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// new_slab_objects: 1. get_partial(从node-&gt;partial获取page) 2. new_slab(伙伴算法获取page)
</span><span class="c1"></span>	<span class="c1">// 从上述page中获得freelist
</span><span class="c1"></span>	<span class="n">freelist</span> <span class="o">=</span> <span class="n">new_slab_objects</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">freelist</span><span class="p">))</span> <span class="p">{</span>
		<span class="c1">// 内存分配失败
</span><span class="c1"></span>		<span class="c1">// 配置CONFIG_SLUB_DEBUG后会打印报错信息
</span><span class="c1"></span>		<span class="n">slab_out_of_memory</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">kmem_cache_debug</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">pfmemalloc_match</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">load_freelist</span><span class="p">;</span>

	<span class="c1">// kmem_cache_debug判断kmem_cache标志位是否包含SLAB_DEBUG_FLAGS
</span><span class="c1"></span>	<span class="c1">// alloc_debug_processing: return 0
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">kmem_cache_debug</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">alloc_debug_processing</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">freelist</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">new_slab</span><span class="p">;</span>

	<span class="n">deactivate_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">get_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">freelist</span><span class="p">),</span> <span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">freelist</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="611-a-nameget_freelistaget_freelist">6.1.1. <a name='get_freelist'></a>get_freelist</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">get_freelist</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="n">new</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">counters</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">freelist</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">freelist</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
		<span class="n">counters</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">;</span>

		<span class="c1">// 获得下一个freelist
</span><span class="c1"></span>		<span class="n">new</span><span class="p">.</span><span class="n">counters</span> <span class="o">=</span> <span class="n">counters</span><span class="p">;</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">.</span><span class="n">frozen</span><span class="p">);</span>

		<span class="n">new</span><span class="p">.</span><span class="n">inuse</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">;</span>
		<span class="c1">// The page is still frozen if the return value is not NULL.
</span><span class="c1"></span>		<span class="n">new</span><span class="p">.</span><span class="n">frozen</span> <span class="o">=</span> <span class="n">freelist</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="c1">// page-&gt;freelist=NULL, page-&gt;counters=new.counters
</span><span class="c1"></span>		<span class="c1">// 将page-&gt;freelist从page中摘除, 后续会放进cpu_slab-&gt;freelist中
</span><span class="c1"></span>	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">__cmpxchg_double_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
		<span class="n">freelist</span><span class="p">,</span> <span class="n">counters</span><span class="p">,</span>
		<span class="nb">NULL</span><span class="p">,</span> <span class="n">new</span><span class="p">.</span><span class="n">counters</span><span class="p">,</span>
		<span class="s">&#34;get_freelist&#34;</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">freelist</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="7-a-namekmem_cache_freeakmem_cache_free源码分析">7. <a name='kmem_cache_free'></a>kmem_cache_free源码分析</h2>
<ol>
<li>kmem_cache_free -&gt; cache_from_obj(定位目标kmem_cache)</li>
<li>kmem_cache_free -&gt; slab_free</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">slab_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">tail</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slab_free_freelist_hook</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tail</span><span class="p">))</span>
		<span class="n">do_slab_free</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>slab_free -&gt; slab_free_freelist_hook</li>
<li>slab_free -&gt; do_slab_free</li>
</ul>
<h3 id="71-a-namecache_from_objacache_from_obj">7.1. <a name='cache_from_obj'></a>cache_from_obj</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="nf">cache_from_obj</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">;</span>
	<span class="c1">// 如果memcg没有开启且没有配置CONFIG_SLAB_FREELIST_HARDENED,kem_cache没有配置SLAB_CONSISTENCY_CHECKS, 则直接返回用户选择的kmem_cache
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcg_kmem_enabled</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_SLAB_FREELIST_HARDENED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">unlikely</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_CONSISTENCY_CHECKS</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">s</span><span class="p">;</span>

	<span class="c1">// virt_to_cache -&gt; virt_to_head_page -&gt; virt_to_page获得page
</span><span class="c1"></span>	<span class="c1">// 返回page-&gt;slab_cache作为kmem_cache(因为用户选择的kmem_cache不可信)
</span><span class="c1"></span>	<span class="n">cachep</span> <span class="o">=</span> <span class="n">virt_to_cache</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">cachep</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">slab_equal_or_root</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span>
		  <span class="s">&#34;%s: Wrong slab cache. %s but object is from %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
		  <span class="n">__func__</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cachep</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="72-a-nameslab_free_freelist_hookaslab_free_freelist_hook">7.2. <a name='slab_free_freelist_hook'></a>slab_free_freelist_hook</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">slab_free_freelist_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
					   <span class="kt">void</span> <span class="o">**</span><span class="n">head</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">tail</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">old_tail</span> <span class="o">=</span> <span class="o">*</span><span class="n">tail</span> <span class="o">?</span> <span class="o">*</span><span class="nl">tail</span> <span class="p">:</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rsize</span><span class="p">;</span>

	<span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="o">*</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="c1">// 依次遍历freelist
</span><span class="c1"></span>		<span class="n">object</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">get_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">slab_want_init_on_free</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
			<span class="c1">// 将object清空(red_zone区域除外)
</span><span class="c1"></span>			<span class="n">memset</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">object_size</span><span class="p">);</span>
			<span class="n">rsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RED_ZONE</span><span class="p">)</span> <span class="o">?</span> <span class="n">s</span><span class="o">-&gt;</span><span class="nl">red_left_pad</span>
							   <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			       <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">-</span> <span class="n">rsize</span><span class="p">);</span>

		<span class="p">}</span>
		<span class="c1">// slab_free_hook内部功能函数实现为空 return false
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slab_free_hook</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">))</span> <span class="p">{</span>
			<span class="c1">// *object-&gt;offset=*head
</span><span class="c1"></span>			<span class="n">set_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
			<span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">object</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">tail</span><span class="p">)</span>
				<span class="o">*</span><span class="n">tail</span> <span class="o">=</span> <span class="n">object</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">object</span> <span class="o">!=</span> <span class="n">old_tail</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">head</span> <span class="o">==</span> <span class="o">*</span><span class="n">tail</span><span class="p">)</span>
		<span class="o">*</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">*</span><span class="n">head</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="73-a-namedo_slab_freeado_slab_free">7.3. <a name='do_slab_free'></a>do_slab_free</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">do_slab_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">tail</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">cnt</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">tail_obj</span> <span class="o">=</span> <span class="n">tail</span> <span class="o">?</span> <span class="o">:</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tid</span><span class="p">;</span>
<span class="nl">redo</span><span class="p">:</span>

	<span class="c1">// 使用tid保持cpu同步
</span><span class="c1"></span>	<span class="k">do</span> <span class="p">{</span>
		<span class="n">tid</span> <span class="o">=</span> <span class="n">this_cpu_read</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">);</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">raw_cpu_ptr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_PREEMPT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		 <span class="n">unlikely</span><span class="p">(</span><span class="n">tid</span> <span class="o">!=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">)));</span>

	<span class="c1">// 和slab_alloc_node()中的barrier作用相同
</span><span class="c1"></span>	<span class="n">barrier</span><span class="p">();</span>

	<span class="c1">// 如果待释放obj所属的page并不是cpu_slab对应的page则进入__slab_free慢释放
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">**</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">);</span>

		<span class="c1">// tail_obj是待插入的obj, set_freepointer: *(tail_obj-&gt;offset)=freelist(原freelist)
</span><span class="c1"></span>		<span class="n">set_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">tail_obj</span><span class="p">,</span> <span class="n">freelist</span><span class="p">);</span>

		<span class="c1">// 验证cpu没有被抢占后, 使得s-&gt;cpu_slab-&gt;freelist=head(tail_obj), tid=next_tid(tid), tail_obj成功插入
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">this_cpu_cmpxchg_double</span><span class="p">(</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">,</span>
				<span class="n">freelist</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span>
				<span class="n">head</span><span class="p">,</span> <span class="n">next_tid</span><span class="p">(</span><span class="n">tid</span><span class="p">))))</span> <span class="p">{</span>

			<span class="n">note_cmpxchg_failure</span><span class="p">(</span><span class="s">&#34;slab_free&#34;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">redo</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_FASTPATH</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">__slab_free</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">tail_obj</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="731-a-nameslab_freea__slab_free">7.3.1. <a name='slab_free'></a>__slab_free</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span> <span class="nf">__slab_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">tail</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>

<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">prior</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">was_frozen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="n">new</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">counters</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="c1">// uninitialized_var消除没有初始化的警告
</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_SLOWPATH</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kmem_cache_debug</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">free_debug_processing</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="c1">// n置空, 释放free_debug_processing()设置的自旋锁
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">n</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">prior</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
		<span class="n">counters</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">;</span>

		<span class="c1">// tail是待插入的obj, set_freepointer: *(tail_obj-&gt;offset)=freelist(原freelist)
</span><span class="c1"></span>		<span class="n">set_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">prior</span><span class="p">);</span>
		<span class="n">new</span><span class="p">.</span><span class="n">counters</span> <span class="o">=</span> <span class="n">counters</span><span class="p">;</span>
		<span class="n">was_frozen</span> <span class="o">=</span> <span class="n">new</span><span class="p">.</span><span class="n">frozen</span><span class="p">;</span>

		<span class="c1">// inuse_obj = inuse_obj - cnt, 当前page释放了cnt(1)个obj
</span><span class="c1"></span>		<span class="n">new</span><span class="p">.</span><span class="n">inuse</span> <span class="o">-=</span> <span class="n">cnt</span><span class="p">;</span>

		<span class="c1">// 如果该page(不存在正被使用的obj或者无可被使用的obj)且没有被冻结(不属于cpu_slab), 说明正在被释放的obj是该page的最后一个被使用的obj, 该page可被放入buddy
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">new</span><span class="p">.</span><span class="n">inuse</span> <span class="o">||</span> <span class="o">!</span><span class="n">prior</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">was_frozen</span><span class="p">)</span> <span class="p">{</span>

			<span class="c1">// 如果kmem_cache存在cpu_slab-&gt;partial且该page无可用obj则冻结page, 后续会被放入cpu_slab-&gt;partial
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">kmem_cache_has_cpu_partial</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">prior</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">new</span><span class="p">.</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="c1">// 获得node, 加锁node资源区
</span><span class="c1"></span>				<span class="n">n</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="p">}</span>
		<span class="p">}</span>
	<span class="c1">// 释放head(正在被释放的obj)进入page(page-&gt;freelist=head, page-&gt;counters=new.counters)
</span><span class="c1"></span>	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cmpxchg_double_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
		<span class="n">prior</span><span class="p">,</span> <span class="n">counters</span><span class="p">,</span>
		<span class="n">head</span><span class="p">,</span> <span class="n">new</span><span class="p">.</span><span class="n">counters</span><span class="p">,</span>
		<span class="s">&#34;__slab_free&#34;</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>

		<span class="c1">// 如果page没有被冻结, 则将page挂载进入cpu_slab-&gt;partial
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">.</span><span class="n">frozen</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">was_frozen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">put_cpu_partial</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">CPU_PARTIAL_FREE</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="c1">// page被冻结后只更新&#34;FREE_FROZEN&#34;信息
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">was_frozen</span><span class="p">)</span>
			<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_FROZEN</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// 如果page无obj被使用, 且kmem_cache的半满page超过临界点(n-&gt;nr_partial &gt;= s-&gt;min_partial), 则进行page释放
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">.</span><span class="n">inuse</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_partial</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">min_partial</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">slab_empty</span><span class="p">;</span>

	<span class="c1">// 释放obj后slab从full变为partial
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kmem_cache_has_cpu_partial</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">prior</span><span class="p">))</span> <span class="p">{</span>
		<span class="c1">// 将slab从full链表删除, 插入n-&gt;partial链表尾部
</span><span class="c1"></span>		<span class="n">remove_full</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">add_partial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">DEACTIVATE_TO_TAIL</span><span class="p">);</span>
		<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_ADD_PARTIAL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="c1">// 解锁node资源区
</span><span class="c1"></span>	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">slab_empty</span><span class="p">:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prior</span><span class="p">)</span> <span class="p">{</span>

		<span class="c1">// 如果该page存在可用obj, 则该page会在partial链表, 所以在partial链表中将page删除
</span><span class="c1"></span>		<span class="n">remove_partial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_REMOVE_PARTIAL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 将page从full链表中删除
</span><span class="c1"></span>		<span class="n">remove_full</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_SLAB</span><span class="p">);</span>
	<span class="n">discard_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="discard_slab">discard_slab</h5>
<ol>
<li>discard_slab-&gt;dec_slabs_node(更新node信息)</li>
<li>discard_slab-&gt;free_slab-&gt;__free_slab</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span> <span class="nf">__free_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// 获得page_order
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">order</span> <span class="o">=</span> <span class="n">compound_order</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">pages</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_CONSISTENCY_CHECKS</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

		<span class="c1">// 对page做安全检查 
</span><span class="c1"></span>		<span class="n">slab_pad_check</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

		<span class="c1">// 对page中的每个obj进行安全检测
</span><span class="c1"></span>		<span class="n">for_each_object</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">),</span>
						<span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">)</span>
			<span class="n">check_object</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">SLUB_RED_INACTIVE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// 清除page标志位
</span><span class="c1"></span>	<span class="n">__ClearPageSlabPfmemalloc</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">__ClearPageSlab</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="c1">// page不再被引用
</span><span class="c1"></span>	<span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="c1">// 更新内存回收状态
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">reclaim_state</span><span class="p">)</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">reclaim_state</span><span class="o">-&gt;</span><span class="n">reclaimed_slab</span> <span class="o">+=</span> <span class="n">pages</span><span class="p">;</span>

	<span class="c1">// 更新系统状态
</span><span class="c1"></span>	<span class="n">uncharge_slab_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>

	<span class="c1">// 伙伴算法释放内存
</span><span class="c1"></span>	<span class="n">__free_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h6 id="slab_pad_check">slab_pad_check</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 当slab_debug开启后, kmem_cache建立时, 内存空间全部被覆写成0x5a, 一个slab被切割成obj时有可能不能被完全利用, 可能会剩余一些空间(padding), 又因为padding区域在内存分配期间不会被修改, 所以应该一直是0x5a, 本函数通过对0x5a进行检测, 试图发现溢出覆写错误
</span><span class="c1"></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">slab_pad_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">start</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">fault</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">pad</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">remainder</span><span class="p">;</span>

	<span class="c1">// 如果kmem_cache没有配置SLAB_POISON则直接返回
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_POISON</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">page_size</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">length</span><span class="p">;</span>

	<span class="c1">// 获得切割obj后slab的剩余空间
</span><span class="c1"></span>	<span class="n">remainder</span> <span class="o">=</span> <span class="n">length</span> <span class="o">%</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">remainder</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pad</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">remainder</span><span class="p">;</span>
	<span class="n">metadata_access_enable</span><span class="p">();</span>

	<span class="c1">// 访问元数据查看POISON_INUSE magic是否被修改, 定位错误的起始位置
</span><span class="c1"></span>	<span class="n">fault</span> <span class="o">=</span> <span class="n">memchr_inv</span><span class="p">(</span><span class="n">pad</span><span class="p">,</span> <span class="n">POISON_INUSE</span><span class="p">,</span> <span class="n">remainder</span><span class="p">);</span>
	<span class="n">metadata_access_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fault</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="c1">// 定位数据覆盖的结尾
</span><span class="c1"></span>	<span class="k">while</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">fault</span> <span class="o">&amp;&amp;</span> <span class="n">end</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">POISON_INUSE</span><span class="p">)</span>
		<span class="n">end</span><span class="o">--</span><span class="p">;</span>

	<span class="c1">// 抛出错误, 打印错误覆盖区间
</span><span class="c1"></span>	<span class="n">slab_err</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="s">&#34;Padding overwritten. 0x%p-0x%p&#34;</span><span class="p">,</span> <span class="n">fault</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">print_section</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&#34;Padding &#34;</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">remainder</span><span class="p">);</span>

	<span class="n">restore_bytes</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&#34;slab padding&#34;</span><span class="p">,</span> <span class="n">POISON_INUSE</span><span class="p">,</span> <span class="n">fault</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h6 id="check_object">check_object</h6>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 讲解slub算法的开头, 列出了有关slab_debug所用到的magic_num以及obj内存布局, 本函数对magic_num和freelist进行安全检测
</span><span class="c1"></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">check_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">object</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">endobject</span> <span class="o">=</span> <span class="n">object</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">object_size</span><span class="p">;</span>

	<span class="c1">// 如果kmem_cache区域配置了SLAB_RED_ZONE, 则对相应的magic_num进行检测
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RED_ZONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 检测red_left_pad
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_bytes_and_report</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="s">&#34;Redzone&#34;</span><span class="p">,</span>
			<span class="n">object</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">red_left_pad</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">red_left_pad</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="c1">// 检测Redzone
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_bytes_and_report</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="s">&#34;Redzone&#34;</span><span class="p">,</span>
			<span class="n">endobject</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">object_size</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_POISON</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">object_size</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 检测padding区域
</span><span class="c1"></span>			<span class="n">check_bytes_and_report</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="s">&#34;Alignment padding&#34;</span><span class="p">,</span>
				<span class="n">endobject</span><span class="p">,</span> <span class="n">POISON_INUSE</span><span class="p">,</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">object_size</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_POISON</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="n">SLUB_RED_ACTIVE</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">__OBJECT_POISON</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="c1">// 检测obj是否早已被free检测obj[-1]是否为POISON_END(0xa5)
</span><span class="c1"></span>			<span class="p">(</span><span class="o">!</span><span class="n">check_bytes_and_report</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="s">&#34;Poison&#34;</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
					<span class="n">POISON_FREE</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">object_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
			 <span class="o">!</span><span class="n">check_bytes_and_report</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="s">&#34;Poison&#34;</span><span class="p">,</span>
				<span class="n">p</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">object_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">POISON_END</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">check_pad_bytes</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">freeptr_outside_object</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">==</span> <span class="n">SLUB_RED_ACTIVE</span><span class="p">)</span>
		<span class="cm">/*
</span><span class="cm">		 * Object and freepointer overlap. Cannot check
</span><span class="cm">		 * freepointer while object is allocated.
</span><span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="c1">// 检查freelist是否有效
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_valid_pointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">get_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">object_err</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="s">&#34;Freepointer corrupt&#34;</span><span class="p">);</span>

		<span class="c1">// 如果无效则丢弃该freelist链后续object
</span><span class="c1"></span>		<span class="n">set_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="8-a-namevmaa进程vma">8. <a name='vma'></a>进程vma</h2>
<ul>
<li>
<p>进程由许多的segment组成, 例如text segment,data segment, bss segment等, segment中被填充各种功能的数据, 每个segment具有不同的权限(r, w, x)</p>
</li>
<li>
<p>对于进程来说segment由什么结构来标识? 这就是接下来要将的进程vma</p>
</li>
</ul>
<h3 id="81-a-namevm_area_structavm_area_struct-结构体">8.1. <a name='vm_area_struct'></a>vm_area_struct 结构体</h3>
<ul>
<li>
<p>在进程中每个segment都被描述为vm_area_struct</p>
</li>
<li>
<p>task_struct -&gt; mm_struct -&gt; vm_area_struct</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="p">{</span>
	<span class="c1">// 第一个cache line
</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_start</span><span class="p">;</span>		
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_end</span><span class="p">;</span>						<span class="c1">// vm_area_struct所对应的vma在进程地址空间中的起始和结束地址
</span><span class="c1"></span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vm_next</span><span class="p">,</span> <span class="o">*</span><span class="n">vm_prev</span><span class="p">;</span>	<span class="c1">// 按照vma在进程地址空间中的顺序, 将vma链入双链表,
</span><span class="c1"></span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">vm_rb</span><span class="p">;</span>						<span class="c1">// 红黑树结点
</span><span class="c1"></span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rb_subtree_gap</span><span class="p">;</span>				<span class="c1">// 记录该vma与上一个vma(可以选择双链表中或者红黑树中)之间的空闲空间大小, 
</span><span class="c1"></span>
	<span class="c1">// 第二个cache line
</span><span class="c1"></span>	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">vm_mm</span><span class="p">;</span>					<span class="c1">// 指向该vma对应的进程的mm_struct结构体
</span><span class="c1"></span>	<span class="n">pgprot_t</span> <span class="n">vm_page_prot</span><span class="p">;</span>						<span class="c1">// 该vma访问权限
</span><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_flags</span><span class="p">;</span>						<span class="c1">// 描述该vma标志位
</span><span class="c1"></span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="o">*</span><span class="n">vm_ops</span><span class="p">;</span>	<span class="c1">// 指向function集合, 虚表
</span><span class="c1"></span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_pgoff</span><span class="p">;</span>						<span class="c1">// 以page为单位的文件映射偏移量
</span><span class="c1"></span>	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">vm_file</span><span class="p">;</span>						<span class="c1">// 指向被映射的文件
</span><span class="c1"></span>
	<span class="p">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="82-a-namefind_vmavmaafind_vmavma查找">8.2. <a name='find_vmavma'></a>find_vma(vma查找)</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="nf">find_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

	<span class="c1">// 在cache中寻找vma
</span><span class="c1"></span>	<span class="n">vma</span> <span class="o">=</span> <span class="n">vmacache_find</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">vma</span><span class="p">;</span>

	<span class="c1">// 定位红黑树根节点
</span><span class="c1"></span>	<span class="n">rb_node</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_rb</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>

	<span class="c1">// 在红黑树中查找vma
</span><span class="c1"></span>	<span class="k">while</span> <span class="p">(</span><span class="n">rb_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

		<span class="c1">// 获得当前结点的vm_area_struct
</span><span class="c1"></span>		<span class="n">tmp</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">rb_node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span><span class="p">,</span> <span class="n">vm_rb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&gt;</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vma</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;=</span> <span class="n">addr</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">rb_node</span> <span class="o">=</span> <span class="n">rb_node</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">rb_node</span> <span class="o">=</span> <span class="n">rb_node</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// 如果查找到的vma有效, 则更新cache
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span>
		<span class="n">vmacache_update</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">vma</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="821-a-namevmacache_findavmacache_find">8.2.1. <a name='vmacache_find'></a>vmacache_find</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="nf">vmacache_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// 通过左移addr, 定位addr对应的index(这个位置可能会存在对应的vma)
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">VMACACHE_HASH</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="c1">// 记录事件
</span><span class="c1"></span>	<span class="n">count_vm_vmacache_event</span><span class="p">(</span><span class="n">VMACACHE_FIND_CALLS</span><span class="p">);</span>

	<span class="c1">// 检测mm是否是当前进程的mm_struct, 如果是第一次触发cache, 将进行初始化
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmacache_valid</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="c1">// 遍历current-&gt;vmacache.vmas[](从idx开始, 因为inx对应的位置cache hit可能性最大)
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">VMACACHE_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">vmacache</span><span class="p">.</span><span class="n">vmas</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_DEBUG_VM_VMACACHE
</span><span class="cp"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span> <span class="o">!=</span> <span class="n">mm</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="cp"></span>			<span class="c1">// 判断vma是否匹配
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;=</span> <span class="n">addr</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&gt;</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">count_vm_vmacache_event</span><span class="p">(</span><span class="n">VMACACHE_FIND_HITS</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">vma</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="c1">// inx遍历到VMACACHE_SIZE后, 归0继续遍历(idx是从中间开始遍历的)
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">idx</span> <span class="o">==</span> <span class="n">VMACACHE_SIZE</span><span class="p">)</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="83-a-nameinsert_vm_structvmaainsert_vm_structvma插入">8.3. <a name='insert_vm_structvma'></a>insert_vm_struct(vma插入)</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">insert_vm_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">rb_link</span><span class="p">,</span> <span class="o">*</span><span class="n">rb_parent</span><span class="p">;</span>

	<span class="c1">// 定位插入vma的目标位置
</span><span class="c1"></span>	<span class="c1">// prev = rb_parent对应的vm_area_struct
</span><span class="c1"></span>	<span class="c1">// rb_link = 待插入的位置
</span><span class="c1"></span>	<span class="c1">// rb_parent = rb_link的父结点
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">find_vma_links</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">prev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rb_link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rb_parent</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_ACCOUNT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="n">security_vm_enough_memory_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma_pages</span><span class="p">(</span><span class="n">vma</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="c1">// 匿名vma要设置页偏移
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">vma_is_anonymous</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">);</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// 将vma插入vma管理体系
</span><span class="c1"></span>	<span class="c1">// vma_link -&gt; __vma_link -&gt; __vma_link_list, 将vma插入双链表
</span><span class="c1"></span>	<span class="c1">// vma_link -&gt; __vma_link -&gt; __vma_link_rb, 将vma插入红黑树
</span><span class="c1"></span>	<span class="n">vma_link</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">rb_link</span><span class="p">,</span> <span class="n">rb_parent</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="831-a-namefind_vma_linksafind_vma_links">8.3.1. <a name='find_vma_links'></a>find_vma_links</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">int</span> <span class="nf">find_vma_links</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">**</span><span class="n">pprev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">***</span><span class="n">rb_link</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">rb_parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">__rb_link</span><span class="p">,</span> <span class="o">*</span><span class="n">__rb_parent</span><span class="p">,</span> <span class="o">*</span><span class="n">rb_prev</span><span class="p">;</span>

	<span class="n">__rb_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_rb</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="n">rb_prev</span> <span class="o">=</span> <span class="n">__rb_parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">__rb_link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma_tmp</span><span class="p">;</span>

		<span class="n">__rb_parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">__rb_link</span><span class="p">;</span>
		<span class="n">vma_tmp</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">__rb_parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span><span class="p">,</span> <span class="n">vm_rb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vma_tmp</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&gt;</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 如果vma_tmp_end_addr大于vma_end_addr且vma_start_end_addr小于vma_start_addr, 说明vma_tmp和vma重合, 函数报错
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">vma_tmp</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

			<span class="c1">// 继续遍历左节点
</span><span class="c1"></span>			<span class="n">__rb_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__rb_parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">rb_prev</span> <span class="o">=</span> <span class="n">__rb_parent</span><span class="p">;</span>
			<span class="c1">// 继续遍历右节点
</span><span class="c1"></span>			<span class="n">__rb_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__rb_parent</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 当__rb_link为空, 即对应结点为空时, 退出遍历红黑树循环
</span><span class="c1"></span>	<span class="c1">// __rb_link对应空结点, 即目标插入位置
</span><span class="c1"></span>	<span class="c1">// __rb_parent对应__rb_link的父结点
</span><span class="c1"></span>	<span class="c1">// pprev对应rb_prev指向的vm_arena_struct
</span><span class="c1"></span>
	<span class="o">*</span><span class="n">pprev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rb_prev</span><span class="p">)</span>
		<span class="o">*</span><span class="n">pprev</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">rb_prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span><span class="p">,</span> <span class="n">vm_rb</span><span class="p">);</span>
	<span class="o">*</span><span class="n">rb_link</span> <span class="o">=</span> <span class="n">__rb_link</span><span class="p">;</span>
	<span class="o">*</span><span class="n">rb_parent</span> <span class="o">=</span> <span class="n">__rb_parent</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="832-a-name-1a红黑树规则">8.3.2. <a name='-1'></a>红黑树规则</h4>
<ul>
<li>
<p>红黑树规则:</p>
<ul>
<li>节点是红色或黑色</li>
<li>根节点是黑色</li>
<li>每个叶节点都是黑色的空节点</li>
<li>每个红色节点的两个子节点都是黑色(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li>
<li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点</li>
</ul>
</li>
<li>
<p>插入节点时通过变色或者旋转维持红黑树规则</p>
</li>
</ul>
<h2 id="9-a-name-1a缺页中断">9. <a name='-1'></a>缺页中断</h2>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../../mm/__do_page_fault.png"
        data-srcset="../../mm/__do_page_fault.png, ../../mm/__do_page_fault.png 1.5x, ../../mm/__do_page_fault.png 2x"
        data-sizes="auto"
        alt="../../mm/__do_page_fault.png"
        title="__do_page_fault" /></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm"> * Page fault error code bits:
</span><span class="cm"> *
</span><span class="cm"> *   bit 0 ==	 0: no page found	1: protection fault
</span><span class="cm"> *   bit 1 ==	 0: read access		1: write access
</span><span class="cm"> *   bit 2 ==	 0: kernel-mode access	1: user-mode access
</span><span class="cm"> *   bit 3 ==				1: use of reserved bit detected
</span><span class="cm"> *   bit 4 ==				1: fault was an instruction fetch
</span><span class="cm"> *   bit 5 ==				1: protection keys block access
</span><span class="cm"> */</span>
<span class="k">enum</span> <span class="n">x86_pf_error_code</span> <span class="p">{</span>
	<span class="n">X86_PF_PROT</span>	<span class="o">=</span>		<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">X86_PF_WRITE</span>	<span class="o">=</span>		<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">X86_PF_USER</span>	<span class="o">=</span>		<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">X86_PF_RSVD</span>	<span class="o">=</span>		<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">X86_PF_INSTR</span>	<span class="o">=</span>		<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">X86_PF_PK</span>	<span class="o">=</span>		<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="91-a-namedo_page_faulta__do_page_fault源码分析">9.1. <a name='do_page_fault'></a>__do_page_fault源码分析</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span>
<span class="nf">__do_page_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hw_error_code</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// 将变量放入cache, 加快速度
</span><span class="c1"></span>	<span class="n">prefetchw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

	<span class="c1">// mmiotrace跟踪器, 用于跟踪基于内存映射的io设备
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">kmmio_fault</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">address</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="c1">// 判断缺页中断发生在内核态还是用户态
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fault_in_kernel_space</span><span class="p">(</span><span class="n">address</span><span class="p">)))</span>
		<span class="n">do_kern_addr_fault</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">hw_error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">do_user_addr_fault</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">hw_error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="92-a-namefault_in_kernel_spaceafault_in_kernel_space">9.2. <a name='fault_in_kernel_space'></a>fault_in_kernel_space</h3>
<ul>
<li>vsyscall和vdso的作用与区别
<ul>
<li>作用: 一般来说, 用户态与内核态通过系统调用进行交互, 但是这种交互非常浪费时间, 那么对于需要实时性的api如gettimeofday等就不太适用, 使用vsyscall或vdso可以加速</li>
<li>区别:
<ul>
<li>vsyscall是一种比较古老的机制, 他在固定地址映射内核内存页实现快速执行内核功能, 但安全性不高, 被vdso逐渐替代, 但是vdso只存在与动态链接, 静态链接程序没有vdso, 所以为了兼容性, vsyscall被保留下来</li>
<li>vdso可以应用aslr实现地址随机化, 而且无需考虑cpu差异性</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">int</span> <span class="nf">fault_in_kernel_space</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// x86_64架构下vsyscall在TASK_SIZE_MAX之上, 但并非内核空间, 所以单独列出
</span><span class="c1"></span>	<span class="c1">// #define VSYSCALL_ADDR (-10UL &lt;&lt; 20), VSYSCALL_ADDR即为vsyscall固定地址(在x86_64架构下(-10)用8字节存储, VSYSCALL_ADDR=0xffffffffff600000)
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_X86_64</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_vsyscall_vaddr</span><span class="p">(</span><span class="n">address</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="c1">// 将大于TASK_SIZE_MAX的地址视为内核空间
</span><span class="c1"></span>	<span class="k">return</span> <span class="n">address</span> <span class="o">&gt;=</span> <span class="n">TASK_SIZE_MAX</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="93-a-namedo_kern_addr_faultado_kern_addr_fault">9.3. <a name='do_kern_addr_fault'></a>do_kern_addr_fault</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span>
<span class="nf">do_kern_addr_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hw_error_code</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// X86_PF_PK存在于用户页, 并非内核页
</span><span class="c1"></span>	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">hw_error_code</span> <span class="o">&amp;</span> <span class="n">X86_PF_PK</span><span class="p">);</span>

	<span class="c1">// 检测错误是否由于vmalloc fault导致
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hw_error_code</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">X86_PF_RSVD</span> <span class="o">|</span> <span class="n">X86_PF_USER</span> <span class="o">|</span> <span class="n">X86_PF_PROT</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vmalloc_fault</span><span class="p">(</span><span class="n">address</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// 检测错误是否是由于TLB表项陈旧(内核页权限变更后, TLB没有更新)
</span><span class="c1"></span>	<span class="c1">// 如果TLB表项陈旧导致错误, 那么只有两种可能. 1. 数据写入时TLB(), 2. 指令执行时TLB(NX)
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">spurious_kernel_fault</span><span class="p">(</span><span class="n">hw_error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="c1">// 判断kprobe是否hook了缺页错误
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">kprobe_page_fault</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">X86_TRAP_PF</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="c1">// 非法地址访问导致页错误
</span><span class="c1"></span>	<span class="n">bad_area_nosemaphore</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">hw_error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="931-a-namevmalloc_faultavmalloc_fault">9.3.1. <a name='vmalloc_fault'></a>vmalloc_fault</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">vmalloc_fault</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">,</span> <span class="o">*</span><span class="n">pgd_k</span><span class="p">;</span>
	<span class="n">p4d_t</span> <span class="o">*</span><span class="n">p4d</span><span class="p">,</span> <span class="o">*</span><span class="n">p4d_k</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>

	<span class="c1">// #define high_memory (-128UL &lt;&lt; 20)
</span><span class="c1"></span>	<span class="c1">// #define VMALLOC_START (((unsigned long)high_memory + VMALLOC_OFFSET) &amp; ~(VMALLOC_OFFSET-1))
</span><span class="c1"></span>	<span class="c1">// VMALLOC空间和前面保留8M的hole保证安全性
</span><span class="c1"></span>	<span class="c1">// 经计算VMALLOC_START=0xfffffffff8000000+8M
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">address</span> <span class="o">&gt;=</span> <span class="n">VMALLOC_START</span> <span class="o">&amp;&amp;</span> <span class="n">address</span> <span class="o">&lt;</span> <span class="n">VMALLOC_END</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="c1">// 使用vmalloc分配内存后, 内存映射会被直接写入全局内核页表init_mm
</span><span class="c1"></span>	<span class="c1">// 进程的内核页表是在进程被创建时, 直接复制内核页表获得, 不具备实时性, 所以只有当发生vmalloc缺页中断时, 才会把对应的全局内核页表项复制到进程内核页表
</span><span class="c1"></span>
	<span class="c1">// 获得进程内核页表
</span><span class="c1"></span>	<span class="n">pgd</span> <span class="o">=</span> <span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">__va</span><span class="p">(</span><span class="n">read_cr3_pa</span><span class="p">())</span> <span class="o">+</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>

	<span class="c1">// 获得全局内核页表
</span><span class="c1"></span>	<span class="n">pgd_k</span> <span class="o">=</span> <span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>

	<span class="c1">// 将与addr关联的全局内核页表项复制到进程内核页表
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pgd_k</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pgtable_l5_enabled</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">set_pgd</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="o">*</span><span class="n">pgd_k</span><span class="p">);</span>
			<span class="n">arch_flush_lazy_mmu_mode</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pgd_page_vaddr</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pgd_page_vaddr</span><span class="p">(</span><span class="o">*</span><span class="n">pgd_k</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 获得进程内核页表和全局内核页表对应的p4d, 令p4d_proc=p4d_kern实现页表项复制
</span><span class="c1"></span>	<span class="n">p4d</span> <span class="o">=</span> <span class="n">p4d_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="n">p4d_k</span> <span class="o">=</span> <span class="n">p4d_offset</span><span class="p">(</span><span class="n">pgd_k</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p4d_none</span><span class="p">(</span><span class="o">*</span><span class="n">p4d_k</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p4d_none</span><span class="p">(</span><span class="o">*</span><span class="n">p4d</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pgtable_l5_enabled</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">set_p4d</span><span class="p">(</span><span class="n">p4d</span><span class="p">,</span> <span class="o">*</span><span class="n">p4d_k</span><span class="p">);</span>
		<span class="n">arch_flush_lazy_mmu_mode</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">p4d_pfn</span><span class="p">(</span><span class="o">*</span><span class="n">p4d</span><span class="p">)</span> <span class="o">!=</span> <span class="n">p4d_pfn</span><span class="p">(</span><span class="o">*</span><span class="n">p4d_k</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">CONFIG_PGTABLE_LEVELS</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">);</span>

	<span class="c1">// 对pud, pmd, pte做安全检测
</span><span class="c1"></span>	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">p4d</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pud_none</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pud_large</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_large</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_kernel</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	
	<span class="c1">// 如果pte对应的page并非正在被使用则缺页
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_present</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="932-a-namespurious_kernel_faultaspurious_kernel_fault">9.3.2. <a name='spurious_kernel_fault'></a>spurious_kernel_fault</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span>
<span class="nf">spurious_kernel_fault</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">error_code</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">p4d_t</span> <span class="o">*</span><span class="n">p4d</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="c1">// 由于TLB表项陈旧导致的虚假错误, 给出的错误原因只有两种:写入(X86_PF_WRITE), 指令执行(X86_PF_INSTR)
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">error_code</span> <span class="o">!=</span> <span class="p">(</span><span class="n">X86_PF_WRITE</span> <span class="o">|</span> <span class="n">X86_PF_PROT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">error_code</span> <span class="o">!=</span> <span class="p">(</span><span class="n">X86_PF_INSTR</span> <span class="o">|</span> <span class="n">X86_PF_PROT</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">// 定位内核页表
</span><span class="c1"></span>	<span class="n">pgd</span> <span class="o">=</span> <span class="n">init_mm</span><span class="p">.</span><span class="n">pgd</span> <span class="o">+</span> <span class="n">pgd_index</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>

	<span class="c1">// 判断pgd是否在内存中
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pgd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">// 通过偏移获得p4d表项
</span><span class="c1"></span>	<span class="n">p4d</span> <span class="o">=</span> <span class="n">p4d_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p4d_present</span><span class="p">(</span><span class="o">*</span><span class="n">p4d</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">// 如果在p4d表项处开启huge page机制, 则直接进入spurious_kernel_fault_check
</span><span class="c1"></span>	<span class="cm">/* spurious_kernel_fault_check:
</span><span class="cm">	if ((error_code &amp; X86_PF_WRITE) &amp;&amp; !pte_write(*pte))
</span><span class="cm">		return 0;
</span><span class="cm">
</span><span class="cm">	if ((error_code &amp; X86_PF_INSTR) &amp;&amp; !pte_exec(*pte))
</span><span class="cm">		return 0;
</span><span class="cm">	return 1;
</span><span class="cm">	*/</span>
	<span class="c1">// 检测是否是因为tlb项老旧导致错误
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">p4d_large</span><span class="p">(</span><span class="o">*</span><span class="n">p4d</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">spurious_kernel_fault_check</span><span class="p">(</span><span class="n">error_code</span><span class="p">,</span> <span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">p4d</span><span class="p">);</span>

	<span class="c1">// 以下处理流程相同, 不再描述
</span><span class="c1"></span>	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">p4d</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pud_present</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pud_large</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">spurious_kernel_fault_check</span><span class="p">(</span><span class="n">error_code</span><span class="p">,</span> <span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pud</span><span class="p">);</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_large</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">spurious_kernel_fault_check</span><span class="p">(</span><span class="n">error_code</span><span class="p">,</span> <span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pmd</span><span class="p">);</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_kernel</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_present</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spurious_kernel_fault_check</span><span class="p">(</span><span class="n">error_code</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spurious_kernel_fault_check</span><span class="p">(</span><span class="n">error_code</span><span class="p">,</span> <span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pmd</span><span class="p">);</span>

	<span class="c1">// 如果在pte阶段还是没有检测到虚假错误则报一个bug
</span><span class="c1"></span>	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">,</span> <span class="s">&#34;PMD has incorrect permission bits</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="933-a-namebad_area_nosemaphoreabad_area_nosemaphore">9.3.3. <a name='bad_area_nosemaphore'></a>bad_area_nosemaphore</h4>
<ul>
<li>bad_area_nosemaphore -&gt; __bad_area_nosemaphore</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span>
<span class="nf">__bad_area_nosemaphore</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">error_code</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pkey</span><span class="p">,</span> <span class="kt">int</span> <span class="n">si_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>

	<span class="c1">// 如果请求来自用户态, 说明想要越界访问内核空间
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">error_code</span> <span class="o">&amp;</span> <span class="n">X86_PF_USER</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">local_irq_enable</span><span class="p">();</span>

		<span class="cm">/*
</span><span class="cm">		 * Valid to do another page fault here because this one came
</span><span class="cm">		 * from user space:
</span><span class="cm">		 */</span>
		<span class="c1">// 不忽略nx页上的取指错误 
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">is_prefetch</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_errata100</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">address</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="c1">// 为了防止内核页表布局被泄露, 这里把用户态访问内核空间错误伪造成protection faults
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&gt;=</span> <span class="n">TASK_SIZE_MAX</span><span class="p">)</span>
			<span class="n">error_code</span> <span class="o">|=</span> <span class="n">X86_PF_PROT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">show_unhandled_signals</span><span class="p">))</span>
			<span class="c1">// 打印错误信息
</span><span class="c1"></span>			<span class="n">show_signal_msg</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>

		<span class="n">set_signal_archinfo</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">error_code</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">si_code</span> <span class="o">==</span> <span class="n">SEGV_PKUERR</span><span class="p">)</span>
			<span class="n">force_sig_pkuerr</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">address</span><span class="p">,</span> <span class="n">pkey</span><span class="p">);</span>

		<span class="c1">// 发送SIGSEGV信号
</span><span class="c1"></span>		<span class="n">force_sig_fault</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">si_code</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">address</span><span class="p">);</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_f00f_bug</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">address</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="c1">// 在内核中发生内核缺页
</span><span class="c1"></span>	<span class="n">no_context</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">si_code</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="no_context">no_context</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span>
<span class="nf">no_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">error_code</span><span class="p">,</span>
	   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signal</span><span class="p">,</span> <span class="kt">int</span> <span class="n">si_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sig</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
		<span class="c1">// 用户模式访问内核态, 直接oops
</span><span class="c1"></span>		<span class="k">goto</span> <span class="n">oops</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// 搜索异常表, 试图找到一个对应该异常的例程来进行修正
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">fixup_exception</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">X86_TRAP_PF</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">))</span> <span class="p">{</span>
		<span class="c1">// 任何中断错误都会在fixup_exception中获得处理, 下面的错误处理流程只用于任务上下文中的错误
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">in_interrupt</span><span class="p">())</span>
			<span class="k">return</span><span class="p">;</span>	
		<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">sig_on_uaccess_err</span> <span class="o">&amp;&amp;</span> <span class="n">signal</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_signal_archinfo</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">error_code</span><span class="p">);</span>
			<span class="n">force_sig_fault</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">si_code</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">address</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*
</span><span class="cm">	 * 32-bit:
</span><span class="cm">	 *
</span><span class="cm">	 *   Valid to do another page fault here, because if this fault
</span><span class="cm">	 *   had been triggered by is_prefetch fixup_exception would have
</span><span class="cm">	 *   handled it.
</span><span class="cm">	 *
</span><span class="cm">	 * 64-bit:
</span><span class="cm">	 *
</span><span class="cm">	 *   Hall of CPU/BIOS bugs.
</span><span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_prefetch</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_errata93</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">address</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="c1">// 固件访问错误恢复
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_EFI</span><span class="p">))</span>
		<span class="n">efi_recover_from_page_fault</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>

<span class="nl">oops</span><span class="p">:</span>
	<span class="c1">// 确定时内核缺陷, 使用oops打印错误...
</span><span class="c1"></span>	<span class="n">flags</span> <span class="o">=</span> <span class="n">oops_begin</span><span class="p">();</span>

	<span class="n">show_fault_oops</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task_stack_end_corrupted</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&#34;Thread overran stack, or stack corrupted</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>

	<span class="n">sig</span> <span class="o">=</span> <span class="n">SIGKILL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__die</span><span class="p">(</span><span class="s">&#34;Oops&#34;</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">error_code</span><span class="p">))</span>
		<span class="n">sig</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Executive summary in case the body of the oops scrolled away */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEFAULT</span> <span class="s">&#34;CR2: %016lx</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>

	<span class="n">oops_end</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="94-a-namedo_user_addr_faultado_user_addr_fault">9.4. <a name='do_user_addr_fault'></a>do_user_addr_fault</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">do_user_addr_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hw_error_code</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="n">vm_fault_t</span> <span class="n">fault</span><span class="p">,</span> <span class="n">major</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">FAULT_FLAG_ALLOW_RETRY</span> <span class="o">|</span> <span class="n">FAULT_FLAG_KILLABLE</span><span class="p">;</span>

	<span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="n">mm</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>

	<span class="c1">// 判断kprobe是否hook了缺页错误
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">kprobe_page_fault</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">X86_TRAP_PF</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="c1">// Reserved bits不会被设置在用户的页表项, 如果存在Reserved bits则发生页表错误
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">hw_error_code</span> <span class="o">&amp;</span> <span class="n">X86_PF_RSVD</span><span class="p">))</span>
		<span class="n">pgtable_bad</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">hw_error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>

	<span class="c1">// 如果开启smap且kernel(supervisor)访问用户态地址(X86_PF_USER=0)则进入bad_area_nosemaphore
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cpu_feature_enabled</span><span class="p">(</span><span class="n">X86_FEATURE_SMAP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="o">!</span><span class="p">(</span><span class="n">hw_error_code</span> <span class="o">&amp;</span> <span class="n">X86_PF_USER</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="o">!</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">X86_EFLAGS_AC</span><span class="p">)))</span>
	<span class="p">{</span>
		<span class="n">bad_area_nosemaphore</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">hw_error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*
</span><span class="cm">	 * If we&#39;re in an interrupt, have no user context or are running
</span><span class="cm">	 * in a region with pagefaults disabled then we must not take the fault
</span><span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">faulthandler_disabled</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">mm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bad_area_nosemaphore</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">hw_error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// 因为到达这一步时cr2中的虚拟地址已经被另存且vmalloc_fault被处理所以开启中断是安全可行的
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">FAULT_FLAG_USER</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">X86_EFLAGS_IF</span><span class="p">)</span>
			<span class="n">local_irq_enable</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="c1">// 记录事件
</span><span class="c1"></span>	<span class="n">perf_sw_event</span><span class="p">(</span><span class="n">PERF_COUNT_SW_PAGE_FAULTS</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>

	<span class="c1">// 更新flags标志位(后面引用)
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">hw_error_code</span> <span class="o">&amp;</span> <span class="n">X86_PF_WRITE</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw_error_code</span> <span class="o">&amp;</span> <span class="n">X86_PF_INSTR</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">FAULT_FLAG_INSTRUCTION</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_X86_64
</span><span class="cp"></span>
	<span class="c1">// vsyscall没有vma, 所以在find_vma之前对vsyscall做模拟
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">is_vsyscall_vaddr</span><span class="p">(</span><span class="n">address</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">emulate_vsyscall</span><span class="p">(</span><span class="n">hw_error_code</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">address</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif
</span><span class="cp"></span>
	<span class="c1">// 1. 内核只能访问用户地址空间的在exception_tables上定义的指令, 如果直接进行这样的尝试(但指令却在exception_tables之外)则会因为持有了mmap_sem锁, 而让系统死锁
</span><span class="c1"></span>	<span class="c1">// 2. 所以, 只有当获得mmap_sem锁失败后, 才能尝试使用1.
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">down_read_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user_mode</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">search_exception_tables</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">bad_area_nosemaphore</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">hw_error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
<span class="nl">retry</span><span class="p">:</span>
		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 如果获得mmap_sem锁成功则会错过down_read内的might_sleep, 这里补一个might_sleep
</span><span class="c1"></span>		<span class="n">might_sleep</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="c1">// 判断vma是否合法
</span><span class="c1"></span>	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bad_area</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">hw_error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// 做简单的安全检测
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;=</span> <span class="n">address</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">good_area</span><span class="p">;</span>

	<span class="c1">// 判断vma是否向下增加
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_GROWSDOWN</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">bad_area</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">hw_error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// 如果address在栈空间, 则根据address和vma-&gt;start的关系决定是否扩充栈
</span><span class="c1"></span>	<span class="c1">// 如果address &lt; vma-&gt;start, 则另vma-&gt;start=address向下扩充stack
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">expand_stack</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">bad_area</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">hw_error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">good_area</span><span class="p">:</span>
	<span class="c1">// 判断是否因为页操作与vma权限不符(保留X86_PF_PK错误, 因为这是留给写时复制的, 并非权限错误)
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">access_error</span><span class="p">(</span><span class="n">hw_error_code</span><span class="p">,</span> <span class="n">vma</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">bad_area_access_error</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">hw_error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// 缺页处理
</span><span class="c1"></span>	<span class="n">fault</span> <span class="o">=</span> <span class="n">handle_mm_fault</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="p">...</span>

</code></pre></td></tr></table>
</div>
</div><h4 id="941-a-namehandle_mm_faultahandle_mm_fault">9.4.1. <a name='handle_mm_fault'></a>handle_mm_fault</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span><span class="lnt">98
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">vm_fault_t</span> <span class="nf">__handle_mm_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_fault</span> <span class="n">vmf</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="p">,</span>
		<span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">address</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pgoff</span> <span class="o">=</span> <span class="n">linear_page_index</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">),</span>
		<span class="p">.</span><span class="n">gfp_mask</span> <span class="o">=</span> <span class="n">__get_fault_gfp_mask</span><span class="p">(</span><span class="n">vma</span><span class="p">),</span>
	<span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dirty</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">;</span>
	
	<span class="c1">// 以vma-&gt;vm_mm为根结点遍历页表, 定位到pmd
</span><span class="c1"></span>	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">p4d_t</span> <span class="o">*</span><span class="n">p4d</span><span class="p">;</span>
	<span class="n">vm_fault_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="c1">// 定位pgd
</span><span class="c1"></span>	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>

	<span class="c1">// 如果没开5级页表直接返回pgd
</span><span class="c1"></span>	<span class="n">p4d</span> <span class="o">=</span> <span class="n">p4d_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p4d</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>

	<span class="c1">// 定位pud
</span><span class="c1"></span>	<span class="n">vmf</span><span class="p">.</span><span class="n">pud</span> <span class="o">=</span> <span class="n">pud_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">p4d</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmf</span><span class="p">.</span><span class="n">pud</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>

	<span class="c1">// 中间表项为空, 且开启huge_page, 设置
</span><span class="c1"></span>	<span class="c1">// 如果pud为空, 且vma可以创建透明的huge_page, 则create_huge_pud触发huge_page错误(匿名页不支持)
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">pud_none</span><span class="p">(</span><span class="o">*</span><span class="n">vmf</span><span class="p">.</span><span class="n">pud</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">__transparent_hugepage_enabled</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">create_huge_pud</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_FALLBACK</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pud_t</span> <span class="n">orig_pud</span> <span class="o">=</span> <span class="o">*</span><span class="n">vmf</span><span class="p">.</span><span class="n">pud</span><span class="p">;</span>

		<span class="n">barrier</span><span class="p">();</span>

		<span class="c1">// pud具有_PAGE_PSE标志位, 且pud为devmap
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">pud_trans_huge</span><span class="p">(</span><span class="n">orig_pud</span><span class="p">)</span> <span class="o">||</span> <span class="n">pud_devmap</span><span class="p">(</span><span class="n">orig_pud</span><span class="p">))</span> <span class="p">{</span>
			<span class="c1">// pud将要被更新为脏页
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">dirty</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pud_write</span><span class="p">(</span><span class="n">orig_pud</span><span class="p">))</span> <span class="p">{</span>

				<span class="c1">// 触发huge_page错误(匿名页不支持)
</span><span class="c1"></span>				<span class="n">ret</span> <span class="o">=</span> <span class="n">wp_huge_pud</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmf</span><span class="p">,</span> <span class="n">orig_pud</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_FALLBACK</span><span class="p">))</span>
					<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">huge_pud_set_accessed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmf</span><span class="p">,</span> <span class="n">orig_pud</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">vmf</span><span class="p">.</span><span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vmf</span><span class="p">.</span><span class="n">pud</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmf</span><span class="p">.</span><span class="n">pmd</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
	
	<span class="c1">// 如果pmd为空, 且vma可以创建透明的huge_page, 则create_huge_pmd创建大页
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">vmf</span><span class="p">.</span><span class="n">pmd</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">__transparent_hugepage_enabled</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">create_huge_pmd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_FALLBACK</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pmd_t</span> <span class="n">orig_pmd</span> <span class="o">=</span> <span class="o">*</span><span class="n">vmf</span><span class="p">.</span><span class="n">pmd</span><span class="p">;</span>

		<span class="n">barrier</span><span class="p">();</span>
		<span class="c1">// 判断pmd是否在swap分区(不在内存中)
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_swap_pmd</span><span class="p">(</span><span class="n">orig_pmd</span><span class="p">)))</span> <span class="p">{</span>
			<span class="c1">// 如果支持迁移但并非迁移pmd入口, 则上报bug
</span><span class="c1"></span>			<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">thp_migration_supported</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
					  <span class="o">!</span><span class="n">is_pmd_migration_entry</span><span class="p">(</span><span class="n">orig_pmd</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_pmd_migration_entry</span><span class="p">(</span><span class="n">orig_pmd</span><span class="p">))</span>
				<span class="n">pmd_migration_entry_wait</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vmf</span><span class="p">.</span><span class="n">pmd</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="c1">// pud具有_PAGE_PSE标志位, 且pud为devmap
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">pmd_trans_huge</span><span class="p">(</span><span class="n">orig_pmd</span><span class="p">)</span> <span class="o">||</span> <span class="n">pmd_devmap</span><span class="p">(</span><span class="n">orig_pmd</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pmd_protnone</span><span class="p">(</span><span class="n">orig_pmd</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">vma_is_accessible</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">do_huge_pmd_numa_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmf</span><span class="p">,</span> <span class="n">orig_pmd</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">dirty</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pmd_write</span><span class="p">(</span><span class="n">orig_pmd</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">wp_huge_pmd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmf</span><span class="p">,</span> <span class="n">orig_pmd</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_FALLBACK</span><span class="p">))</span>
					<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">huge_pmd_set_accessed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmf</span><span class="p">,</span> <span class="n">orig_pmd</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// vmf被填充, 下一步根据vmf分配物理页
</span><span class="c1"></span>	<span class="k">return</span> <span class="n">handle_pte_fault</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmf</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="handle_pte_fault">handle_pte_fault</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">vm_fault_t</span> <span class="nf">handle_pte_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="n">entry</span><span class="p">;</span>

	<span class="c1">// 若pmd不存在, 则pte不存在
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pte</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// pmd_devmap_trans_unstable{return pmd_devmap(*pmd) || pmd_trans_unstable(pmd);}
</span><span class="c1"></span>		<span class="c1">// pmd_devmap检测pmd是否为_PAGE_DEVMAP, 如果是则直接返回1
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// pmd_trans_unstable-&gt;pmd_none_or_trans_huge_or_clear_bad{...}
</span><span class="c1"></span>		<span class="c1">// 检测pmd是否为空, 或者是否可以转换为huge_page, 否则进入pmd_clear_bad
</span><span class="c1"></span>
		<span class="c1">// 提前检测_PAGE_DEVMAP, 可以避免后面devmap页进入pmd_none_or_trans_huge_or_clear_bad后陷入pmd_clear_bad, 而滥用dmesg打印错误
</span><span class="c1"></span>		<span class="c1">// pmd_devmap_trans_unstable=pmd_devmap+pmd_trans_unstable 可这个命名太抽象 =.=
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">pmd_devmap_trans_unstable</span><span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="c1">// 此时pmd存在且不可能变成huge_pmd, 使用pte_offset_map是安全的
</span><span class="c1"></span>		<span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_map</span><span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">,</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">);</span>
		<span class="n">vmf</span><span class="o">-&gt;</span><span class="n">orig_pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pte</span><span class="p">;</span>

		<span class="n">barrier</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_none</span><span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">orig_pte</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pte_unmap</span><span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pte</span><span class="p">);</span>
			<span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pte</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// pte为空, 分配页表
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pte</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma_is_anonymous</span><span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">vma</span><span class="p">))</span>
			<span class="c1">// 处理匿名页
</span><span class="c1"></span>			<span class="k">return</span> <span class="n">do_anonymous_page</span><span class="p">(</span><span class="n">vmf</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="c1">// 处理文件映射页
</span><span class="c1"></span>			<span class="k">return</span> <span class="n">do_fault</span><span class="p">(</span><span class="n">vmf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// -----------  物理页存在  -----------
</span><span class="c1"></span>
	<span class="c1">// 页表已建立, 但不存在与内存, 做页交换
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_present</span><span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">orig_pte</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">do_swap_page</span><span class="p">(</span><span class="n">vmf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pte_protnone</span><span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">orig_pte</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">vma_is_accessible</span><span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">vma</span><span class="p">))</span>
		<span class="c1">// 维持node平衡, 进行页迁移
</span><span class="c1"></span>		<span class="k">return</span> <span class="n">do_numa_page</span><span class="p">(</span><span class="n">vmf</span><span class="p">);</span>

	<span class="n">vmf</span><span class="o">-&gt;</span><span class="n">ptl</span> <span class="o">=</span> <span class="n">pte_lockptr</span><span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">ptl</span><span class="p">);</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">orig_pte</span><span class="p">;</span>

	<span class="c1">// 锁定资源区后, 检测pte是否发生变化, 如果发生, 直接解锁资源区 return
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pte_same</span><span class="p">(</span><span class="o">*</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pte</span><span class="p">,</span> <span class="n">entry</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="c1">// 因写入而触发中断
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_write</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>
			<span class="c1">// 写时复制缺页中断
</span><span class="c1"></span>			<span class="k">return</span> <span class="n">do_wp_page</span><span class="p">(</span><span class="n">vmf</span><span class="p">);</span>

		<span class="c1">// 标记脏页
</span><span class="c1"></span>		<span class="n">entry</span> <span class="o">=</span> <span class="n">pte_mkdirty</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">pte_mkyoung</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>

	<span class="c1">// 如果pte内容没有变化进入else
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">ptep_set_access_flags</span><span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">vma</span><span class="p">,</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pte</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span>
				<span class="n">vmf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">))</span> <span class="p">{</span>
		<span class="c1">// pte内容更改, 刷新mmu
</span><span class="c1"></span>		<span class="n">update_mmu_cache</span><span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">vma</span><span class="p">,</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pte</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

		<span class="c1">// 如果pte没有发生变化, 且是写中断错误, 这里可能对应写时复制, 所以更新tlb
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">)</span>
			<span class="n">flush_tlb_fix_spurious_fault</span><span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">vma</span><span class="p">,</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">unlock</span><span class="p">:</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pte</span><span class="p">,</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">ptl</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="10-a-nameptmallocaptmalloc">10. <a name='ptmalloc'></a>ptmalloc</h2>
<blockquote>
<p>ptmalloc是linux 用户态堆管理机制, 也是本文源码分析的最后一部分, 链接如下:</p>
</blockquote>
<p><a href="https://www.povcfe.site/posts/ptmalloc/" target="_blank" rel="noopener noreffer">ptmalloc源码解析</a></p>
<h2 id="11-a-name-1a杂记">11. <a name='-1'></a>杂记</h2>
<ul>
<li>山高路远不畏险</li>
<li>还有很多需要写的东西, 留给下一篇文章</li>
</ul>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2021-01-12</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/kernel_mm/index.md" target="_blank">Read Markdown</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="https://povcfe.github.io/kernel_mm/" data-title="linux内核(5.4.81)---内存管理模块源码分析" data-via="xxxx" data-hashtags="linux kernel,源码分析,内存管理"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="https://povcfe.github.io/kernel_mm/" data-hashtag="linux kernel"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="Share on Hacker News" data-sharer="hackernews" data-url="https://povcfe.github.io/kernel_mm/" data-title="linux内核(5.4.81)---内存管理模块源码分析"><i class="fab fa-hacker-news fa-fw"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="https://povcfe.github.io/kernel_mm/" data-title="linux内核(5.4.81)---内存管理模块源码分析"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="https://povcfe.github.io/kernel_mm/" data-title="linux内核(5.4.81)---内存管理模块源码分析"><i class="fab fa-weibo fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/linux-kernel/">linux kernel</a>,&nbsp;<a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a>,&nbsp;<a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/kernel_boot/" class="prev" rel="prev" title="linux内核(5.4.81)---内核引导"><i class="fas fa-angle-left fa-fw"></i>linux内核(5.4.81)---内核引导</a>
            <a href="/reprint/" class="next" rel="next" title="一些思考">一些思考<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="valine" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://valine.js.org/">Valine</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.80.0">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2019 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">xxxx</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/valine/valine.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":10},"comment":{"valine":{"appId":"QGzwQXOqs5JOhN4RGPOkR2mR-MdYXbMMI","appKey":"WBmoGyJtbqUswvfLh6L8iEBr","avatar":"mp","el":"#valine","emojiCDN":"https://cdn.jsdelivr.net/npm/emoji-datasource-google@5.0.1/img/google/64/","emojiMaps":{"100":"1f4af.png","alien":"1f47d.png","anger":"1f4a2.png","angry":"1f620.png","anguished":"1f627.png","astonished":"1f632.png","black_heart":"1f5a4.png","blue_heart":"1f499.png","blush":"1f60a.png","bomb":"1f4a3.png","boom":"1f4a5.png","broken_heart":"1f494.png","brown_heart":"1f90e.png","clown_face":"1f921.png","cold_face":"1f976.png","cold_sweat":"1f630.png","confounded":"1f616.png","confused":"1f615.png","cry":"1f622.png","crying_cat_face":"1f63f.png","cupid":"1f498.png","dash":"1f4a8.png","disappointed":"1f61e.png","disappointed_relieved":"1f625.png","dizzy":"1f4ab.png","dizzy_face":"1f635.png","drooling_face":"1f924.png","exploding_head":"1f92f.png","expressionless":"1f611.png","face_vomiting":"1f92e.png","face_with_cowboy_hat":"1f920.png","face_with_hand_over_mouth":"1f92d.png","face_with_head_bandage":"1f915.png","face_with_monocle":"1f9d0.png","face_with_raised_eyebrow":"1f928.png","face_with_rolling_eyes":"1f644.png","face_with_symbols_on_mouth":"1f92c.png","face_with_thermometer":"1f912.png","fearful":"1f628.png","flushed":"1f633.png","frowning":"1f626.png","ghost":"1f47b.png","gift_heart":"1f49d.png","green_heart":"1f49a.png","grimacing":"1f62c.png","grin":"1f601.png","grinning":"1f600.png","hankey":"1f4a9.png","hear_no_evil":"1f649.png","heart":"2764-fe0f.png","heart_decoration":"1f49f.png","heart_eyes":"1f60d.png","heart_eyes_cat":"1f63b.png","heartbeat":"1f493.png","heartpulse":"1f497.png","heavy_heart_exclamation_mark_ornament":"2763-fe0f.png","hole":"1f573-fe0f.png","hot_face":"1f975.png","hugging_face":"1f917.png","hushed":"1f62f.png","imp":"1f47f.png","innocent":"1f607.png","japanese_goblin":"1f47a.png","japanese_ogre":"1f479.png","joy":"1f602.png","joy_cat":"1f639.png","kiss":"1f48b.png","kissing":"1f617.png","kissing_cat":"1f63d.png","kissing_closed_eyes":"1f61a.png","kissing_heart":"1f618.png","kissing_smiling_eyes":"1f619.png","laughing":"1f606.png","left_speech_bubble":"1f5e8-fe0f.png","love_letter":"1f48c.png","lying_face":"1f925.png","mask":"1f637.png","money_mouth_face":"1f911.png","nauseated_face":"1f922.png","nerd_face":"1f913.png","neutral_face":"1f610.png","no_mouth":"1f636.png","open_mouth":"1f62e.png","orange_heart":"1f9e1.png","partying_face":"1f973.png","pensive":"1f614.png","persevere":"1f623.png","pleading_face":"1f97a.png","pouting_cat":"1f63e.png","purple_heart":"1f49c.png","rage":"1f621.png","relaxed":"263a-fe0f.png","relieved":"1f60c.png","revolving_hearts":"1f49e.png","right_anger_bubble":"1f5ef-fe0f.png","robot_face":"1f916.png","rolling_on_the_floor_laughing":"1f923.png","scream":"1f631.png","scream_cat":"1f640.png","see_no_evil":"1f648.png","shushing_face":"1f92b.png","skull":"1f480.png","skull_and_crossbones":"2620-fe0f.png","sleeping":"1f634.png","sleepy":"1f62a.png","slightly_frowning_face":"1f641.png","slightly_smiling_face":"1f642.png","smile":"1f604.png","smile_cat":"1f638.png","smiley":"1f603.png","smiley_cat":"1f63a.png","smiling_face_with_3_hearts":"1f970.png","smiling_imp":"1f608.png","smirk":"1f60f.png","smirk_cat":"1f63c.png","sneezing_face":"1f927.png","sob":"1f62d.png","space_invader":"1f47e.png","sparkling_heart":"1f496.png","speak_no_evil":"1f64a.png","speech_balloon":"1f4ac.png","star-struck":"1f929.png","stuck_out_tongue":"1f61b.png","stuck_out_tongue_closed_eyes":"1f61d.png","stuck_out_tongue_winking_eye":"1f61c.png","sunglasses":"1f60e.png","sweat":"1f613.png","sweat_drops":"1f4a6.png","sweat_smile":"1f605.png","thinking_face":"1f914.png","thought_balloon":"1f4ad.png","tired_face":"1f62b.png","triumph":"1f624.png","two_hearts":"1f495.png","unamused":"1f612.png","upside_down_face":"1f643.png","weary":"1f629.png","white_frowning_face":"2639-fe0f.png","white_heart":"1f90d.png","wink":"1f609.png","woozy_face":"1f974.png","worried":"1f61f.png","yawning_face":"1f971.png","yellow_heart":"1f49b.png","yum":"1f60b.png","zany_face":"1f92a.png","zipper_mouth_face":"1f910.png","zzz":"1f4a4.png"},"enableQQ":false,"highlight":true,"lang":"en","pageSize":10,"placeholder":"Your comment ...","recordIP":true,"serverURLs":"https://leancloud.hugoloveit.com","visitor":true}},"search":{"algoliaAppID":"PASDMWALPK","algoliaIndex":"index.en","algoliaSearchKey":"b42948e51daaa93df92381c8e2ac0f93","highlightTag":"em","maxResultLength":10,"noResultsFound":"No results found","snippetLength":30,"type":"algolia"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
