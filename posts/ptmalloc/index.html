<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>glibc2.23 ptmalloc 原理概述 - povcfe&#39;s blog</title><meta name="Description" content="povcfe&#39;s blog"><meta property="og:title" content="glibc2.23 ptmalloc 原理概述" />
<meta property="og:description" content="发表于看雪论坛
 linux用户态下的堆溢出利用即是对ptmalloc2安全机制的绕过，只有深入的了解ptmalloc，才能进行精准的堆溢出攻击
 malloc __libc_malloc(传入参数:size)  判断 是否定义hook函数 ，如果存在则调用hook函数，否则跳到2  void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); 执行arena_get得到空闲分配区  arena_get (ar_ptr, bytes); 调用_int_malloc()获得内存地址  victim = _int_malloc (ar_ptr, bytes); 如果分配失败，ptmalloc会尝试再去寻找一个可用的arena并进行内存分配  if (!victim &amp;&amp; ar_ptr != NULL) { LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); } 得到内存地址后解锁分配区  if (ar_ptr !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://povcfe.github.io/posts/ptmalloc/" />
<meta property="og:image" content="https://povcfe.github.io/logo.png"/>
<meta property="article:published_time" content="2019-10-06T10:23:59-08:00" />
<meta property="article:modified_time" content="2019-10-06T10:23:59-08:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://povcfe.github.io/logo.png"/>

<meta name="twitter:title" content="glibc2.23 ptmalloc 原理概述"/>
<meta name="twitter:description" content="发表于看雪论坛
 linux用户态下的堆溢出利用即是对ptmalloc2安全机制的绕过，只有深入的了解ptmalloc，才能进行精准的堆溢出攻击
 malloc __libc_malloc(传入参数:size)  判断 是否定义hook函数 ，如果存在则调用hook函数，否则跳到2  void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); 执行arena_get得到空闲分配区  arena_get (ar_ptr, bytes); 调用_int_malloc()获得内存地址  victim = _int_malloc (ar_ptr, bytes); 如果分配失败，ptmalloc会尝试再去寻找一个可用的arena并进行内存分配  if (!victim &amp;&amp; ar_ptr != NULL) { LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); } 得到内存地址后解锁分配区  if (ar_ptr !"/>
<meta name="application-name" content="povcfe&#39;s blog">
<meta name="apple-mobile-web-app-title" content="povcfe&#39;s blog"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://povcfe.github.io/posts/ptmalloc/" /><link rel="prev" href="https://povcfe.github.io/posts/pwn/" /><link rel="next" href="https://povcfe.github.io/posts/kernel_rop1/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "glibc2.23 ptmalloc 原理概述",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/povcfe.github.io\/posts\/ptmalloc\/"
        },"genre": "posts","keywords": "linux, ptmalloc, heap","wordcount":  1626 ,
        "url": "https:\/\/povcfe.github.io\/posts\/ptmalloc\/","datePublished": "2019-10-06T10:23:59-08:00","dateModified": "2019-10-06T10:23:59-08:00","publisher": {
            "@type": "Organization",
            "name": "作者"},"author": {
                "@type": "Person",
                "name": "作者"
            },"description": ""
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="povcfe&#39;s blog">povcfe&#39;s blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="povcfe&#39;s blog">povcfe&#39;s blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">glibc2.23 ptmalloc 原理概述</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>作者</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/linux%E7%94%A8%E6%88%B7%E6%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="far fa-folder fa-fw"></i>linux用户态源码分析</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2019-10-06">2019-10-06</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 1626 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 8 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#malloc">malloc</a>
      <ul>
        <li><a href="#__libc_malloc传入参数size">__libc_malloc(传入参数:size)</a></li>
        <li><a href="#_int_malloc">_int_malloc</a></li>
        <li><a href="#malloc_consolidate">malloc_consolidate</a></li>
      </ul>
    </li>
    <li><a href="#free">free</a>
      <ul>
        <li><a href="#__libc_free传入参数待释放指针">__libc_free(传入参数:待释放指针)</a></li>
        <li><a href="#_int_free1分配区指针2chunk指针3分配区互斥锁">_int_free(1.分配区指针，2.chunk指针，3.分配区互斥锁)</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p><a href="https://bbs.pediy.com/user-839858.htm" target="_blank" rel="noopener noreffer">发表于看雪论坛</a></p>
<blockquote>
<p>linux用户态下的堆溢出利用即是对ptmalloc2安全机制的绕过，只有深入的了解ptmalloc，才能进行精准的堆溢出攻击</p>
</blockquote>
<h2 id="malloc">malloc</h2>
<h3 id="__libc_malloc传入参数size">__libc_malloc(传入参数:size)</h3>
<ol>
<li>判断 <strong>是否定义hook函数</strong> ，如果存在则调用hook函数，否则跳到2</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)</span> <span class="p">(</span><span class="n">size_t</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
    <span class="o">=</span> <span class="n">atomic_forced_read</span> <span class="p">(</span><span class="n">__malloc_hook</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">hook</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">RETURN_ADDRESS</span> <span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</code></pre></div><ol start="2">
<li>执行arena_get得到空闲分配区</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">arena_get</span> <span class="p">(</span><span class="n">ar_ptr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
</code></pre></div><ol start="3">
<li>调用_int_malloc()获得内存地址</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">victim</span> <span class="o">=</span> <span class="n">_int_malloc</span> <span class="p">(</span><span class="n">ar_ptr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
</code></pre></div><ol start="4">
<li>如果分配失败，ptmalloc会尝试再去寻找一个可用的arena并进行内存分配</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">victim</span> <span class="o">&amp;&amp;</span> <span class="n">ar_ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">LIBC_PROBE</span> <span class="p">(</span><span class="n">memory_malloc_retry</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
      <span class="n">ar_ptr</span> <span class="o">=</span> <span class="n">arena_get_retry</span> <span class="p">(</span><span class="n">ar_ptr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
      <span class="n">victim</span> <span class="o">=</span> <span class="n">_int_malloc</span> <span class="p">(</span><span class="n">ar_ptr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div><ol start="5">
<li>得到内存地址后解锁分配区</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">ar_ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">mutex_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ar_ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</code></pre></div><ol start="6">
<li>如果在上面的步骤中获得非mmap得到的chunk，但是chunk对应的分配区与实际的分配区不相符，则程序终止</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">assert</span> <span class="p">(</span><span class="o">!</span><span class="n">victim</span> <span class="o">||</span> <span class="n">chunk_is_mmapped</span> <span class="p">(</span><span class="n">mem2chunk</span> <span class="p">(</span><span class="n">victim</span><span class="p">))</span> <span class="o">||</span>
          <span class="n">ar_ptr</span> <span class="o">==</span> <span class="n">arena_for_chunk</span> <span class="p">(</span><span class="n">mem2chunk</span> <span class="p">(</span><span class="n">victim</span><span class="p">)));</span>
</code></pre></div><h3 id="_int_malloc">_int_malloc</h3>
<ul>
<li>errout:
<ul>
<li>打印错误字符串并 return</li>
</ul>
</li>
</ul>
<ol>
<li>判断 <strong>size是否大于(unsigned long)(-2*MINSIZE)</strong> MINSIZE=chunk的最小大小 ，如果是则return，否则将size转换为chunk_size</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define checked_request2size(req, sz)                             \
</span><span class="cp">  if (REQUEST_OUT_OF_RANGE (req)) {					      \
</span><span class="cp">      __set_errno (ENOMEM);						      \
</span><span class="cp">      return 0;								      \
</span><span class="cp">    }									      \
</span><span class="cp">  (sz) = request2size (req);
</span></code></pre></div><ol start="2">
<li>判断 <strong>前面是否没有获得空闲分配区</strong> 如果是则跳到3，否则跳到4</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">av</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
</code></pre></div><ol start="3">
<li>调用sysmalloc尝试获得chunk地址，如果得到则调用alloc_perturb 将清理空间数据，return chunk地址</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">av</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">sysmalloc</span> <span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="n">av</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="n">alloc_perturb</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div><ol start="4">
<li>(从fastbin中分配chunk) 判断 <strong>size是否小于global_max_fast</strong> ,如果是跳到5，否则跳到10</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">get_max_fast</span> <span class="p">()))</span>
</code></pre></div><ol start="5">
<li>根据size获得fastbin索引x，定位当前分配区fastbin<i class="far fa-check-square fa-fw"></i> </li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">get_max_fast</span> <span class="p">()))</span>
    <span class="p">{</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">fastbin_index</span> <span class="p">(</span><span class="n">nb</span><span class="p">);</span>
    <span class="n">mfastbinptr</span> <span class="o">*</span><span class="n">fb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fastbin</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
    <span class="n">mchunkptr</span> <span class="n">pp</span> <span class="o">=</span> <span class="o">*</span><span class="n">fb</span><span class="p">;</span>
</code></pre></div><ol start="6">
<li>令victim=fastbin<i class="far fa-check-square fa-fw"></i> ,判断 <strong>victim是否等于NULL</strong> 如果是则跳到7，否则fastbin<i class="far fa-check-square fa-fw"></i> =fastbin<i class="far fa-check-square fa-fw"></i> -&gt;fd</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">do</span>
<span class="p">{</span>
    <span class="n">victim</span> <span class="o">=</span> <span class="n">pp</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">victim</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">while</span> <span class="p">((</span><span class="n">pp</span> <span class="o">=</span> <span class="n">catomic_compare_and_exchange_val_acq</span> <span class="p">(</span><span class="n">fb</span><span class="p">,</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">victim</span><span class="p">))</span>
             <span class="o">!=</span> <span class="n">victim</span><span class="p">);</span>
</code></pre></div><ol start="7">
<li>
<p>判断 <strong>victim是否不等于0</strong> 如果是跳到8，否则跳到10</p>
</li>
<li>
<p>判断 <strong>victim_size对应的fastbin索引是否不等于size对应的fastbin索引</strong> ，如果是则goto errout <strong>(errstr = &ldquo;malloc(): memory corruption (fast)&quot;)</strong> 否则跳到9</p>
</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">fastbin_index</span> <span class="p">(</span><span class="n">chunksize</span> <span class="p">(</span><span class="n">victim</span><span class="p">))</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;malloc(): memory corruption (fast)&#34;</span><span class="p">;</span>
    <span class="nl">errout</span><span class="p">:</span>
        <span class="n">malloc_printerr</span> <span class="p">(</span><span class="n">check_action</span><span class="p">,</span> <span class="n">errstr</span><span class="p">,</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">),</span> <span class="n">av</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div><ol start="9">
<li>将victim chunk指针转换为用户数据区指针，调用alloc_perturb()对用户数据区进行初始化，return</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>
<span class="n">alloc_perturb</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
</code></pre></div><ol start="10">
<li>(从smallbin中分配chunk) 判断 <strong>size是否在smallbin范围(小于MIN_LARGE_SIZE)内</strong> 如果是则跳到11，否则跳到18</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">nb</span><span class="p">))</span>
</code></pre></div><ol start="11">
<li>根据size获得smallbin的索引x，定位本分配区的smallbin<i class="far fa-check-square fa-fw"></i> </li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">idx</span> <span class="o">=</span> <span class="n">smallbin_index</span> <span class="p">(</span><span class="n">nb</span><span class="p">);</span>
<span class="n">bin</span> <span class="o">=</span> <span class="n">bin_at</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
</code></pre></div><ol start="12">
<li>
<p>令victim等于smallbin<i class="far fa-check-square fa-fw"></i> -&gt;bk,判断 <strong>smallbin<i class="far fa-check-square fa-fw"></i> -&gt;bk是否不等于smallbin<i class="far fa-check-square fa-fw"></i> (即smallbin是否不为空)</strong> 如果是则跳到13，否则跳到18</p>
</li>
<li>
<p>判断 <strong>smallbin<i class="far fa-check-square fa-fw"></i> -&gt;bk是否等于0</strong> 如果是则执行malloc_consolidate进行初始化，否则跳到14</p>
</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">victim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* initialization check */</span>
    <span class="n">malloc_consolidate</span> <span class="p">(</span><span class="n">av</span><span class="p">);</span>
</code></pre></div><ol start="14">
<li>判断 <strong>victim-&gt;bk-&gt;fd是否不等于victim</strong> 如果是则goto errout <strong>(errstr = &ldquo;malloc(): smallbin double linked list corrupted&rdquo;)</strong> 否则跳到15</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">bck</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">!=</span> <span class="n">victim</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;malloc(): smallbin double linked list corrupted&#34;</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div><ol start="15">
<li>设置victim的下一个chunk 标志位为pre_chunk_inuse,将smallbin<i class="far fa-check-square fa-fw"></i> -&gt;bk从双链表中摘除(smallbin<i class="far fa-check-square fa-fw"></i> -&gt;bk＝smallbin<i class="far fa-check-square fa-fw"></i> -&gt;bk-&gt;bk,smallbin<i class="far fa-check-square fa-fw"></i> -&gt;bk-&gt;fd=smallbin<i class="far fa-check-square fa-fw"></i> )</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">set_inuse_bit_at_offset</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="n">bin</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>
<span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">bin</span><span class="p">;</span>
</code></pre></div><ol start="16">
<li>如果当前分配区不是main_arena,则设置victim的标志位为NON_MAIN_ARENA</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span>
    <span class="n">victim</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">|=</span> <span class="n">NON_MAIN_ARENA</span><span class="p">;</span>
</code></pre></div><ol start="17">
<li>将victim chunk指针转换为用户数据区指针，调用alloc_perturb()对用户数据区进行初始化，return</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>
<span class="n">alloc_perturb</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
</code></pre></div><ol start="18">
<li>根据size获得largebin的索引x</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">idx</span> <span class="o">=</span> <span class="n">largebin_index</span> <span class="p">(</span><span class="n">nb</span><span class="p">);</span>
</code></pre></div><ol start="19">
<li>判断<strong>当前分配区是否存在fastbin</strong> (通过flag标志位)如果是则执行malloc_consolidate合并fastbin</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">have_fastchunks</span> <span class="p">(</span><span class="n">av</span><span class="p">))</span>
    <span class="n">malloc_consolidate</span> <span class="p">(</span><span class="n">av</span><span class="p">);</span>
</code></pre></div><ol start="20">
<li>(处理unsortedbin) 令victim等于unsortedbin-&gt;bk, (while循环/20-32/ 直至unsortedbin为空) 判断 <strong>unsortedbin-&gt;bk是否不等于unsortedbin</strong> ，如果是跳到21，否则跳到32</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">while</span> <span class="p">((</span><span class="n">victim</span> <span class="o">=</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">)</span> <span class="o">!=</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">))</span>
</code></pre></div><ol start="21">
<li>判断 <strong>victim_size是否小于等于2*SIZE_SZ或者victim_size是否大于system_mem</strong> ,如果是则打印错误 <strong>(&ldquo;malloc(): memory corruption&rdquo;)</strong> 并退出，否则跳到22</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
              <span class="o">||</span> <span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">malloc_printerr</span> <span class="p">(</span><span class="n">check_action</span><span class="p">,</span> <span class="s">&#34;malloc(): memory corruption&#34;</span><span class="p">,</span>
    <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">),</span> <span class="n">av</span><span class="p">);</span>
</code></pre></div><ol start="22">
<li>判断 <strong>size是否在smallbin范围内并且victim-&gt;bk是否等于unsortedbin(即unsorted bin 是否只存在一个chunk)并且unsortedbin的当前chunk是否为last_remainder并且victim_size是否大于(nb+MINSIZE)</strong> 如果是则切割chunk并产生last_remainder,否则跳到25</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">nb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
              <span class="n">bck</span> <span class="o">==</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
              <span class="n">victim</span> <span class="o">==</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">last_remainder</span> <span class="o">&amp;&amp;</span>
              <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span> <span class="o">+</span> <span class="n">MINSIZE</span><span class="p">))</span>
<span class="p">{</span>
    <span class="cm">/* split and reattach remainder */</span>
    <span class="n">remainder_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">nb</span><span class="p">;</span>
    <span class="n">remainder</span> <span class="o">=</span> <span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
    <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
    <span class="n">av</span><span class="o">-&gt;</span><span class="n">last_remainder</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
</code></pre></div><ol start="23">
<li>如果切割后的last_remainder_size在smallbin范围内，则将新的last_remainder的fd_nextsize和bk_nextsize清零</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">remainder_size</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ol start="24">
<li>设置victim的pre_inuse和main_arena标志位，设置last_remainder的pre_inuse标志位和last_remainder下一个块的pre_inuse标志位，将victim转换为用户数据区地址，调用alloc_perturb()对用户数据区进行初始化，return</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">set_head</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span> <span class="o">|</span> <span class="n">PREV_INUSE</span> <span class="o">|</span>
                        <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span> <span class="o">?</span> <span class="nl">NON_MAIN_ARENA</span> <span class="p">:</span> <span class="mi">0</span><span class="p">));</span>
<span class="n">set_head</span> <span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remainder_size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>
<span class="n">set_foot</span> <span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remainder_size</span><span class="p">);</span>

<span class="n">check_malloced_chunk</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>
<span class="n">alloc_perturb</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
</code></pre></div><ol start="25">
<li>将victim从unsortedbin中移除</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>
<span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">);</span>
</code></pre></div><ol start="26">
<li>
<p>判断 <strong>victim_size是否等于size(即当前unsortedbin是否与请求等大)</strong> 如果是则跳到27，否则跳到28</p>
</li>
<li>
<p>设置victim下一个块的pre_inuse标志位，设置victim的main_arena标志位，将victim转换为用户数据区地址，调用alloc_perturb()对用户数据区进行初始化，return</p>
</li>
<li>
<p>(将unsortedbin放入对应的smallbin或者largebin) 判断 <strong>victim_size是否在smallbin范围内</strong> 如果是则获得victim在smallbin中的索引y及其在smallbin[y]目标放置位的前一个块和后一个块(放在smallbin的头部)然后跳到31，否则跳到29</p>
</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">size</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">victim_index</span> <span class="o">=</span> <span class="n">smallbin_index</span> <span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="n">bck</span> <span class="o">=</span> <span class="n">bin_at</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim_index</span><span class="p">);</span>
    <span class="n">fwd</span> <span class="o">=</span> <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ol start="29">
<li>获得victim在largebin中的索引y及其前一个块和后一个块(largebin[y]中chunk按大小排列,具体方法见30)</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">victim_index</span> <span class="o">=</span> <span class="n">largebin_index</span> <span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="n">bck</span> <span class="o">=</span> <span class="n">bin_at</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim_index</span><span class="p">);</span>
<span class="n">fwd</span> <span class="o">=</span> <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
</code></pre></div><ol start="30">
<li>
<p>利用循环和fd_nextsize指针寻找大于victim_size的chunk(如果victim_size小于最小的chunk,则不进入循环)</p>
</li>
<li>
<p>设置分配区的binmap，将victim插入目标放置</p>
</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">mark_bin</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim_index</span><span class="p">);</span>
<span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>
<span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fwd</span><span class="p">;</span>
<span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">victim</span><span class="p">;</span>
<span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">victim</span><span class="p">;</span>
</code></pre></div><ol start="32">
<li>迭代器＋1，当迭代器小于10000时，跳回20</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define MAX_ITERS       10000
</span><span class="cp"></span><span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">iters</span> <span class="o">&gt;=</span> <span class="n">MAX_ITERS</span><span class="p">)</span>
    <span class="k">break</span><span class="p">;</span>
</code></pre></div><ol start="33">
<li>(从largebin中分配chunk) 判断 <strong>size是否不在smallbin范围内</strong> 如果是跳到34，否则跳到40</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">nb</span><span class="p">))</span>
</code></pre></div><ol start="34">
<li>定位largebin<i class="far fa-check-square fa-fw"></i> ,令victim = largebin<i class="far fa-check-square fa-fw"></i> -&gt;fd,判断 <strong>victim是否不等于&amp;largebin<i class="far fa-check-square fa-fw"></i> (largebin 是否不为空)并且victim_size是否大于等于size</strong> 如果是则跳到35，否则跳到40</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">((</span><span class="n">victim</span> <span class="o">=</span> <span class="n">first</span> <span class="p">(</span><span class="n">bin</span><span class="p">))</span> <span class="o">!=</span> <span class="n">bin</span> <span class="o">&amp;&amp;</span>
    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span><span class="p">))</span>
</code></pre></div><ol start="35">
<li>利用bk_nextsize找到chunk(同步赋值给victim),使得victim_size大于size</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">victim</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="n">chunksize</span> <span class="p">(</span><span class="n">victim</span><span class="p">))</span> <span class="o">&lt;</span>
        <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span><span class="p">)))</span>
<span class="n">victim</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="p">;</span>
</code></pre></div><ol start="36">
<li>如果victim不等于largebin<i class="far fa-check-square fa-fw"></i> -&gt;bk且victim_size等于victim-&gt;fd-&gt;size，则令victim=victim-&gt;fd</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">victim</span> <span class="o">!=</span> <span class="n">last</span> <span class="p">(</span><span class="n">bin</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
    <span class="n">victim</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
</code></pre></div><ol start="37">
<li>使用unlink取出victim，切割largebin，判断 <strong>remainder_size是否小于MINSIZE</strong> 如果是则只设置victim的下一个块的标志位pre_inuse和main_arena，否则跳到38</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">remainder_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">nb</span><span class="p">;</span>
<span class="n">unlink</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">bck</span><span class="p">,</span> <span class="n">fwd</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">remainder_size</span> <span class="o">&lt;</span> <span class="n">MINSIZE</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">set_inuse_bit_at_offset</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span>
    <span class="n">victim</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">|=</span> <span class="n">NON_MAIN_ARENA</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ol start="38">
<li>将剩余的chunk放入unsortedbin 判断 <strong>unsortedbin-&gt;fd-&gt;bk是否不等于unsortedbin</strong> ，如果是则goto errout <strong>errstr = &ldquo;malloc(): corrupted unsorted chunks&rdquo;</strong></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">remainder</span> <span class="o">=</span> <span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="cm">/* We cannot assume the unsorted list is empty and therefore
</span><span class="cm">    have to perform a complete insert here.  */</span>
<span class="n">bck</span> <span class="o">=</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">);</span>
<span class="n">fwd</span> <span class="o">=</span> <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">!=</span> <span class="n">bck</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;malloc(): corrupted unsorted chunks&#34;</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ol start="39">
<li>
<p>设置剩余chunk的标志位及bin链表，将victim转换为用户数据区地址，调用alloc_perturb()对用户数据区进行初始化，return</p>
</li>
<li>
<p>遍历largebin寻找满足要求的空闲块(使用binmap和block缩短检索时间)，如果找到则按照上诉方式分配victim，否则跳到41</p>
</li>
<li>
<p>(从top_chunk中分配chunk) 令victim等于top_chunk,判断 <strong>top_chunk_size是否大于等于(size+MINSIZE)</strong> 如果是则切割top_chunk赋值给victim,将victim转换为用户数据区地址，调用alloc_perturb()对用户数据区进行初始化，return 否则跳到42</p>
</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">victim</span> <span class="o">=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
<span class="n">size</span> <span class="o">=</span> <span class="n">chunksize</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>

<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span> <span class="o">+</span> <span class="n">MINSIZE</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">remainder_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">nb</span><span class="p">;</span>
    <span class="n">remainder</span> <span class="o">=</span> <span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
    <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
    <span class="n">set_head</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span> <span class="o">|</span> <span class="n">PREV_INUSE</span> <span class="o">|</span>
            <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span> <span class="o">?</span> <span class="nl">NON_MAIN_ARENA</span> <span class="p">:</span> <span class="mi">0</span><span class="p">));</span>
    <span class="n">set_head</span> <span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remainder_size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>

    <span class="n">check_malloced_chunk</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>
    <span class="n">alloc_perturb</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ol start="42">
<li>判断 <strong>分配区是否存在fastbin</strong> 如果存在则执行malloc_consolidate()，获得size 在bin中的索引，否则跳到43</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">have_fastchunks</span> <span class="p">(</span><span class="n">av</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">malloc_consolidate</span> <span class="p">(</span><span class="n">av</span><span class="p">);</span>
    <span class="cm">/* restore original bin index */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">nb</span><span class="p">))</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">smallbin_index</span> <span class="p">(</span><span class="n">nb</span><span class="p">);</span>
    <span class="k">else</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">largebin_index</span> <span class="p">(</span><span class="n">nb</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><ol start="43">
<li>使用sysmalloc分配空间，使用alloc_perturb 清空内存，return</li>
</ol>
<pre><code>else
{
    void *p = sysmalloc (nb, av);
    if (p != NULL)
    alloc_perturb (p, bytes);
    return p;
}
</code></pre><h3 id="malloc_consolidate">malloc_consolidate</h3>
<ol>
<li>如果max_fast不为0，则清空分配区have_fastbin标志，否则执行malloc_init_state进行初始化</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">get_max_fast</span> <span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">clear_fastchunks</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>
<span class="p">...</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="n">malloc_init_state</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>
    <span class="n">check_malloc_state</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div><ol start="2">
<li>获得unsortedbin，fastbin[0]，fastbin[MAX]地址</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">maxfb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fastbin</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">NFASTBINS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">fb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fastbin</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div><ol start="3">
<li>
<p>遍历fastbin中的所有chunk，对每个chunk做如下操作</p>
</li>
<li>
<p>获得chunk_size,下一个块的地址与next_chunk_size</p>
</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">size</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">PREV_INUSE</span><span class="o">|</span><span class="n">NON_MAIN_ARENA</span><span class="p">);</span>
<span class="n">nextchunk</span> <span class="o">=</span> <span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="n">nextsize</span> <span class="o">=</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">nextchunk</span><span class="p">);</span>
</code></pre></div><ol start="5">
<li>判断 <strong>上一个块是否空闲</strong> 如果是则合并chunk，并使用unlink将上一个块从bin中释放，否则跳到6</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev_inuse</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">prevsize</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prev_size</span><span class="p">;</span>
    <span class="n">size</span> <span class="o">+=</span> <span class="n">prevsize</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span> <span class="n">prevsize</span><span class="p">));</span>
    <span class="n">unlink</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">bck</span><span class="p">,</span> <span class="n">fwd</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div><ol start="6">
<li>
<p>判断 <strong>下一个块是否不是是top_chunk</strong> 如果是则跳到7，否则跳到9</p>
</li>
<li>
<p>判断 <strong>下一个块是否空闲</strong> 如果是则合并chunk，并使用unlink将下一个块从bin中释放，否则跳到8</p>
</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">nextinuse</span> <span class="o">=</span> <span class="n">inuse_bit_at_offset</span><span class="p">(</span><span class="n">nextchunk</span><span class="p">,</span> <span class="n">nextsize</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nextinuse</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">size</span> <span class="o">+=</span> <span class="n">nextsize</span><span class="p">;</span>
    <span class="n">unlink</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">nextchunk</span><span class="p">,</span> <span class="n">bck</span><span class="p">,</span> <span class="n">fwd</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><ol start="8">
<li>将chunk插入unsortedbin头部，return</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">unsorted_bin</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="n">first_unsorted</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">set_head</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">unsorted_bin</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">first_unsorted</span><span class="p">;</span>
</code></pre></div><ol start="9">
<li>将chunk与top_chunk合并，return</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">else</span> <span class="p">{</span>
    <span class="n">size</span> <span class="o">+=</span> <span class="n">nextsize</span><span class="p">;</span>
    <span class="n">set_head</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>
    <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="free">free</h2>
<h3 id="__libc_free传入参数待释放指针">__libc_free(传入参数:待释放指针)</h3>
<ol>
<li>判断 <strong>是否定义hook函数</strong> ，如果存在则调用hook函数，否则跳到2</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
    <span class="o">=</span> <span class="n">atomic_forced_read</span> <span class="p">(</span><span class="n">__free_hook</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">hook</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">{</span>
    <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)(</span><span class="n">mem</span><span class="p">,</span> <span class="n">RETURN_ADDRESS</span> <span class="p">(</span><span class="mi">0</span><span class="p">));</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ol start="2">
<li>判断 <strong>传入指针是否为0</strong> ，如果为0(0为无效指针)则return，否则跳到3</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">mem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>                              <span class="cm">/* free(0) has no effect */</span>
    <span class="k">return</span><span class="p">;</span>
</code></pre></div><ol start="3">
<li>
<p>将传入指针转换为chunk指针</p>
</li>
<li>
<p>判断 <strong>chunk是否是由mmap分配得到</strong> ，如果是则跳到5，否则跳到8</p>
</li>
<li>
<p>判断 <strong>是否没有禁用动态阈值选项且chunk大小是否大于mmap分配阈值且chunk大小是否小于mmap默认最大分配阈值</strong> ，如果是则跳到6，否则跳到7</p>
</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">chunk_is_mmapped</span> <span class="p">(</span><span class="n">p</span><span class="p">))</span>                       <span class="cm">/* release mmapped memory. */</span>
<span class="p">{</span>
    <span class="cm">/* see if the dynamic brk/mmap threshold needs adjusting */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mp_</span><span class="p">.</span><span class="n">no_dyn_threshold</span>
        <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">mp_</span><span class="p">.</span><span class="n">mmap_threshold</span>
        <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">DEFAULT_MMAP_THRESHOLD_MAX</span><span class="p">)</span>
</code></pre></div><ol start="6">
<li>设置mmap分配阈值等于chunk_size，top_chunk收缩阈值等于chunk_size*2</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="p">{</span>
    <span class="n">mp_</span><span class="p">.</span><span class="n">mmap_threshold</span> <span class="o">=</span> <span class="n">chunksize</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="n">mp_</span><span class="p">.</span><span class="n">trim_threshold</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mp_</span><span class="p">.</span><span class="n">mmap_threshold</span><span class="p">;</span>
    <span class="n">LIBC_PROBE</span> <span class="p">(</span><span class="n">memory_mallopt_free_dyn_thresholds</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">mp_</span><span class="p">.</span><span class="n">mmap_threshold</span><span class="p">,</span> <span class="n">mp_</span><span class="p">.</span><span class="n">trim_threshold</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><ol start="7">
<li>执行munmap_chunk释放chunk，然后return</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">munmap_chunk</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="k">return</span><span class="p">;</span>
</code></pre></div><ol start="8">
<li>获得chunk的分配区，并执行_int_free函数</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">ar_ptr</span> <span class="o">=</span> <span class="n">arena_for_chunk</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="n">_int_free</span> <span class="p">(</span><span class="n">ar_ptr</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div><h3 id="_int_free1分配区指针2chunk指针3分配区互斥锁">_int_free(1.分配区指针，2.chunk指针，3.分配区互斥锁)</h3>
<ul>
<li>errout:
<ol>
<li>判断 <strong>分配区是否被锁</strong> ，如果是则解锁分配区</li>
<li>打印错误字符串并 return</li>
</ol>
</li>
</ul>
<ol>
<li>获得chunk_size</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">size</span> <span class="o">=</span> <span class="n">chunksize</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
</code></pre></div><ol start="2">
<li>判断 <strong>chunk指针是否大于-chunk_size(unsigned)或者chunk指针是否不关于MALOOC_ALIGN_MASK字节对齐</strong> 如果是则goto errout <strong>errstr = &ldquo;free(): invalid pointer&rdquo;</strong></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">((</span><span class="n">uintptr_t</span><span class="p">)</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">uintptr_t</span><span class="p">)</span> <span class="o">-</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
      <span class="o">||</span> <span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">misaligned_chunk</span> <span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;free(): invalid pointer&#34;</span><span class="p">;</span>
<span class="nl">errout</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">have_lock</span> <span class="o">&amp;&amp;</span> <span class="n">locked</span><span class="p">)</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">mutex_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">malloc_printerr</span> <span class="p">(</span><span class="n">check_action</span><span class="p">,</span> <span class="n">errstr</span><span class="p">,</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">av</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ol start="3">
<li>判断 <strong>chunk_size是否小于MINSIZE或者chunk_size是否不关于MALOOC_ALIGN_MASK字节对齐</strong> 如果是则goto errout <strong>(errstr = &ldquo;free(): invalid size&rdquo;)</strong></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">MINSIZE</span> <span class="o">||</span> <span class="o">!</span><span class="n">aligned_OK</span> <span class="p">(</span><span class="n">size</span><span class="p">)))</span>
<span class="p">{</span>
    <span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;free(): invalid size&#34;</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ol start="4">
<li>(释放到fastbin) 判断 <strong>chunk_size是否小于等于global_max_fast</strong> 如果是则跳到5，否则跳到10</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">size</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">get_max_fast</span> <span class="p">())</span>
</code></pre></div><ol start="5">
<li>分配区加锁，判断 <strong>分配区是否加锁或者next_chunk_size是否小于等于2*sizeof(INTERNAL_SIZE_T)或者next_chunk_size是否大于等于av-&gt;system_mem</strong> ，如果是则goto errout <strong>(errstr = &ldquo;free(): invalid next size (fast)&quot;</strong></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">have_lock</span>
    <span class="o">||</span> <span class="p">({</span> <span class="n">assert</span> <span class="p">(</span><span class="n">locked</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">locked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span>
        <span class="o">||</span> <span class="n">chunksize</span> <span class="p">(</span><span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span><span class="p">;</span>
        <span class="p">}))</span>
<span class="p">{</span>
<span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;free(): invalid next size (fast)&#34;</span><span class="p">;</span>
<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ol start="6">
<li>解锁分配区，设置分配区flag的has_fastbin比特位为1，根据chunk_size寻找对应fastbins的索引x，根据分配区和索引位置找到chunk对应的&amp;fastbin<i class="far fa-check-square fa-fw"></i> </li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">set_fastchunks</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">fastbin_index</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="n">fb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fastbin</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
</code></pre></div><ol start="7">
<li>判断 <strong>chunk是否等于fastbin<i class="far fa-check-square fa-fw"></i> </strong> 如果是则goto errout <strong>(errstr = &ldquo;double free or corruption (fasttop)&quot;)</strong></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">old</span> <span class="o">==</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;double free or corruption (fasttop)&#34;</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ol start="8">
<li>获得fastbin<i class="far fa-check-square fa-fw"></i> -&gt;size对应的fastbin索引y，将chunk插入fastbin头部</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">old_idx</span> <span class="o">=</span> <span class="n">fastbin_index</span><span class="p">(</span><span class="n">chunksize</span><span class="p">(</span><span class="n">old</span><span class="p">));</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">old2</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>
</code></pre></div><ol start="9">
<li>判断 <strong>分配区是否加锁且fastbin<i class="far fa-check-square fa-fw"></i> 是否不为0且x与y是否不相同</strong> 如果是，则goto errout <strong>(errstr = &ldquo;invalid fastbin entry (free)&quot;</strong> 否则return</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">have_lock</span> <span class="o">&amp;&amp;</span> <span class="n">old</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">old_idx</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;invalid fastbin entry (free)&#34;</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ol start="10">
<li>
<p>(释放到unsortedbin) 判断 <strong>chunk是否不是mmap函数分配的</strong> 如果是则跳到11，否则跳到27</p>
</li>
<li>
<p>分配区加锁</p>
</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunk_is_mmapped</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">have_lock</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">locked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ol start="12">
<li>判断 <strong>chunk是否是top_chunk</strong> 如果是则goto errout <strong>(errstr = &ldquo;double free or corruption (top)&quot;</strong></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">nextchunk</span> <span class="o">=</span> <span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="cm">/* Lightweight tests: check whether the block is already the
</span><span class="cm">    top block.  */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;double free or corruption (top)&#34;</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ol start="13">
<li>判断 <strong>分配区是否可以分配连续空间且next_chunk指针是否大于(top_chunk指针+top_chunk_size)</strong> 如果是则goto errout <strong>(errstr = &ldquo;double free or corruption (out)&quot;</strong></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">contiguous</span> <span class="p">(</span><span class="n">av</span><span class="p">)</span>
    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">nextchunk</span>
    <span class="o">&gt;=</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">+</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">)),</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;double free or corruption (out)&#34;</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ol start="14">
<li>判断 <strong>next_chunk的pre_inuse标志是否为0</strong> 如果是，则goto errout <strong>(errstr = &ldquo;double free or corruption (!prev)&quot;</strong></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="o">!</span><span class="n">prev_inuse</span><span class="p">(</span><span class="n">nextchunk</span><span class="p">)))</span>
<span class="p">{</span>
    <span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;double free or corruption (!prev)&#34;</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ol start="15">
<li>判断 <strong>next_chunk_size是否小于2*sizeof(size_t)或者next_chunk_size是否大于av-&gt;system_mem</strong> 如果是则goto errout <strong>(errstr = &ldquo;free(): invalid next size (normal)&quot;</strong></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">nextsize</span> <span class="o">=</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">nextchunk</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">nextchunk</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="o">||</span> <span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">nextsize</span> <span class="o">&gt;=</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;free(): invalid next size (normal)&#34;</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ol start="16">
<li>判断 <strong>pre_chunk是否是空闲的</strong> 如果是则使用unlink取出pre_chunk，使chunk等于pre_chunk</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev_inuse</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">prevsize</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prev_size</span><span class="p">;</span>
    <span class="n">size</span> <span class="o">+=</span> <span class="n">prevsize</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span> <span class="n">prevsize</span><span class="p">));</span>
    <span class="n">unlink</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">bck</span><span class="p">,</span> <span class="n">fwd</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><ol start="17">
<li>
<p>判断 <strong>next_chunk是否等于top_chunk</strong> 如果是，则跳到22</p>
</li>
<li>
<p>判断 <strong>next_chunk是否是空闲的</strong> 如果是则使用unlink取出next_chunk,否则清空next_chunk的pre_inuse</p>
</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nextinuse</span><span class="p">)</span> <span class="p">{</span>
<span class="n">unlink</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">nextchunk</span><span class="p">,</span> <span class="n">bck</span><span class="p">,</span> <span class="n">fwd</span><span class="p">);</span>
<span class="n">size</span> <span class="o">+=</span> <span class="n">nextsize</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span>
<span class="n">clear_inuse_bit_at_offset</span><span class="p">(</span><span class="n">nextchunk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div><ol start="19">
<li>
<p>获得unsorted_bin地址</p>
</li>
<li>
<p>判断 <strong>unsorted_bin-&gt;fd-&gt;bk是否不等于unsorted_bin</strong> 如果是，则goto errout <strong>(errstr = &ldquo;free(): corrupted unsorted chunks&rdquo;</strong></p>
</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">bck</span> <span class="o">=</span> <span class="n">unsorted_chunks</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>
<span class="n">fwd</span> <span class="o">=</span> <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">!=</span> <span class="n">bck</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">errstr</span> <span class="o">=</span> <span class="s">&#34;free(): corrupted unsorted chunks&#34;</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ol start="21">
<li>
<p>将chunk插入unsortedbin(bk处),如果chunk_size不在small_bin范围则清空chunk的fd_nextsize和bk_nextsize区域，设置chunk的pre_inuse,size，跳到23</p>
</li>
<li>
<p>跳到此处说明，chunk与top_chunk相邻，top_chunk会合并当前chunk</p>
</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">else</span> <span class="p">{</span>
    <span class="n">size</span> <span class="o">+=</span> <span class="n">nextsize</span><span class="p">;</span>
    <span class="n">set_head</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>
    <span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">check_chunk</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><ol start="23">
<li>判断 <strong>被释放的最终size是否大于FASTBIN_CONSOLIDATION_THRESHOLD(65536UL)</strong> 如果是则触发malloc_consolidate函数合并fastbin</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">FASTBIN_CONSOLIDATION_THRESHOLD</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">have_fastchunks</span><span class="p">(</span><span class="n">av</span><span class="p">))</span>
    <span class="n">malloc_consolidate</span><span class="p">(</span><span class="n">av</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div><ol start="24">
<li>判断 <strong>分配区是否是main_arena</strong> 如果是则当top_chunk_size大于收缩阈值时，执行systrim函数，收缩top_chunk</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifndef MORECORE_CANNOT_TRIM
</span><span class="cp"></span>	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">chunksize</span><span class="p">(</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">))</span> <span class="o">&gt;=</span>
	    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">mp_</span><span class="p">.</span><span class="n">trim_threshold</span><span class="p">))</span>
	  <span class="n">systrim</span><span class="p">(</span><span class="n">mp_</span><span class="p">.</span><span class="n">top_pad</span><span class="p">,</span> <span class="n">av</span><span class="p">);</span>
<span class="cp">#endif
</span><span class="cp"></span><span class="p">}</span>
</code></pre></div><ol start="25">
<li>如果不是则匹配top_chunk对应的子分配区，当子分配区与当前分配区相同时，执行heap_trim，尝试收缩top_chunk</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">else</span> <span class="p">{</span>
    <span class="cm">/* Always try heap_trim(), even if the top chunk is not
</span><span class="cm">    large, because the corresponding heap might go away.  */</span>
    <span class="n">heap_info</span> <span class="o">*</span><span class="n">heap</span> <span class="o">=</span> <span class="n">heap_for_ptr</span><span class="p">(</span><span class="n">top</span><span class="p">(</span><span class="n">av</span><span class="p">));</span>

    <span class="n">assert</span><span class="p">(</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">ar_ptr</span> <span class="o">==</span> <span class="n">av</span><span class="p">);</span>
    <span class="n">heap_trim</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">mp_</span><span class="p">.</span><span class="n">top_pad</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><ol start="26">
<li>解锁分配区，然后return</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">av</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</code></pre></div><ol start="27">
<li>(通过munmap释放chunk) 执行munmap_chunk释放chunk</li>
</ol>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2019-10-06</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/linux/">linux</a>,&nbsp;<a href="/tags/ptmalloc/">ptmalloc</a>,&nbsp;<a href="/tags/heap/">heap</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/pwn/" class="prev" rel="prev" title="Pwn思维导图"><i class="fas fa-angle-left fa-fw"></i>Pwn思维导图</a>
            <a href="/posts/kernel_rop1/" class="next" rel="next" title="linux 内核提权总结(demo&#43;exp分析) -- ROP(一)">linux 内核提权总结(demo&#43;exp分析) -- ROP(一)<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank"></a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
